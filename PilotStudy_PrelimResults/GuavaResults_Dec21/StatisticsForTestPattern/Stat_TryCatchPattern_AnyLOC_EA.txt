Project: guava
 Class: SetsTest
 Method: testSubSet_unnaturalOrdering
 Body: {
    ImmutableSortedSet<Integer> set =
        ImmutableSortedSet.<Integer>reverseOrder().add(2, 4, 6, 8, 10).build();

    try {
      Sets.subSet(set, Range.closed(4, 8));
      fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException expected) {
    }

    // These results are all incorrect, but there's no way (short of iterating over the result)
    // to verify that with an arbitrary ordering or comparator.
    assertEquals(ImmutableSortedSet.of(2, 4), Sets.subSet(set, Range.atLeast(4)));
    assertEquals(ImmutableSortedSet.of(8, 10), Sets.subSet(set, Range.atMost(8)));
    assertEquals(ImmutableSortedSet.of(2, 4, 6, 8, 10), Sets.subSet(set, Range.<Integer>all()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: subSet(oneMC) - Predicate: of(outer) - Scenario: set(outer1)

Project: guava
 Class: SetsTest
 Method: testNewSetFromMapIllegal
 Body: {
    Map<Integer, Boolean> map = new LinkedHashMap<>();
    map.put(2, true);
    try {
      Sets.newSetFromMap(map);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: newSetFromMap(unmatched) - Predicate: N/A - Scenario: Sets(unmatched - new object)

Project: guava
 Class: SetsTest
 Method: testPowerSetIteration_manual
 Body: {
    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3);
    Set<Set<Integer>> powerSet = powerSet(elements);
    // The API doesn't promise this iteration order, but it's convenient here.
    Iterator<Set<Integer>> i = powerSet.iterator();
    assertEquals(ImmutableSet.of(), i.next());
    assertEquals(ImmutableSet.of(1), i.next());
    assertEquals(ImmutableSet.of(2), i.next());
    assertEquals(ImmutableSet.of(2, 1), i.next());
    assertEquals(ImmutableSet.of(3), i.next());
    assertEquals(ImmutableSet.of(3, 1), i.next());
    assertEquals(ImmutableSet.of(3, 2), i.next());
    assertEquals(ImmutableSet.of(3, 2, 1), i.next());
    assertFalse(i.hasNext());
    try {
      i.next();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: of(outer) - Scenario: i(outer1)

Project: guava
 Class: FutureCallbackTest
 Method: testOnSuccessThrowsError
 Body: {
    class TestError extends Error {}
    TestError error = new TestError();
    String result = "result";
    SettableFuture<String> future = SettableFuture.create();
    @SuppressWarnings("unchecked") // Safe for a mock
    FutureCallback<String> callback = Mockito.mock(FutureCallback.class);
    addCallback(future, callback, directExecutor());
    Mockito.doThrow(error).when(callback).onSuccess(result);
    try {
      future.set(result);
      fail("Should have thrown");
    } catch (TestError e) {
      assertSame(error, e);
    }
    assertEquals(result, future.get());
    Mockito.verify(callback).onSuccess(result);
    Mockito.verifyNoMoreInteractions(callback);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: set(unmatched) - Predicate: N/A(unmatched) - Scenario: future(unmatched - new object)

Project: guava
 Class: MoreExecutorsTest
 Method: testInvokeAnyImpl_nullElement
 Body: {
    ListeningExecutorService e = newDirectExecutorService();
    List<Callable<Integer>> l = new ArrayList<>();
    l.add(
        new Callable<Integer>() {
          @Override
          public Integer call() {
            throw new ArithmeticException("/ by zero");
          }
        });
    l.add(null);
    try {
      invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);
      fail();
    } catch (NullPointerException success) {
    } finally {
      joinPool(e);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: invokeAnyImpl(unmatched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: MoreExecutorsTest
 Method: testInvokeAnyImpl_noTaskCompletes
 Body: {
    ListeningExecutorService e = newDirectExecutorService();
    List<Callable<String>> l = new ArrayList<>();
    l.add(new NPETask());
    try {
      invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);
      fail();
    } catch (ExecutionException success) {
      assertThat(success.getCause()).isInstanceOf(NullPointerException.class);
    } finally {
      joinPool(e);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: invokeAnyImpl(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: MoreExecutorsTest
 Method: testExecuteAfterShutdown
 Body: {
    ExecutorService executor = newDirectExecutorService();
    executor.shutdown();
    try {
      executor.execute(EMPTY_RUNNABLE);
      fail();
    } catch (RejectedExecutionException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: execute(unmatched) - Predicate: N/A - Scenario: executor(matched - new object)

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceThrowOnStartUp
 Body: {
    ThrowOnStartUpService service = new ThrowOnStartUpService();
    assertFalse(service.startUpCalled);

    service.startAsync();
    try {
      service.awaitRunning();
      fail();
    } catch (IllegalStateException expected) {
      assertThat(expected.getCause()).hasMessage("kaboom!");
    }
    executionThread.join();

    assertTrue(service.startUpCalled);
    assertEquals(Service.State.FAILED, service.state());
    assertThat(service.failureCause()).hasMessage("kaboom!");
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(unmatched) - Predicate: N/A(matched) - Scenario: service(matched - new object)

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceThrowOnRun
 Body: {
    ThrowOnRunService service = new ThrowOnRunService();

    service.startAsync();
    try {
      service.awaitTerminated();
      fail();
    } catch (IllegalStateException expected) {
      executionThread.join();
      assertEquals(service.failureCause(), expected.getCause());
      assertThat(expected.getCause()).hasMessage("kaboom!");
    }
    assertTrue(service.shutDownCalled);
    assertEquals(Service.State.FAILED, service.state());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: failureCause(unmatched) - Scenario: service(matched - new object)

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceThrowOnRunAndThenAgainOnShutDown
 Body: {
    ThrowOnRunService service = new ThrowOnRunService();
    service.throwOnShutDown = true;

    service.startAsync();
    try {
      service.awaitTerminated();
      fail();
    } catch (IllegalStateException expected) {
      executionThread.join();
      assertEquals(service.failureCause(), expected.getCause());
      assertThat(expected.getCause()).hasMessage("kaboom!");
    }

    assertTrue(service.shutDownCalled);
    assertEquals(Service.State.FAILED, service.state());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: failureCause(unmatched) - Scenario: service(matched - new object)

Project: guava
 Class: JoinerTest
 Method: testMap
 Body: {
    MapJoiner j = Joiner.on(';').withKeyValueSeparator(':');
    assertEquals("", j.join(ImmutableMap.of()));
    assertEquals(":", j.join(ImmutableMap.of("", "")));

    Map<String, String> mapWithNulls = Maps.newLinkedHashMap();
    mapWithNulls.put("a", null);
    mapWithNulls.put(null, "b");

    try {
      j.join(mapWithNulls);
      fail();
    } catch (NullPointerException expected) {
    }

    assertEquals("a:00;00:b", j.useForNull("00").join(mapWithNulls));

    StringBuilder sb = new StringBuilder();
    j.appendTo(sb, ImmutableMap.of(1, 2, 3, 4, 5, 6));
    assertEquals("1:2;3:4;5:6", sb.toString());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: join(unmatched) - Predicate: join(outer) - Scenario: j(unmatched - new object)

Project: guava
 Class: ServiceManagerTest
 Method: testFailStart_singleServiceCallsHealthy
 Body: {
    Service a = new FailStartService();
    ServiceManager manager = new ServiceManager(asList(a));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);
    try {
      manager.startAsync().awaitHealthy();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertFalse(listener.healthyCalled);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitHealthy(unmatched) - Predicate: N/A(outer) - Scenario: manager.startAsync()(unmatched - new object)

Project: guava
 Class: ServiceManagerTest
 Method: testSingleFailedServiceCallsStopped
 Body: {
    Service a = new FailStartService();
    ServiceManager manager = new ServiceManager(asList(a));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);
    try {
      manager.startAsync().awaitHealthy();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertTrue(listener.stoppedCalled);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitHealthy(unmatched) - Predicate: N/A(outer) - Scenario: manager.startAsync()(unmatched - new object)

Project: guava
 Class: ServiceManagerTest
 Method: testFailStart
 Body: {
    Service a = new NoOpService();
    Service b = new FailStartService();
    Service c = new NoOpService();
    Service d = new FailStartService();
    Service e = new NoOpService();
    ServiceManager manager = new ServiceManager(asList(a, b, c, d, e));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);
    assertState(manager, Service.State.NEW, a, b, c, d, e);
    try {
      manager.startAsync().awaitHealthy();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertFalse(listener.healthyCalled);
    assertState(manager, Service.State.RUNNING, a, c, e);
    assertEquals(ImmutableSet.of(b, d), listener.failedServices);
    assertState(manager, Service.State.FAILED, b, d);
    assertFalse(manager.isHealthy());

    manager.stopAsync().awaitStopped();
    assertFalse(manager.isHealthy());
    assertFalse(listener.healthyCalled);
    assertTrue(listener.stoppedCalled);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitHealthy(unmatched) - Predicate: N/A(outer) - Scenario: manager.startAsync()(unmatched - new object)

Project: guava
 Class: ServiceManagerTest
 Method: testFailRun
 Body: {
    Service a = new NoOpService();
    Service b = new FailRunService();
    ServiceManager manager = new ServiceManager(asList(a, b));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);
    assertState(manager, Service.State.NEW, a, b);
    try {
      manager.startAsync().awaitHealthy();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertTrue(listener.healthyCalled);
    assertEquals(ImmutableSet.of(b), listener.failedServices);

    manager.stopAsync().awaitStopped();
    assertState(manager, Service.State.FAILED, b);
    assertState(manager, Service.State.TERMINATED, a);

    assertTrue(listener.stoppedCalled);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitHealthy(unmatched) - Predicate: N/A(outer) - Scenario: manager.startAsync()(unmatched - new object)

Project: guava
 Class: ConfigurableDirectedGraphTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableDirectedGraphTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);
    try {
      incidentEdges.add(EndpointPair.ordered(N1, N2));
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: incidentEdges(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedGraphTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = graph.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ConfigurableDirectedGraphTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = graph.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: successors(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: CollectionAddAllTester
 Method: testAddAll_nullUnsupported
 Body: {
    List<E> containsNull = singletonList(null);
    try {
      collection.addAll(containsNull);
      fail("addAll(containsNull) should throw");
    } catch (NullPointerException expected) {
    }
    expectUnchanged();
    expectNullMissingWhenNullUnsupported(
        "Should not contain null after unsupported addAll(containsNull)");
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addAll(oneMC) - Predicate: N/A - Scenario: containsNull(outer1)

Project: guava
 Class: FilesTest
 Method: testTouch
 Body: {
    File temp = createTempFile();
    assertTrue(temp.exists());
    assertTrue(temp.delete());
    assertFalse(temp.exists());
    Files.touch(temp);
    assertTrue(temp.exists());
    Files.touch(temp);
    assertTrue(temp.exists());

    try {
      Files.touch(
          new File(temp.getPath()) {
            @Override
            public boolean setLastModified(long t) {
              return false;
            }

            private static final long serialVersionUID = 0;
          });
      fail("expected exception");
    } catch (IOException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: touch(matched) - Predicate: exists(outer) - Scenario: Files(unmatched - new object)

Project: guava
 Class: FilesTest
 Method: testWriteBytes
 Body: {
    File temp = createTempFile();
    byte[] data = newPreFilledByteArray(2000);
    Files.write(data, temp);
    assertTrue(Arrays.equals(data, Files.toByteArray(temp)));

    try {
      Files.write(null, temp);
      fail("expected exception");
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: write(matched) - Predicate: equals(outer) - Scenario: Files(unmatched - new object)

Project: guava
 Class: FilesTest
 Method: testCopyEqualFiles
 Body: {
    File temp1 = createTempFile();
    File temp2 = file(temp1.getPath());
    assertEquals(temp1, temp2);
    Files.write(ASCII, temp1, Charsets.UTF_8);
    try {
      Files.copy(temp1, temp2);
      fail("Expected an IAE to be thrown but wasn't");
    } catch (IllegalArgumentException expected) {
    }
    assertEquals(ASCII, Files.toString(temp1, Charsets.UTF_8));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copy(unmatched) - Predicate: N/A(outer) - Scenario: Files(unmatched - new object)

Project: guava
 Class: FilesTest
 Method: testMoveFailures
 Body: {
    File temp1 = createTempFile();
    File temp2 = createTempFile();

    moveHelper(false, new UnmovableFile(temp1, false, false), temp2);
    moveHelper(
        false, new UnmovableFile(temp1, false, false), new UnmovableFile(temp2, true, false));

    try {
      File asciiFile = getTestFile("ascii.txt");
      moveHelper(false, asciiFile, asciiFile);
      fail("expected exception");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: moveHelper(matched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FilesTest
 Method: testCopySameFile
 Body: {
    File temp = createTempFile();
    Files.write(ASCII, temp, Charsets.UTF_8);
    try {
      Files.copy(temp, temp);
      fail("Expected an IAE to be thrown but wasn't");
    } catch (IllegalArgumentException expected) {
    }
    assertEquals(ASCII, Files.toString(temp, Charsets.UTF_8));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copy(unmatched) - Predicate: toString(outer) - Scenario: Files(unmatched - new object)

Project: guava
 Class: FilesTest
 Method: testCreateParentDirs_nonDirectoryParentExists
 Body: {
    File parent = getTestFile("ascii.txt");
    assertTrue(parent.isFile());
    File file = file(parent, "foo");
    try {
      Files.createParentDirs(file);
      fail();
    } catch (IOException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: createParentDirs(oneMC) - Predicate: isFile(outer) - Scenario: file(outer1)

Project: guava
 Class: FilesTest
 Method: testMap_noSuchFile
 Body: {
    // Setup
    File file = createTempFile();
    boolean deleted = file.delete();
    assertTrue(deleted);

    // Test
    try {
      Files.map(file);
      fail("Should have thrown FileNotFoundException.");
    } catch (FileNotFoundException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: map(oneMC) - Predicate: N/A(outer) - Scenario: deleted(outer1)

Project: guava
 Class: SimpleAbstractMultisetTest
 Method: testRemoveUnsupported
 Body: {
    Multiset<String> multiset = new NoRemoveMultiset<>();
    multiset.add("a");
    try {
      multiset.remove("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    assertTrue(multiset.contains("a"));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(unmatched) - Predicate: contains(outer) - Scenario: multiset(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: addEdge_parallelSelfLoopEdge
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
      fail("Adding a parallel self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addEdge(matched) - Predicate: N/A(inner) - Scenario: N/A

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(successors).containsExactlyElementsIn(network.successors(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: successors(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: AbstractFutureCancellationCauseTest
 Method: testSetFuture_misbehavingFutureDoesNotThrow
 Body: {
    ListenableFuture<String> badFuture =
        new ListenableFuture<String>() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }

          @Override
          public boolean isDone() {
            return true;
          }

          @Override
          public boolean isCancelled() {
            return true; // BAD!!
          }

          @Override
          public String get() {
            return "foo"; // BAD!!
          }

          @Override
          public String get(long time, TimeUnit unit) {
            return "foo"; // BAD!!
          }

          @Override
          public void addListener(Runnable runnable, Executor executor) {
            executor.execute(runnable);
          }
        };
    Future<?> future = newFutureInstance();
    future
        .getClass()
        .getMethod(
            "setFuture",
            future.getClass().getClassLoader().loadClass(ListenableFuture.class.getName()))
        .invoke(future, badFuture);
    try {
      future.get();
      fail();
    } catch (CancellationException expected) {
      assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
      assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A(inner) - Scenario: future(matched - new object)

Project: guava
 Class: AbstractFutureCancellationCauseTest
 Method: testCancel_notDoneNoInterrupt
 Body: {
    Future<?> future = newFutureInstance();
    assertTrue(future.cancel(false));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertNull(tryInternalFastPathGetFailure(future));
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      assertNotNull(e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(unmatched) - Scenario: future(outer1)

Project: guava
 Class: AbstractFutureCancellationCauseTest
 Method: testCancel_notDoneInterrupt
 Body: {
    Future<?> future = newFutureInstance();
    assertTrue(future.cancel(true));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertNull(tryInternalFastPathGetFailure(future));
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      assertNotNull(e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(unmatched) - Scenario: future(outer1)

Project: guava
 Class: TearDownStackTest
 Method: testThrowingTearDown
 Body: {
    final TearDownStack stack = buildTearDownStack();

    final ThrowingTearDown tearDownOne = new ThrowingTearDown("one");
    stack.addTearDown(tearDownOne);

    final ThrowingTearDown tearDownTwo = new ThrowingTearDown("two");
    stack.addTearDown(tearDownTwo);

    assertEquals(false, tearDownOne.ran);
    assertEquals(false, tearDownTwo.ran);

    try {
      stack.runTearDown();
      fail("runTearDown should have thrown an exception");
    } catch (ClusterException expected) {
      assertThat(expected.getCause()).hasMessage("two");
    } catch (RuntimeException e) {
      throw new RuntimeException(
          "A ClusterException should have been thrown, rather than a " + e.getClass().getName(), e);
    }

    assertEquals(true, tearDownOne.ran);
    assertEquals(true, tearDownTwo.ran);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: runTearDown(unmatched) - Predicate: N/A(matched) - Scenario: stack(unmatched - new object)

Project: guava
 Class: ArbitraryInstancesTest
 Method: testGet_comparable
 Body: {
    @SuppressWarnings("unchecked") // The null value can compare with any Object
    Comparable<Object> comparable = ArbitraryInstances.get(Comparable.class);
    assertEquals(0, comparable.compareTo(comparable));
    assertTrue(comparable.compareTo("") > 0);
    try {
      comparable.compareTo(null);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: compareTo(oneMC) - Predicate: compareTo(outer) - Scenario: comparable(outer1)

Project: guava
 Class: ListSetTester
 Method: testSet_indexTooHigh
 Body: {
    int index = getNumElements();
    try {
      getList().set(index, e3());
      fail("set(size) should throw IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException expected) {
    }
    expectUnchanged();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: set(oneMC) - Predicate: N/A - Scenario: index(outer1)

Project: guava
 Class: FileBackedOutputStreamTest
 Method: testWriteErrorAfterClose
 Body: {
    byte[] data = newPreFilledByteArray(100);
    FileBackedOutputStream out = new FileBackedOutputStream(50);
    ByteSource source = out.asByteSource();

    out.write(data);
    assertTrue(Arrays.equals(data, source.read()));

    out.close();
    try {
      out.write(42);
      fail("expected exception");
    } catch (IOException expected) {
    }

    // Verify that write had no effect
    assertTrue(Arrays.equals(data, source.read()));
    out.reset();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: write(unmatched) - Predicate: equals(outer) - Scenario: out(unmatched - new object)

Project: guava
 Class: AbstractIteratorTest
 Method: testException
 Body: {
    final SomeUncheckedException exception = new SomeUncheckedException();
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          @Override
          public Integer computeNext() {
            throw exception;
          }
        };

    // It should pass through untouched
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (SomeUncheckedException e) {
      assertSame(exception, e);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hasNext(oneMC) - Predicate: N/A(inner) - Scenario: iter(outer1)

Project: guava
 Class: AbstractIteratorTest
 Method: testCantRemove
 Body: {
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          boolean haveBeenCalled;

          @Override
          public Integer computeNext() {
            if (haveBeenCalled) {
              endOfData();
            }
            haveBeenCalled = true;
            return 0;
          }
        };

    assertEquals(0, (int) iter.next());

    try {
      iter.remove();
      fail("No exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: N/A(outer) - Scenario: iter(outer1)

Project: guava
 Class: AbstractIteratorTest
 Method: testDefaultBehaviorOfNextAndHasNext
 Body: {

    // This sample AbstractIterator returns 0 on the first call, 1 on the
    // second, then signals that it's reached the end of the data
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          private int rep;

          @Override
          public Integer computeNext() {
            switch (rep++) {
              case 0:
                return 0;
              case 1:
                return 1;
              case 2:
                return endOfData();
              default:
                fail("Should not have been invoked again");
                return null;
            }
          }
        };

    assertTrue(iter.hasNext());
    assertEquals(0, (int) iter.next());

    // verify idempotence of hasNext()
    assertTrue(iter.hasNext());
    assertTrue(iter.hasNext());
    assertTrue(iter.hasNext());
    assertEquals(1, (int) iter.next());

    assertFalse(iter.hasNext());

    // Make sure computeNext() doesn't get invoked again
    assertFalse(iter.hasNext());

    try {
      iter.next();
      fail("no exception thrown");
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: hasNext(outer) - Scenario: iter(outer1)

Project: guava
 Class: SequentialExecutorTest
 Method: testDelegateRejection
 Body: {
    final AtomicInteger numCalls = new AtomicInteger();
    final AtomicBoolean reject = new AtomicBoolean(true);
    final SequentialExecutor executor =
        new SequentialExecutor(
            new Executor() {
              @Override
              public void execute(Runnable r) {
                if (reject.get()) {
                  throw new RejectedExecutionException();
                }
                r.run();
              }
            });
    Runnable task =
        new Runnable() {
          @Override
          public void run() {
            numCalls.incrementAndGet();
          }
        };
    try {
      executor.execute(task);
      fail();
    } catch (RejectedExecutionException expected) {
    }
    assertEquals(0, numCalls.get());
    reject.set(false);
    executor.execute(task);
    assertEquals(1, numCalls.get());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: execute(oneMC) - Predicate: get(outer) - Scenario: task(outer1)

Project: guava
 Class: AbstractLoadingCacheTest
 Method: testGetUnchecked_error
 Body: {
    final Error cause = new Error();
    final AtomicReference<Object> valueRef = new AtomicReference<>();
    LoadingCache<Object, Object> cache =
        new AbstractLoadingCache<Object, Object>() {
          @Override
          public Object get(Object key) throws ExecutionException {
            Object v = valueRef.get();
            if (v == null) {
              throw new ExecutionError(cause);
            }
            return v;
          }

          @Override
          public Object getIfPresent(Object key) {
            return valueRef.get();
          }
        };

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (ExecutionError expected) {
      assertEquals(cause, expected.getCause());
    }

    Object newValue = new Object();
    valueRef.set(newValue);
    assertSame(newValue, cache.getUnchecked(new Object()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: cache(outer1)

Project: guava
 Class: AbstractLoadingCacheTest
 Method: testGetUnchecked_unchecked
 Body: {
    final RuntimeException cause = new RuntimeException();
    final AtomicReference<Object> valueRef = new AtomicReference<>();
    LoadingCache<Object, Object> cache =
        new AbstractLoadingCache<Object, Object>() {
          @Override
          public Object get(Object key) throws ExecutionException {
            Object v = valueRef.get();
            if (v == null) {
              throw new ExecutionException(cause);
            }
            return v;
          }

          @Override
          public Object getIfPresent(Object key) {
            return valueRef.get();
          }
        };

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertEquals(cause, expected.getCause());
    }

    Object newValue = new Object();
    valueRef.set(newValue);
    assertSame(newValue, cache.getUnchecked(new Object()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: cache(outer1)

Project: guava
 Class: AbstractLoadingCacheTest
 Method: testGetUnchecked_otherThrowable
 Body: {
    final Throwable cause = new Throwable();
    final AtomicReference<Object> valueRef = new AtomicReference<>();
    LoadingCache<Object, Object> cache =
        new AbstractLoadingCache<Object, Object>() {
          @Override
          public Object get(Object key) throws ExecutionException {
            Object v = valueRef.get();
            if (v == null) {
              throw new ExecutionException(cause);
            }
            return v;
          }

          @Override
          public Object getIfPresent(Object key) {
            return valueRef.get();
          }
        };

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertEquals(cause, expected.getCause());
    }

    Object newValue = new Object();
    valueRef.set(newValue);
    assertSame(newValue, cache.getUnchecked(new Object()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: cache(outer1)

Project: guava
 Class: AbstractLoadingCacheTest
 Method: testGetUnchecked_checked
 Body: {
    final Exception cause = new Exception();
    final AtomicReference<Object> valueRef = new AtomicReference<>();
    LoadingCache<Object, Object> cache =
        new AbstractLoadingCache<Object, Object>() {
          @Override
          public Object get(Object key) throws ExecutionException {
            Object v = valueRef.get();
            if (v == null) {
              throw new ExecutionException(cause);
            }
            return v;
          }

          @Override
          public Object getIfPresent(Object key) {
            return valueRef.get();
          }
        };

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException expected) {
      assertEquals(cause, expected.getCause());
    }

    Object newValue = new Object();
    valueRef.set(newValue);
    assertSame(newValue, cache.getUnchecked(new Object()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: cache(outer1)

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedAsMapEntries
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    Iterator<Entry<String, Collection<Integer>>> entries = map.asMap().entrySet().iterator();
    Entry<String, Collection<Integer>> entry = entries.next();
    assertEquals("bar", entry.getKey());
    assertThat(entry.getValue()).containsExactly(1, 3).inOrder();
    try {
      entry.setValue(Arrays.<Integer>asList());
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    entries.remove(); // clear
    entry = entries.next();
    assertEquals("foo", entry.getKey());
    assertThat(entry.getValue()).contains(2);
    assertFalse(entries.hasNext());
    assertEquals("{foo=[2]}", map.toString());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: getKey(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testEntrySetToTypedArrayMutationThrows
 Body: {
    map.putInstance(String.class, "test");
    @SuppressWarnings("unchecked") // Should get a CCE later if cast is wrong
    Entry<Object, Object> entry = map.entrySet().toArray(new Entry[0])[0];
    assertEquals(TypeToken.of(String.class), entry.getKey());
    assertEquals("test", entry.getValue());
    try {
      entry.setValue(1);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testEntrySetMutationThrows
 Body: {
    map.putInstance(String.class, "test");
    assertEquals(TypeToken.of(String.class), map.entrySet().iterator().next().getKey());
    assertEquals("test", map.entrySet().iterator().next().getValue());
    try {
      map.entrySet().iterator().next().setValue(1);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: map.entrySet().iterator().next()(unmatched - actionReference)

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testEntrySetToArrayMutationThrows
 Body: {
    map.putInstance(String.class, "test");
    @SuppressWarnings("unchecked") // Should get a CCE later if cast is wrong
    Entry<Object, Object> entry = (Entry<Object, Object>) map.entrySet().toArray()[0];
    assertEquals(TypeToken.of(String.class), entry.getKey());
    assertEquals("test", entry.getValue());
    try {
      entry.setValue(1);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: TreeRangeMapTest
 Method: testSubRangeMapPutCoalescing
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.open(3, 7), 1);
    rangeMap.put(Range.closed(9, 10), 2);
    rangeMap.put(Range.closed(12, 16), 3);
    RangeMap<Integer, Integer> sub = rangeMap.subRangeMap(Range.closed(5, 11));
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.closed(9, 10), 2), sub.asMapOfRanges());
    sub.putCoalescing(Range.closed(7, 9), 2);
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.closed(7, 10), 2), sub.asMapOfRanges());
    assertEquals(
        ImmutableMap.of(Range.open(3, 7), 1, Range.closed(7, 10), 2, Range.closed(12, 16), 3),
        rangeMap.asMapOfRanges());

    sub.putCoalescing(Range.singleton(7), 1);
    assertEquals(
        ImmutableMap.of(Range.closed(5, 7), 1, Range.openClosed(7, 10), 2), sub.asMapOfRanges());
    assertEquals(
        ImmutableMap.of(
            Range.open(3, 5),
            1,
            Range.closed(5, 7),
            1,
            Range.openClosed(7, 10),
            2,
            Range.closed(12, 16),
            3),
        rangeMap.asMapOfRanges());

    try {
      sub.putCoalescing(Range.open(9, 12), 5);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putCoalescing(matched) - Predicate: of(outer) - Scenario: sub(matched - new object)

Project: guava
 Class: TreeRangeMapTest
 Method: testSubRangeMapPut
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.open(3, 7), 1);
    rangeMap.put(Range.closed(9, 10), 2);
    rangeMap.put(Range.closed(12, 16), 3);
    RangeMap<Integer, Integer> sub = rangeMap.subRangeMap(Range.closed(5, 11));
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.closed(9, 10), 2), sub.asMapOfRanges());
    sub.put(Range.closed(7, 9), 4);
    assertEquals(
        ImmutableMap.of(
            Range.closedOpen(5, 7), 1, Range.closed(7, 9), 4, Range.openClosed(9, 10), 2),
        sub.asMapOfRanges());
    assertEquals(
        ImmutableMap.of(
            Range.open(3, 7),
            1,
            Range.closed(7, 9),
            4,
            Range.openClosed(9, 10),
            2,
            Range.closed(12, 16),
            3),
        rangeMap.asMapOfRanges());

    try {
      sub.put(Range.open(9, 12), 5);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }

    sub = sub.subRangeMap(Range.closedOpen(5, 5));
    sub.put(Range.closedOpen(5, 5), 6); // should be a no-op
    assertEquals(
        ImmutableMap.of(
            Range.open(3, 7),
            1,
            Range.closed(7, 9),
            4,
            Range.openClosed(9, 10),
            2,
            Range.closed(12, 16),
            3),
        rangeMap.asMapOfRanges());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: sub(matched - new object)

Project: guava
 Class: CharSourceTest
 Method: testClosesOnErrors_copyingToWriterThatThrows
 Body: {
    TestCharSource okSource = new TestCharSource(STRING);
    try {
      okSource.copyTo(new TestWriter(WRITE_THROWS));
      fail();
    } catch (IOException expected) {
    }
    assertTrue(okSource.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: okSource(outer1)

Project: guava
 Class: CharSourceTest
 Method: testClosesOnErrors_whenReadThrows
 Body: {
    TestCharSource failSource = new TestCharSource(STRING, READ_THROWS);
    try {
      failSource.copyTo(new TestCharSink());
      fail();
    } catch (IOException expected) {
    }
    assertTrue(failSource.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: failSource(outer1)

Project: guava
 Class: MacHashFunctionTest
 Method: testHashTwice
 Body: {
    Hasher hasher = Hashing.hmacMd5(MD5_KEY).newHasher();

    assertEquals(
        "9753980fe94daa8ecaa82216519393a9",
        hasher.putString("The quick brown fox jumps over the lazy dog", UTF_8).hash().toString());
    try {
      hasher.hash();
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hash(oneMC) - Predicate: toString(outer) - Scenario: hasher(outer1)

Project: guava
 Class: MacHashFunctionTest
 Method: testNoProviders
 Body: {
    ProviderList providers = Providers.getProviderList();
    Providers.setProviderList(ProviderList.newList());
    try {
      Hashing.hmacMd5(MD5_KEY);
      fail("expected ISE");
    } catch (IllegalStateException expected) {
    } finally {
      Providers.setProviderList(providers);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hmacMd5(unmatched) - Predicate: N/A - Scenario: Hashing(unmatched - new object)

Project: guava
 Class: MacHashFunctionTest
 Method: testPutAfterHash
 Body: {
    Hasher hasher = Hashing.hmacMd5(MD5_KEY).newHasher();

    assertEquals(
        "9753980fe94daa8ecaa82216519393a9",
        hasher.putString("The quick brown fox jumps over the lazy dog", UTF_8).hash().toString());
    try {
      hasher.putInt(42);
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putInt(oneMC) - Predicate: toString(outer) - Scenario: hasher(outer1)

Project: guava
 Class: EndpointPairTest
 Method: endpointPair_unmodifiableView
 Body: {
    MutableGraph<Integer> directedGraph = GraphBuilder.directed().build();
    Set<EndpointPair<Integer>> edges = directedGraph.edges();

    directedGraph.putEdge(N1, N2);
    containsExactlySanityCheck(edges, EndpointPair.ordered(N1, N2));

    directedGraph.putEdge(N2, N1);
    containsExactlySanityCheck(edges, EndpointPair.ordered(N1, N2), EndpointPair.ordered(N2, N1));

    directedGraph.removeEdge(N1, N2);
    directedGraph.removeEdge(N2, N1);
    containsExactlySanityCheck(edges);

    try {
      edges.add(EndpointPair.ordered(N1, N2));
      fail("Set returned by edges() should be unmodifiable");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A - Scenario: edges(matched - new object)

Project: guava
 Class: AtomicDoubleArrayTest
 Method: testConstructorEmptyArray
 Body: {
    AtomicDoubleArray aa = new AtomicDoubleArray(new double[0]);
    assertEquals(0, aa.length());
    try {
      aa.get(0);
      fail();
    } catch (IndexOutOfBoundsException success) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: length(outer) - Scenario: aa(outer1)

Project: guava
 Class: AtomicDoubleArrayTest
 Method: testConstructorZeroLength
 Body: {
    AtomicDoubleArray aa = new AtomicDoubleArray(0);
    assertEquals(0, aa.length());
    try {
      aa.get(0);
      fail();
    } catch (IndexOutOfBoundsException success) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: length(outer) - Scenario: aa(outer1)

Project: guava
 Class: UnmodifiableIteratorTest
 Method: testRemove
 Body: {
    final String[] array = {"a", "b", "c"};

    Iterator<String> iterator =
        new UnmodifiableIterator<String>() {
          int i;

          @Override
          public boolean hasNext() {
            return i < array.length;
          }

          @Override
          public String next() {
            if (!hasNext()) {
              throw new NoSuchElementException();
            }
            return array[i++];
          }
        };

    assertTrue(iterator.hasNext());
    assertEquals("a", iterator.next());
    try {
      iterator.remove();
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: BloomFilterTest
 Method: testPutAllWithSelf
 Body: {
    BloomFilter<Integer> bf1 = BloomFilter.create(Funnels.integerFunnel(), 1);
    try {
      assertFalse(bf1.isCompatible(bf1));
      bf1.putAll(bf1);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(oneMC) - Predicate: N/A - Scenario: bf1(outer1)

Project: guava
 Class: AbstractServiceTest
 Method: testThrowingServiceStartAndWait
 Body: {
    StartThrowingService service = new StartThrowingService();
    RecordingListener listener = RecordingListener.record(service);

    try {
      service.startAsync().awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertEquals(service.exception, e.getCause());
    }
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(oneMC) - Predicate: failureCause(unmatched) - Scenario: listener(outer1)

Project: guava
 Class: AbstractServiceTest
 Method: testStopUnstartedService
 Body: {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record(service);

    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());

    try {
      service.startAsync();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertEquals(State.TERMINATED, Iterables.getOnlyElement(listener.getStateHistory()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: startAsync(unmatched) - Predicate: state(outer) - Scenario: service(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testThrowingServiceStopAndWait_runThrowing
 Body: {
    RunThrowingService service = new RunThrowingService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync();
    try {
      service.awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertEquals(service.exception, e.getCause());
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: failureCause(unmatched) - Scenario: service(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testFailingServiceStopAndWait_runFailing
 Body: {
    RunFailingService service = new RunFailingService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync();
    try {
      service.awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertEquals(EXCEPTION, e.getCause());
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(unmatched) - Predicate: failureCause(unmatched) - Scenario: service(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testThrowingServiceStopAndWait_stopThrowing
 Body: {
    StopThrowingService service = new StopThrowingService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync().awaitRunning();
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.exception, service.failureCause());
      assertEquals(service.exception, e.getCause());
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: failureCause(unmatched) - Scenario: service.stopAsync()(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceFailureIdempotence
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    /*
     * Set up a RecordingListener to perform its built-in assertions, even though we won't look at
     * its state history.
     */
    RecordingListener unused = RecordingListener.record(service);
    service.startAsync();
    service.notifyFailed(new Exception("1"));
    service.notifyFailed(new Exception("2"));
    assertThat(service.failureCause()).hasMessage("1");
    try {
      service.awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertThat(e.getCause()).hasMessage("1");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(unmatched) - Predicate: N/A(matched) - Scenario: service(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testNotifyFailedWhenTerminated
 Body: {
    NoOpService service = new NoOpService();
    service.startAsync().awaitRunning();
    service.stopAsync().awaitTerminated();
    try {
      service.notifyFailed(new Exception());
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: notifyFailed(unmatched) - Predicate: N/A - Scenario: service(matched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testFailingServiceStopAndWait_stopFailing
 Body: {
    StopFailingService service = new StopFailingService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync().awaitRunning();
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertEquals(EXCEPTION, e.getCause());
    }
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: failureCause(unmatched) - Scenario: service.stopAsync()(unmatched - new object)

Project: guava
 Class: AbstractServiceTest
 Method: testFailingServiceStartAndWait
 Body: {
    StartFailingService service = new StartFailingService();
    RecordingListener listener = RecordingListener.record(service);

    try {
      service.startAsync().awaitRunning();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertEquals(EXCEPTION, e.getCause());
    }
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(oneMC) - Predicate: failureCause(unmatched) - Scenario: listener(outer1)

Project: guava
 Class: ConfigurableSimpleUndirectedGraphTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedGraphTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = graph.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.successors(N1)).containsExactlyElementsIn(successors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedGraphTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);
    try {
      incidentEdges.add(EndpointPair.unordered(N1, N2));
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: incidentEdges(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedGraphTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = graph.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_readFullyAndThenSome
 Body: {
    ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
    byte[] actual = new byte[bytes.length * 2];
    try {
      in.readFully(actual);
      fail("expected exception");
    } catch (IllegalStateException ex) {
      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: readFully(oneMC) - Predicate: N/A(inner) - Scenario: actual(outer1)

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_offset
 Body: {
    ByteArrayDataInput in = ByteStreams.newDataInput(bytes, 2);
    assertEquals(0x56787654, in.readInt());
    try {
      in.readInt();
      fail("expected exception");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: readInt(oneMC) - Predicate: readInt(outer) - Scenario: in(outer1)

Project: guava
 Class: ByteStreamsTest
 Method: testSkipFully
 Body: {
    byte[] bytes = newPreFilledByteArray(100);
    skipHelper(0, 0, new ByteArrayInputStream(bytes));
    skipHelper(50, 50, new ByteArrayInputStream(bytes));
    skipHelper(50, 50, new SlowSkipper(new ByteArrayInputStream(bytes), 1));
    skipHelper(50, 50, new SlowSkipper(new ByteArrayInputStream(bytes), 0));
    skipHelper(100, -1, new ByteArrayInputStream(bytes));
    try {
      skipHelper(101, 0, new ByteArrayInputStream(bytes));
      fail("expected exception");
    } catch (EOFException e) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: skipHelper(matched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_empty
 Body: {
    byte[] b = new byte[0];
    ByteArrayDataInput in = ByteStreams.newDataInput(b);
    try {
      in.readInt();
      fail("expected exception");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: readInt(oneMC) - Predicate: N/A - Scenario: in(outer1)

Project: guava
 Class: ByteStreamsTest
 Method: testLimit_markNotSet
 Body: {
    byte[] big = newPreFilledByteArray(5);
    InputStream bin = new ByteArrayInputStream(big);
    InputStream lin = ByteStreams.limit(bin, 2);

    try {
      lin.reset();
      fail();
    } catch (IOException expected) {
      assertThat(expected).hasMessage("Mark not set");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: reset(oneMC) - Predicate: N/A(inner) - Scenario: lin(outer1)

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_normal
 Body: {
    ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
    assertEquals(0x12345678, in.readInt());
    assertEquals(0x76543210, in.readInt());
    try {
      in.readInt();
      fail("expected exception");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: readInt(oneMC) - Predicate: readInt(outer) - Scenario: in(outer1)

Project: guava
 Class: MultisetAddTester
 Method: testAddTooMany
 Body: {
    getMultiset().add(e3(), Integer.MAX_VALUE);
    try {
      getMultiset().add(e3());
      fail();
    } catch (IllegalArgumentException expected) {
    }
    assertEquals(Integer.MAX_VALUE, getMultiset().count(e3()));
    assertEquals(Integer.MAX_VALUE, getMultiset().size());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(matched) - Predicate: count(outer) - Scenario: getMultiset()(matched - actionReference)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredEntriesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.put("cow", 7);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredEntriesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.putAll(ImmutableMap.of("sheep", 5, "cow", 7));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredKeysIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredValuesIllegalSetValue
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      filtered.put("b", 4);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      Entry<String, Integer> entry = filtered.entrySet().iterator().next();
      try {
        entry.setValue(5);
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredValuesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredValuesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 4, "zzz", 5, "b", 6));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredKeysIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 3, "zzz", 4, "b", 5));
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: addEdge_parallelSelfLoopEdge
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
      fail("Adding a parallel self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addEdge(matched) - Predicate: N/A(inner) - Scenario: N/A

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(successors).containsExactlyElementsIn(network.successors(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: successors(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: MultimapPutAllMultimapTester
 Method: testPutAllRejectsNullValue
 Body: {
    Multimap<K, V> source = getSubjectGenerator().create(Helpers.mapEntry(k0(), null));
    try {
      multimap().putAll(source);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
    expectUnchanged();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(oneMC) - Predicate: N/A - Scenario: source(outer1)

Project: guava
 Class: MultimapPutAllMultimapTester
 Method: testPutAllRejectsNullKey
 Body: {
    Multimap<K, V> source = getSubjectGenerator().create(Helpers.mapEntry(null, v0()));
    try {
      multimap().putAll(source);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
    expectUnchanged();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(oneMC) - Predicate: N/A - Scenario: source(outer1)

Project: guava
 Class: SuppliersTest
 Method: testMemoizeNonSerializable
 Body: {
    CountingSupplier countingSupplier = new CountingSupplier();
    Supplier<Integer> memoizedSupplier = Suppliers.memoize(countingSupplier);
    assertThat(memoizedSupplier.toString()).isEqualTo("Suppliers.memoize(CountingSupplier)");
    checkMemoize(countingSupplier, memoizedSupplier);
    // Calls to the original memoized supplier shouldn't affect its copy.
    memoizedSupplier.get();
    assertThat(memoizedSupplier.toString())
        .isEqualTo("Suppliers.memoize(<supplier that returned 10>)");

    // Should get an exception when we try to serialize.
    try {
      reserialize(memoizedSupplier);
      fail();
    } catch (RuntimeException ex) {
      assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: reserialize(unmatched) - Predicate: getClass(unmatched) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.successors(N1)).containsExactlyElementsIn(successors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: SupplementalMonitorTest
 Method: testGetWaitQueueLengthWithWrongMonitorThrowsIMSE
 Body: {
    Monitor monitor1 = new Monitor();
    Monitor monitor2 = new Monitor();
    FlagGuard guard = new FlagGuard(monitor2);
    try {
      monitor1.getWaitQueueLength(guard);
      fail("expected IllegalMonitorStateException");
    } catch (IllegalMonitorStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getWaitQueueLength(oneMC) - Predicate: N/A - Scenario: guard(outer1)

Project: guava
 Class: SupplementalMonitorTest
 Method: testHasWaitersWithWrongMonitorThrowsIMSE
 Body: {
    Monitor monitor1 = new Monitor();
    Monitor monitor2 = new Monitor();
    FlagGuard guard = new FlagGuard(monitor2);
    try {
      monitor1.hasWaiters(guard);
      fail("expected IllegalMonitorStateException");
    } catch (IllegalMonitorStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hasWaiters(oneMC) - Predicate: N/A - Scenario: guard(outer1)

Project: guava
 Class: InternetDomainNameTest
 Method: testChild
 Body: {
    InternetDomainName domain = InternetDomainName.from("foo.com");

    assertEquals("www.foo.com", domain.child("www").toString());

    try {
      domain.child("www.");
      fail("www..google.com should have been invalid");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: child(oneMC) - Predicate: toString(outer) - Scenario: domain(outer1)

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedUntimed_cancelled
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    future.cancel(true);
    try {
      getChecked(future, TwoArgConstructorException.class);
      fail();
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getChecked(unmatched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedTimed_interrupted
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    Thread.currentThread().interrupt();
    try {
      getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
      fail();
    } catch (TwoArgConstructorException expected) {
      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
      assertTrue(Thread.currentThread().isInterrupted());
    } finally {
      Thread.interrupted();
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getChecked(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedUntimed_interrupted
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    Thread.currentThread().interrupt();
    try {
      getChecked(future, TwoArgConstructorException.class);
      fail();
    } catch (TwoArgConstructorException expected) {
      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
      assertTrue(Thread.currentThread().isInterrupted());
    } finally {
      Thread.interrupted();
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getChecked(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedTimed_cancelled
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    future.cancel(true);
    try {
      getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
      fail();
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getChecked(unmatched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: NullCacheTest
 Method: testGet_computeNull
 Body: {
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .maximumSize(0)
            .removalListener(listener)
            .build(constantLoader(null));

    try {
      cache.getUnchecked(new Object());
      fail();
    } catch (InvalidCacheLoadException e) {
      /* expected */
    }

    assertTrue(listener.isEmpty());
    checkEmpty(cache);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: isEmpty(outer) - Scenario: cache(outer1)

Project: guava
 Class: NullCacheTest
 Method: testGet_runtimeException
 Body: {
    final RuntimeException e = new RuntimeException();
    LoadingCache<Object, Object> map =
        CacheBuilder.newBuilder()
            .maximumSize(0)
            .removalListener(listener)
            .build(exceptionLoader(e));

    try {
      map.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException uee) {
      assertSame(e, uee.getCause());
    }
    assertTrue(listener.isEmpty());
    checkEmpty(map);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: map(outer1)

Project: guava
 Class: FloatsTest
 Method: testConstrainToRange
 Body: {
    float tolerance = 1e-10f;
    assertEquals((float) 1, Floats.constrainToRange((float) 1, (float) 0, (float) 5), tolerance);
    assertEquals((float) 1, Floats.constrainToRange((float) 1, (float) 1, (float) 5), tolerance);
    assertEquals((float) 3, Floats.constrainToRange((float) 1, (float) 3, (float) 5), tolerance);
    assertEquals((float) -1, Floats.constrainToRange((float) 0, (float) -5, (float) -1), tolerance);
    assertEquals((float) 2, Floats.constrainToRange((float) 5, (float) 2, (float) 2), tolerance);
    try {
      Floats.constrainToRange((float) 1, (float) 3, (float) 2);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: constrainToRange(oneMC) - Predicate: constrainToRange(outer) - Scenario: tolerance(outer1)

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_noPermission
 Body: {
    Path file = root().resolve("parent/nonexistent.file");
    Path parent = file.getParent();
    assertFalse(Files.exists(parent));
    try {
      MoreFiles.createParentDirectories(file);
      // Cleanup in case parent creation was [erroneously] successful.
      Files.delete(parent);
      fail("expected exception");
    } catch (IOException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: delete(oneMC) - Predicate: exists(outer) - Scenario: parent(outer1)

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_nonDirectoryParentExists
 Body: {
    Path parent = createTempFile();
    assertTrue(Files.isRegularFile(parent));
    Path file = parent.resolve("foo");
    try {
      MoreFiles.createParentDirectories(file);
      fail();
    } catch (IOException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: createParentDirectories(oneMC) - Predicate: isRegularFile(outer) - Scenario: file(outer1)

Project: guava
 Class: StatsTest
 Method: testFromByteArray_withTooLongArrayInputThrowsIllegalArgumentException
 Body: {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooLongByteArray =
        ByteBuffer.allocate(buffer.length + 2)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer)
            .putChar('.')
            .array();
    try {
      Stats.fromByteArray(tooLongByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: fromByteArray(oneMC) - Predicate: N/A - Scenario: tooLongByteArray(outer1)

Project: guava
 Class: StatsTest
 Method: testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException
 Body: {
    byte[] buffer = MANY_VALUES_STATS_VARARGS.toByteArray();
    byte[] tooShortByteArray =
        ByteBuffer.allocate(buffer.length - 1)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer, 0, Stats.BYTES - 1)
            .array();
    try {
      Stats.fromByteArray(tooShortByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: fromByteArray(oneMC) - Predicate: N/A - Scenario: tooShortByteArray(outer1)

Project: guava
 Class: MutableClassToInstanceMapTest
 Method: testConstraint
 Body: {

    /**
     * We'll give ourselves a pass on testing all the possible ways of breaking the constraint,
     * because we know that newClassMap() is implemented using ConstrainedMap which is itself
     * well-tested. A purist would object to this, but what can I say, we're dirty cheaters.
     */
    map.put(Integer.class, new Integer(5));
    try {
      map.put(Double.class, new Long(42));
      fail();
    } catch (ClassCastException expected) {
    }
    // Won't compile: map.put(String.class, "x");
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: N/A - Scenario: map(matched - actionReference)

Project: guava
 Class: StopwatchTest
 Method: testStop_alreadyStopped
 Body: {
    stopwatch.start();
    stopwatch.stop();
    try {
      stopwatch.stop();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertFalse(stopwatch.isRunning());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: stop(matched) - Predicate: isRunning(outer) - Scenario: stopwatch(matched - actionReference)

Project: guava
 Class: StopwatchTest
 Method: testStart_whileRunning
 Body: {
    stopwatch.start();
    try {
      stopwatch.start();
      fail();
    } catch (IllegalStateException expected) {
    }
    assertTrue(stopwatch.isRunning());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: start(matched) - Predicate: isRunning(outer) - Scenario: stopwatch(matched - actionReference)

Project: guava
 Class: FuturesTest
 Method: testSubmitAsync_asyncCallable_error
 Body: {
    final Error error = new Error("deliberate");
    AsyncCallable<Integer> callable =
        new AsyncCallable<Integer>() {
          @Override
          public ListenableFuture<Integer> call() {
            throw error;
          }
        };
    SettableFuture<String> inputFuture = SettableFuture.create();
    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());
    inputFuture.set("value");
    try {
      getDone(outputFuture);
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_getThrowsRuntimeException
 Body: {
    ListenableFuture<Object> input =
        UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());

    ListenableFuture<Object> output = transformAsync(input, asyncIdentity(), directExecutor());
    try {
      getDone(output);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyRuntimeException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: output(outer1)

Project: guava
 Class: FuturesTest
 Method: testCatching_rejectionPropagatesToOutput
 Body: {
    SettableFuture<String> input = SettableFuture.create();
    ListenableFuture<String> transformed =
        catching(input, Throwable.class, constant("foo"), REJECTING_EXECUTOR);
    input.setException(new Exception());
    try {
      getDone(transformed);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransform_getThrowsRuntimeException
 Body: {
    ListenableFuture<Object> input =
        UncheckedThrowingFuture.throwingRuntimeException(new MyRuntimeException());

    ListenableFuture<Object> output = transform(input, identity(), directExecutor());
    try {
      getDone(output);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyRuntimeException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: output(outer1)

Project: guava
 Class: FuturesTest
 Method: testWhenAllCompleteRunnable_resultCanceledWithInterrupt_InterruptsRunnable
 Body: {
    SettableFuture<String> stringFuture = SettableFuture.create();
    SettableFuture<Boolean> booleanFuture = SettableFuture.create();
    final CountDownLatch inFunction = new CountDownLatch(1);
    final CountDownLatch gotException = new CountDownLatch(1);
    Runnable combiner =
        new Runnable() {
          @Override
          public void run() {
            inFunction.countDown();
            try {
              new CountDownLatch(1).await(); // wait for interrupt
            } catch (InterruptedException expected) {
              // Ensure the thread's interrupt status is preserved.
              Thread.currentThread().interrupt();
              gotException.countDown();
            }
          }
        };

    ListenableFuture<?> futureResult =
        whenAllComplete(stringFuture, booleanFuture).run(combiner, newSingleThreadExecutor());

    stringFuture.set("value");
    booleanFuture.set(true);
    inFunction.await();
    futureResult.cancel(true);
    try {
      futureResult.get();
      fail();
    } catch (CancellationException expected) {
    }
    gotException.await();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A - Scenario: futureResult(matched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_rejectionPropagatesToOutput
 Body: {
    SettableFuture<String> input = SettableFuture.create();
    ListenableFuture<String> transformed =
        catchingAsync(
            input,
            Throwable.class,
            constantAsyncFunction(immediateFuture("foo")),
            REJECTING_EXECUTOR);
    input.setException(new Exception());
    try {
      getDone(transformed);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_interruptPropagatesToTransformingThread
 Body: {
    SettableFuture<String> input = SettableFuture.create();
    final CountDownLatch inFunction = new CountDownLatch(1);
    final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
    final CountDownLatch gotException = new CountDownLatch(1);
    AsyncFunction<String, String> function =
        new AsyncFunction<String, String>() {
          @Override
          public ListenableFuture<String> apply(String s) throws Exception {
            inFunction.countDown();
            try {
              shouldCompleteFunction.await();
            } catch (InterruptedException expected) {
              gotException.countDown();
              throw expected;
            }
            return immediateFuture("a");
          }
        };

    ListenableFuture<String> futureResult =
        transformAsync(input, function, newSingleThreadExecutor());

    input.set("value");
    inFunction.await();
    futureResult.cancel(true);
    shouldCompleteFunction.countDown();
    try {
      futureResult.get();
      fail();
    } catch (CancellationException expected) {
    }
    // TODO(cpovirk): implement interruption, updating this test:
    // https://github.com/google/guava/issues/1989
    assertEquals(1, gotException.getCount());
    // gotException.await();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: getCount(outer) - Scenario: futureResult(matched - new object)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_logging_seenExceptionUpdateCancelRace
 Body: {
    final MyException subsequentFailure = new MyException();
    SettableFuture<Object> firstFuture = SettableFuture.create();
    final SettableFuture<Object> secondFuture = SettableFuture.create();
    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);

    bulkFuture.addListener(
        new Runnable() {
          @Override
          public void run() {
            /*
             * This is similar to the above test, but this time we're making sure that we recognize
             * that the output Future is done early not because of an exception but because of a
             * cancellation.
             */
            secondFuture.setException(subsequentFailure);
          }
        },
        directExecutor());
    firstFuture.cancel(false);

    try {
      getDone(bulkFuture);
      fail();
    } catch (CancellationException expected) {
      assertThat(getOnlyElement(aggregateFutureLogHandler.getStoredLogRecords()).getThrown())
          .isSameAs(subsequentFailure);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_listenerThrowsError
 Body: {
    SettableFuture<Object> input = SettableFuture.create();
    ListenableFuture<Object> output =
        catchingAsync(input, Throwable.class, asyncIdentity(), directExecutor());

    output.addListener(
        new Runnable() {
          @Override
          public void run() {
            throw new MyError();
          }
        },
        directExecutor());
    try {
      input.setException(new MyException());
      fail();
    } catch (MyError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setException(unmatched) - Predicate: N/A - Scenario: input(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_customTypeNoMatch
 Body: {
    AsyncFunction<IOException, Integer> fallback = asyncFunctionReturningOne();
    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new RuntimeException());
    ListenableFuture<Integer> faultTolerantFuture =
        catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
    try {
      getDone(faultTolerantFuture);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RuntimeException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: faultTolerantFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testScheduleAsync_asyncCallable_error
 Body: {
    final Error error = new Error("deliberate");
    AsyncCallable<Integer> callable =
        new AsyncCallable<Integer>() {
          @Override
          public ListenableFuture<Integer> call() {
            throw error;
          }
        };
    SettableFuture<String> inputFuture = SettableFuture.create();
    ListenableFuture<Integer> outputFuture = submitAsync(callable, directExecutor());
    inputFuture.set("value");
    try {
      getDone(outputFuture);
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatching_customTypeNoMatch
 Body: {
    Function<IOException, Integer> fallback = functionReturningOne();
    ListenableFuture<Integer> originalFuture = immediateFailedFuture(new RuntimeException());
    ListenableFuture<Integer> faultTolerantFuture =
        catching(originalFuture, IOException.class, fallback, directExecutor());
    try {
      getDone(faultTolerantFuture);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RuntimeException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: faultTolerantFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_asyncFunction_nullInsteadOfFuture
 Body: {
    ListenableFuture<?> inputFuture = immediateFuture("a");
    ListenableFuture<?> chainedFuture =
        transformAsync(inputFuture, constantAsyncFunction(null), directExecutor());
    try {
      getDone(chainedFuture);
      fail();
    } catch (ExecutionException expected) {
      NullPointerException cause = (NullPointerException) expected.getCause();
      assertThat(cause)
          .hasMessageThat()
          .contains(
              "AsyncFunction.apply returned null instead of a Future. "
                  + "Did you mean to return immediateFuture(null)?");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: chainedFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_singleFailure
 Body: {
    Throwable exception = new Throwable("failed");
    ListenableFuture<String> future = immediateFailedFuture(exception);
    ListenableFuture<List<String>> compound = allAsList(ImmutableList.of(future));

    try {
      getDone(compound);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: getCause(inner) - Scenario: compound(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_asyncFunction_error
 Body: {
    final Error error = new Error("deliberate");
    AsyncFunction<String, Integer> function =
        new AsyncFunction<String, Integer>() {
          @Override
          public ListenableFuture<Integer> apply(String input) {
            throw error;
          }
        };
    SettableFuture<String> inputFuture = SettableFuture.create();
    ListenableFuture<Integer> outputFuture =
        transformAsync(inputFuture, function, directExecutor());
    inputFuture.set("value");
    try {
      getDone(outputFuture);
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_getThrowsError
 Body: {
    ListenableFuture<Object> input = UncheckedThrowingFuture.throwingError(new MyError());

    ListenableFuture<Object> output = transformAsync(input, asyncIdentity(), directExecutor());
    try {
      getDone(output);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyError.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: output(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransform_rejectionPropagatesToOutput
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    Function<Foo, Foo> identity = identity();
    ListenableFuture<Foo> transformed = transform(input, identity, REJECTING_EXECUTOR);
    input.set(new Foo());
    try {
      getDone(transformed);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testWhenAllCompleteRunnable_resultCanceledWithoutInterrupt_doesNotInterruptRunnable
 Body: {
    SettableFuture<String> stringFuture = SettableFuture.create();
    SettableFuture<Boolean> booleanFuture = SettableFuture.create();
    final CountDownLatch inFunction = new CountDownLatch(1);
    final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
    final CountDownLatch combinerCompletedWithoutInterrupt = new CountDownLatch(1);
    Runnable combiner =
        new Runnable() {
          @Override
          public void run() {
            inFunction.countDown();
            try {
              shouldCompleteFunction.await();
              combinerCompletedWithoutInterrupt.countDown();
            } catch (InterruptedException e) {
              // Ensure the thread's interrupt status is preserved.
              Thread.currentThread().interrupt();
              throw new RuntimeException(e);
            }
          }
        };

    ListenableFuture<?> futureResult =
        whenAllComplete(stringFuture, booleanFuture).run(combiner, newSingleThreadExecutor());

    stringFuture.set("value");
    booleanFuture.set(true);
    inFunction.await();
    futureResult.cancel(false);
    shouldCompleteFunction.countDown();
    try {
      futureResult.get();
      fail();
    } catch (CancellationException expected) {
    }
    combinerCompletedWithoutInterrupt.await();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A - Scenario: futureResult(matched - new object)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_logging_multipleExceptions_doneLater
 Body: {
    SettableFuture<Object> future1 = SettableFuture.create();
    SettableFuture<Object> future2 = SettableFuture.create();
    SettableFuture<Object> future3 = SettableFuture.create();
    ListenableFuture<List<Object>> all = allAsList(future1, future2, future3);

    future1.setException(new MyException());
    future2.setException(new MyException());
    future3.setException(new MyException());

    try {
      getDone(all);
      fail();
    } catch (ExecutionException expected) {
      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
      assertThat(logged).hasSize(2); // failures after the first are logged
      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);
      assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransform_listenerThrowsError
 Body: {
    SettableFuture<Object> input = SettableFuture.create();
    ListenableFuture<Object> output = transform(input, identity(), directExecutor());

    output.addListener(
        new Runnable() {
          @Override
          public void run() {
            throw new MyError();
          }
        },
        directExecutor());
    try {
      input.set("foo");
      fail();
    } catch (MyError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: set(unmatched) - Predicate: N/A - Scenario: input(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_cancelled
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2);
    compound.addListener(listener, directExecutor());

    listener.expectCall();
    future1.cancel(true);
    assertTrue(compound.isDone());
    assertTrue(listener.wasCalled());
    assertFalse(future2.isDone());

    try {
      getDone(compound);
      fail();
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: isDone(outer) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_fallbackGeneratesError
 Body: {
    final Error error = new Error("deliberate");
    AsyncFunction<Throwable, Integer> fallback =
        new AsyncFunction<Throwable, Integer>() {
          @Override
          public ListenableFuture<Integer> apply(Throwable t) throws Exception {
            throw error;
          }
        };
    ListenableFuture<Integer> failingFuture = immediateFailedFuture(new RuntimeException());
    try {
      getDone(catchingAsync(failingFuture, Throwable.class, fallback, directExecutor()));
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: getCause(inner) - Scenario: failingFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testCatching_fallbackGeneratesError
 Body: {
    final Error error = new Error("deliberate");
    Function<Throwable, Integer> fallback =
        new Function<Throwable, Integer>() {
          @Override
          public Integer apply(Throwable t) {
            throw error;
          }
        };
    ListenableFuture<Integer> failingFuture = immediateFailedFuture(new RuntimeException());
    try {
      getDone(catching(failingFuture, Throwable.class, fallback, directExecutor()));
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: getCause(inner) - Scenario: failingFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_logging_seenExceptionUpdateRace
 Body: {
    final MyException sameInstance = new MyException();
    SettableFuture<Object> firstFuture = SettableFuture.create();
    final SettableFuture<Object> secondFuture = SettableFuture.create();
    ListenableFuture<List<Object>> bulkFuture = allAsList(firstFuture, secondFuture);

    bulkFuture.addListener(
        new Runnable() {
          @Override
          public void run() {
            /*
             * firstFuture just completed, but AggregateFuture hasn't yet had time to record the
             * exception in seenExceptions. When we complete secondFuture with the same exception,
             * we want for AggregateFuture to still detect that it's been previously seen.
             */
            secondFuture.setException(sameInstance);
          }
        },
        directExecutor());
    firstFuture.setException(sameInstance);

    try {
      getDone(bulkFuture);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyException.class);
      assertThat(aggregateFutureLogHandler.getStoredLogRecords()).isEmpty();
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_interruptPropagatesToTransformingThread
 Body: {
    SettableFuture<String> input = SettableFuture.create();
    final CountDownLatch inFunction = new CountDownLatch(1);
    final CountDownLatch shouldCompleteFunction = new CountDownLatch(1);
    final CountDownLatch gotException = new CountDownLatch(1);
    AsyncFunction<Throwable, String> function =
        new AsyncFunction<Throwable, String>() {
          @Override
          public ListenableFuture<String> apply(Throwable t) throws Exception {
            inFunction.countDown();
            try {
              shouldCompleteFunction.await();
            } catch (InterruptedException expected) {
              gotException.countDown();
              throw expected;
            }
            return immediateFuture("a");
          }
        };

    ListenableFuture<String> futureResult =
        catchingAsync(input, Exception.class, function, newSingleThreadExecutor());

    input.setException(new Exception());
    inFunction.await();
    futureResult.cancel(true);
    shouldCompleteFunction.countDown();
    try {
      futureResult.get();
      fail();
    } catch (CancellationException expected) {
    }
    // TODO(cpovirk): implement interruption, updating this test:
    // https://github.com/google/guava/issues/1989
    assertEquals(1, gotException.getCount());
    // gotException.await();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: getCount(outer) - Scenario: futureResult(matched - new object)

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_asyncError
 Body: {
    final Exception thrown = new RuntimeException("test");

    final SettableFuture<Integer> futureInteger = SettableFuture.create();
    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
    AsyncCallable<String> combiner =
        new AsyncCallable<String>() {
          @Override
          public ListenableFuture<String> call() throws Exception {
            assertTrue(futureInteger.isDone());
            assertTrue(futureBoolean.isDone());
            return immediateFailedFuture(thrown);
          }
        };

    ListenableFuture<String> futureResult =
        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
    Integer integerPartial = 1;
    futureInteger.set(integerPartial);
    Boolean booleanPartial = true;
    futureBoolean.set(booleanPartial);

    try {
      getDone(futureResult);
      fail();
    } catch (ExecutionException expected) {
      assertSame(thrown, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testImmediateCancelledFutureStack
 Body: {
    ListenableFuture<String> future = CallerClass1.makeImmediateCancelledFuture();
    assertTrue(future.isCancelled());

    try {
      CallerClass2.get(future);
      fail();
    } catch (CancellationException expected) {
      // There should be two CancellationException chained together.  The outer one should have the
      // stack trace of where the get() call was made, and the inner should have the stack trace of
      // where the immediateCancelledFuture() call was made.
      List<StackTraceElement> stackTrace = ImmutableList.copyOf(expected.getStackTrace());
      assertFalse(Iterables.any(stackTrace, hasClassName(CallerClass1.class)));
      assertTrue(Iterables.any(stackTrace, hasClassName(CallerClass2.class)));

      // See AbstractFutureCancellationCauseTest for how to set causes.
      assertThat(expected.getCause()).isNull();
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: any(unmatched) - Scenario: future(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_rejectionPropagatesToOutput
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    AsyncFunction<Foo, Foo> asyncIdentity = asyncIdentity();
    ListenableFuture<Foo> transformed = transformAsync(input, asyncIdentity, REJECTING_EXECUTOR);
    input.set(new Foo());
    try {
      getDone(transformed);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(RejectedExecutionException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: N/A(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_nullInsteadOfFuture
 Body: {
    ListenableFuture<Integer> inputFuture = immediateFailedFuture(new Exception());
    ListenableFuture<?> chainedFuture =
        catchingAsync(
            inputFuture,
            Throwable.class,
            new AsyncFunction<Throwable, Integer>() {
              @Override
              @SuppressWarnings("AsyncFunctionReturnsNull")
              public ListenableFuture<Integer> apply(Throwable t) {
                return null;
              }
            },
            directExecutor());
    try {
      getDone(chainedFuture);
      fail();
    } catch (ExecutionException expected) {
      NullPointerException cause = (NullPointerException) expected.getCause();
      assertThat(cause)
          .hasMessageThat()
          .contains(
              "AsyncFunction.apply returned null instead of a Future. "
                  + "Did you mean to return immediateFuture(null)?");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: chainedFuture(outer1)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_immediateFailure
 Body: {
    Throwable exception = new Throwable("failed");
    ListenableFuture<String> future1 = immediateFailedFuture(exception);
    ListenableFuture<String> future2 = immediateFuture("results");
    ListenableFuture<List<String>> compound = allAsList(ImmutableList.of(future1, future2));

    try {
      getDone(compound);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: getCause(inner) - Scenario: compound(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransform_getThrowsError
 Body: {
    ListenableFuture<Object> input = UncheckedThrowingFuture.throwingError(new MyError());

    ListenableFuture<Object> output = transform(input, identity(), directExecutor());
    try {
      getDone(output);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyError.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(oneMC) - Predicate: N/A(inner) - Scenario: output(outer1)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_asyncFunction_timeout
 Body: {
    AsyncFunction<String, Integer> function = constantAsyncFunction(immediateFuture(1));
    ListenableFuture<Integer> future =
        transformAsync(SettableFuture.<String>create(), function, directExecutor());
    try {
      future.get(1, MILLISECONDS);
      fail();
    } catch (TimeoutException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: N/A - Scenario: future(outer1)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_failure
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2);
    compound.addListener(listener, directExecutor());

    listener.expectCall();
    Throwable exception = new Throwable("failed1");
    future1.setException(exception);
    assertTrue(compound.isDone());
    assertTrue(listener.wasCalled());
    assertFalse(future2.isDone());

    try {
      getDone(compound);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(unmatched) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_interrupted
 Body: {
    SettableFuture<String> stringFuture = SettableFuture.create();
    SettableFuture<Boolean> booleanFuture = SettableFuture.create();
    final CountDownLatch inFunction = new CountDownLatch(1);
    final CountDownLatch gotException = new CountDownLatch(1);
    AsyncCallable<String> combiner =
        new AsyncCallable<String>() {
          @Override
          public ListenableFuture<String> call() throws Exception {
            inFunction.countDown();
            try {
              new CountDownLatch(1).await(); // wait for interrupt
            } catch (InterruptedException expected) {
              gotException.countDown();
              throw expected;
            }
            return immediateFuture("a");
          }
        };

    ListenableFuture<String> futureResult =
        whenAllComplete(stringFuture, booleanFuture).callAsync(combiner, newSingleThreadExecutor());

    stringFuture.set("value");
    booleanFuture.set(true);
    inFunction.await();
    futureResult.cancel(true);
    try {
      futureResult.get();
      fail();
    } catch (CancellationException expected) {
    }
    gotException.await();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A - Scenario: futureResult(matched - new object)

Project: guava
 Class: FuturesTest
 Method: testAllAsList_error
 Body: {
    Error error = new Error("deliberate");
    SettableFuture<String> future1 = SettableFuture.create();
    ListenableFuture<String> future2 = immediateFuture("results");
    ListenableFuture<List<String>> compound = allAsList(ImmutableList.of(future1, future2));

    future1.setException(error);
    try {
      getDone(compound);
      fail();
    } catch (ExecutionException expected) {
      assertSame(error, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_listenerThrowsError
 Body: {
    SettableFuture<Object> input = SettableFuture.create();
    ListenableFuture<Object> output = transformAsync(input, asyncIdentity(), directExecutor());

    output.addListener(
        new Runnable() {
          @Override
          public void run() {
            throw new MyError();
          }
        },
        directExecutor());
    try {
      input.set("foo");
      fail();
    } catch (MyError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: set(unmatched) - Predicate: N/A - Scenario: input(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testWhenAllSucceed
 Body: {
    class PartialResultException extends Exception {}

    final SettableFuture<Integer> futureInteger = SettableFuture.create();
    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
    AsyncCallable<String> combiner =
        new AsyncCallable<String>() {
          @Override
          public ListenableFuture<String> call() throws Exception {
            throw new AssertionFailedError("AsyncCallable should not have been called.");
          }
        };

    ListenableFuture<String> futureResult =
        whenAllSucceed(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
    PartialResultException partialResultException = new PartialResultException();
    futureInteger.setException(partialResultException);
    Boolean booleanPartial = true;
    futureBoolean.set(booleanPartial);
    try {
      getDone(futureResult);
      fail();
    } catch (ExecutionException expected) {
      assertSame(partialResultException, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_runnableError
 Body: {
    final RuntimeException thrown = new RuntimeException("test");

    final SettableFuture<Integer> futureInteger = SettableFuture.create();
    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
    Runnable combiner =
        new Runnable() {
          @Override
          public void run() {
            assertTrue(futureInteger.isDone());
            assertTrue(futureBoolean.isDone());
            throw thrown;
          }
        };

    ListenableFuture<?> futureResult =
        whenAllComplete(futureInteger, futureBoolean).run(combiner, directExecutor());
    Integer integerPartial = 1;
    futureInteger.set(integerPartial);
    Boolean booleanPartial = true;
    futureBoolean.set(booleanPartial);

    try {
      getDone(futureResult);
      fail();
    } catch (ExecutionException expected) {
      assertSame(thrown, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(inner) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testNonCancellationPropagating_failure
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);
    Throwable failure = new Throwable("thrown");

    assertFalse(wrapper.isDone());
    input.setException(failure);
    try {
      getDone(wrapper);
      fail();
    } catch (ExecutionException expected) {
      assertSame(failure, expected.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(unmatched) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: FuturesTest
 Method: testCatching_listenerThrowsError
 Body: {
    SettableFuture<Object> input = SettableFuture.create();
    ListenableFuture<Object> output =
        catching(input, Throwable.class, identity(), directExecutor());

    output.addListener(
        new Runnable() {
          @Override
          public void run() {
            throw new MyError();
          }
        },
        directExecutor());
    try {
      input.setException(new MyException());
      fail();
    } catch (MyError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setException(unmatched) - Predicate: N/A - Scenario: input(unmatched - new object)

Project: guava
 Class: OptionalTest
 Method: testOr_nullSupplier_absent
 Body: {
    Supplier<Object> nullSupplier = Suppliers.ofInstance(null);
    Optional<Object> absentOptional = Optional.absent();
    try {
      absentOptional.or(nullSupplier);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: or(oneMC) - Predicate: N/A - Scenario: absentOptional(outer1)

Project: guava
 Class: CacheBuilderTest
 Method: testTicker_setTwice
 Body: {
    Ticker testTicker = Ticker.systemTicker();
    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder().ticker(testTicker);
    try {
      // even to the same instance is not allowed
      builder.ticker(testTicker);
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: ticker(oneMC) - Predicate: N/A - Scenario: builder(outer1)

Project: guava
 Class: ImmutableListMultimapTest
 Method: testCopyOfNullValue
 Body: {
    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();
    input.putAll("foo", Arrays.asList(1, null, 3));
    try {
      ImmutableListMultimap.copyOf(input);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyOf(unmatched) - Predicate: N/A - Scenario: ImmutableListMultimap(unmatched - new object)

Project: guava
 Class: ImmutableListMultimapTest
 Method: testCopyOfNullKey
 Body: {
    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();
    input.put(null, 1);
    try {
      ImmutableListMultimap.copyOf(input);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyOf(unmatched) - Predicate: N/A - Scenario: ImmutableListMultimap(unmatched - new object)

Project: guava
 Class: UnmodifiableListIteratorTest
 Method: testRemove
 Body: {
    Iterator<String> iterator = create();

    assertTrue(iterator.hasNext());
    assertEquals("a", iterator.next());
    try {
      iterator.remove();
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: UnmodifiableListIteratorTest
 Method: testAdd
 Body: {
    ListIterator<String> iterator = create();

    assertTrue(iterator.hasNext());
    assertEquals("a", iterator.next());
    assertEquals("b", iterator.next());
    assertEquals("b", iterator.previous());
    try {
      iterator.add("c");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: UnmodifiableListIteratorTest
 Method: testSet
 Body: {
    ListIterator<String> iterator = create();

    assertTrue(iterator.hasNext());
    assertEquals("a", iterator.next());
    assertEquals("b", iterator.next());
    assertEquals("b", iterator.previous());
    try {
      iterator.set("c");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: set(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: TablesTransformValuesTest
 Method: testPutAllTable
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Table<String, Integer, Character> other = HashBasedTable.create();
    other.put("foo", 1, 'd');
    other.put("bar", 2, 'e');
    other.put("cat", 2, 'f');
    try {
      table.putAll(other);
      fail("Expected UnsupportedOperationException");
    } catch (UnsupportedOperationException expected) {
    }
    assertEquals((Character) 'a', table.get("foo", 1));
    assertEquals((Character) 'b', table.get("bar", 1));
    assertEquals((Character) 'c', table.get("foo", 3));
    assertSize(3);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: get(outer) - Scenario: table(unmatched - new object)

Project: guava
 Class: FunctionsTest
 Method: testForMapWithoutDefault
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("One", 1);
    map.put("Three", 3);
    map.put("Null", null);
    Function<String, Integer> function = Functions.forMap(map);

    assertEquals(1, function.apply("One").intValue());
    assertEquals(3, function.apply("Three").intValue());
    assertNull(function.apply("Null"));

    try {
      function.apply("Two");
      fail();
    } catch (IllegalArgumentException expected) {
    }

    new EqualsTester()
        .addEqualityGroup(function, Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, 42))
        .testEquals();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: apply(unmatched) - Predicate: intValue(outer) - Scenario: function(matched - new object)

Project: guava
 Class: TypeResolverTest
 Method: testWhere_duplicateMapping
 Body: {
    Type t = aTypeVariable();
    TypeResolver resolver = new TypeResolver().where(t, String.class);
    try {
      resolver.where(t, String.class);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: where(oneMC) - Predicate: N/A - Scenario: resolver(outer1)

Project: guava
 Class: MessageDigestHashFunctionTest
 Method: testHashTwice
 Body: {
    Hasher sha1 = Hashing.sha1().newHasher();

    assertEquals(
        "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
        sha1.putString("The quick brown fox jumps over the lazy dog", Charsets.UTF_8)
            .hash()
            .toString());
    try {
      sha1.hash();
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hash(oneMC) - Predicate: toString(outer) - Scenario: sha1(outer1)

Project: guava
 Class: MessageDigestHashFunctionTest
 Method: testPutAfterHash
 Body: {
    Hasher sha1 = Hashing.sha1().newHasher();

    assertEquals(
        "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
        sha1.putString("The quick brown fox jumps over the lazy dog", Charsets.UTF_8)
            .hash()
            .toString());
    try {
      sha1.putInt(42);
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putInt(oneMC) - Predicate: toString(outer) - Scenario: sha1(outer1)

Project: guava
 Class: DoublesTest
 Method: testConstrainToRange
 Body: {
    double tolerance = 1e-10;
    assertEquals(
        (double) 1, Doubles.constrainToRange((double) 1, (double) 0, (double) 5), tolerance);
    assertEquals(
        (double) 1, Doubles.constrainToRange((double) 1, (double) 1, (double) 5), tolerance);
    assertEquals(
        (double) 3, Doubles.constrainToRange((double) 1, (double) 3, (double) 5), tolerance);
    assertEquals(
        (double) -1, Doubles.constrainToRange((double) 0, (double) -5, (double) -1), tolerance);
    assertEquals(
        (double) 2, Doubles.constrainToRange((double) 5, (double) 2, (double) 2), tolerance);
    try {
      Doubles.constrainToRange((double) 1, (double) 3, (double) 2);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: constrainToRange(oneMC) - Predicate: constrainToRange(outer) - Scenario: tolerance(outer1)

Project: guava
 Class: IterablesTest
 Method: testFind
 Body: {
    Iterable<String> list = newArrayList("cool", "pants");
    assertEquals("cool", Iterables.find(list, Predicates.equalTo("cool")));
    assertEquals("pants", Iterables.find(list, Predicates.equalTo("pants")));
    try {
      Iterables.find(list, Predicates.alwaysFalse());
      fail();
    } catch (NoSuchElementException e) {
    }
    assertEquals("cool", Iterables.find(list, Predicates.alwaysTrue()));
    assertCanIterateAgain(list);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: find(oneMC) - Predicate: find(outer) - Scenario: list(outer1)

Project: guava
 Class: IterablesTest
 Method: testSkip_allOfImmutableList_modifiable
 Body: {
    List<String> list = ImmutableList.of("a", "b");
    Iterator<String> iterator = skip(list, 2).iterator();
    try {
      iterator.remove();
      fail("Expected UnsupportedOperationException");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: N/A - Scenario: iterator(outer1)

Project: guava
 Class: IterablesTest
 Method: testSkip_allOfMutableList_modifiable
 Body: {
    List<String> list = newArrayList("a", "b");
    Iterator<String> iterator = skip(list, 2).iterator();
    try {
      iterator.remove();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: N/A - Scenario: iterator(outer1)

Project: guava
 Class: IterablesTest
 Method: testConsumingIterable_duelingIterators
 Body: {
    // Test data
    List<String> list = Lists.newArrayList(asList("a", "b"));

    // Test & Verify
    Iterator<String> i1 = Iterables.consumingIterable(list).iterator();
    Iterator<String> i2 = Iterables.consumingIterable(list).iterator();

    i1.next();
    try {
      i2.next();
      fail("Concurrent modification should throw an exception.");
    } catch (ConcurrentModificationException cme) {
      // Pass
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: N/A - Scenario: i2(matched - new object)

Project: guava
 Class: IterablesTest
 Method: testConcatNullPointerException
 Body: {
    List<Integer> list1 = newArrayList(1);
    List<Integer> list2 = newArrayList(4);

    try {
      Iterables.concat(list1, null, list2);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: concat(oneMC) - Predicate: N/A - Scenario: list2(outer1)

Project: guava
 Class: IterablesTest
 Method: testPoorlyBehavedTransform
 Body: {
    List<String> input = asList("1", null, "3");
    Iterable<Integer> result =
        Iterables.transform(
            input,
            new Function<String, Integer>() {
              @Override
              public Integer apply(String from) {
                return Integer.valueOf(from);
              }
            });

    Iterator<Integer> resultIterator = result.iterator();
    resultIterator.next();

    try {
      resultIterator.next();
      fail("Expected NFE");
    } catch (NumberFormatException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: N/A - Scenario: resultIterator(matched - new object)

Project: guava
 Class: IterablesTest
 Method: testUnmodifiableIterable
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterable<String> iterable = Iterables.unmodifiableIterable(list);
    Iterator<String> iterator = iterable.iterator();
    iterator.next();
    try {
      iterator.remove();
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    assertEquals("[a, b, c]", iterable.toString());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(unmatched) - Predicate: toString(outer) - Scenario: iterator(matched - new object)

Project: guava
 Class: IterablesTest
 Method: testMergeSorted_empty
 Body: {
    // Setup
    Iterable<Iterable<Integer>> elements = ImmutableList.of();

    // Test
    Iterable<Integer> iterable = Iterables.mergeSorted(elements, Ordering.natural());

    // Verify
    Iterator<Integer> iterator = iterable.iterator();
    assertFalse(iterator.hasNext());
    try {
      iterator.next();
      fail("next() on empty iterator should throw NoSuchElementException");
    } catch (NoSuchElementException e) {
      // Huzzah!
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: ArrayListMultimapTest
 Method: testSublistConcurrentModificationException
 Body: {
    ListMultimap<String, Integer> multimap = create();
    multimap.putAll("foo", asList(1, 2, 3, 4, 5));
    List<Integer> list = multimap.get("foo");
    assertThat(multimap.get("foo")).containsExactly(1, 2, 3, 4, 5).inOrder();
    List<Integer> sublist = list.subList(0, 5);
    assertThat(sublist).containsExactly(1, 2, 3, 4, 5).inOrder();

    sublist.clear();
    assertTrue(sublist.isEmpty());
    multimap.put("foo", 6);

    try {
      sublist.isEmpty();
      fail("Expected ConcurrentModificationException");
    } catch (ConcurrentModificationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: isEmpty(unmatched) - Predicate: N/A(outer) - Scenario: sublist(matched - new object)

Project: guava
 Class: PrimitivesTest
 Method: testAllPrimitiveTypes
 Body: {
    Set<Class<?>> primitives = Primitives.allPrimitiveTypes();
    assertEquals(
        ImmutableSet.<Object>of(
            boolean.class,
            byte.class,
            char.class,
            double.class,
            float.class,
            int.class,
            long.class,
            short.class,
            void.class),
        primitives);

    try {
      primitives.remove(boolean.class);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: of(outer) - Scenario: primitives(outer1)

Project: guava
 Class: PrimitivesTest
 Method: testAllWrapperTypes
 Body: {
    Set<Class<?>> wrappers = Primitives.allWrapperTypes();
    assertEquals(
        ImmutableSet.<Object>of(
            Boolean.class,
            Byte.class,
            Character.class,
            Double.class,
            Float.class,
            Integer.class,
            Long.class,
            Short.class,
            Void.class),
        wrappers);

    try {
      wrappers.remove(Boolean.class);
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: of(outer) - Scenario: wrappers(outer1)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredEntriesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.put("cow", 7);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredEntriesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.putAll(ImmutableMap.of("sheep", 5, "cow", 7));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredKeysIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredValuesIllegalSetValue
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      filtered.put("b", 4);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      Entry<String, Integer> entry = filtered.entrySet().iterator().next();
      try {
        entry.setValue(5);
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredValuesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredValuesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 4, "zzz", 5, "b", 6));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredMapTest
 Method: testFilteredKeysIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 3, "zzz", 4, "b", 5));
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: TypeTokenTest
 Method: testSerializable
 Body: {
    reserialize(TypeToken.of(String.class));
    reserialize(TypeToken.of(String.class).getTypes());
    reserialize(TypeToken.of(String.class).getTypes().classes());
    reserialize(TypeToken.of(String.class).getTypes().interfaces());
    reserialize(TypeToken.of(String.class).getTypes().rawTypes());
    reserialize(TypeToken.of(String.class).getTypes().classes().rawTypes());
    reserialize(TypeToken.of(String.class).getTypes().interfaces().rawTypes());
    reserialize(new TypeToken<int[]>() {});
    reserialize(new TypeToken<Map<String, Integer>>() {});
    reserialize(new IKnowMyType<Map<? super String, ? extends int[]>>() {}.type());
    reserialize(TypeToken.of(new TypeCapture<B>() {}.capture()).getTypes().rawTypes());
    try {
      SerializableTester.reserialize(TypeToken.of(new TypeCapture<B>() {}.capture()));
      fail();
    } catch (RuntimeException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: reserialize(matched) - Predicate: N/A - Scenario: SerializableTester(inner2)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testExplicitOrdering_cycleWithUnorderedLock
 Body: {
    Lock myLock = CycleDetectingLockFactory.newInstance(Policies.THROW).newReentrantLock("MyLock");
    lock03.lock();
    myLock.lock();
    lock03.unlock();

    try {
      lock01.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          "MyLock -> OtherOrder.FIRST",
          "OtherOrder.THIRD -> MyLock",
          "OtherOrder.FIRST -> OtherOrder.THIRD");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(unmatched) - Predicate: N/A - Scenario: lock01(unmatched - new object)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReadWriteLockDeadlock_transitive
 Body: {
    readLockA.lock(); // Establish an ordering from readLockA -> lockB
    lockB.lock();
    readLockA.unlock();
    lockB.unlock();

    // Establish an ordering from lockB -> lockC
    lockB.lock();
    lockC.lock();
    lockB.unlock();
    lockC.unlock();

    // lockC -> writeLockA should fail.
    lockC.lock();
    try {
      writeLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockC -> ReadWriteA", "LockB -> LockC", "ReadWriteA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: writeLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testDifferentLockFactories
 Body: {
    CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory.newInstance(Policies.WARN);
    ReentrantLock lockD = otherFactory.newReentrantLock("LockD");

    // lockA -> lockD
    lockA.lock();
    lockD.lock();
    lockA.unlock();
    lockD.unlock();

    // lockD -> lockA should fail even though lockD is from a different factory.
    lockD.lock();
    try {
      lockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockD -> LockA", "LockA -> LockD");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: lockA(unmatched - new object)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReadLock_transitive
 Body: {
    readLockA.lock(); // Establish an ordering from readLockA -> lockB.
    lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    // Establish an ordering from lockB -> readLockC.
    lockB.lock();
    readLockC.lock();
    lockB.unlock();
    readLockC.unlock();

    // readLockC -> readLockA
    readLockC.lock();
    try {
      readLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected, "ReadWriteC -> ReadWriteA", "LockB -> ReadWriteC", "ReadWriteA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: readLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReadWriteLockDeadlock_treatedEquivalently
 Body: {
    readLockA.lock(); // readLockA -> writeLockB
    writeLockB.lock();
    readLockA.unlock();
    writeLockB.unlock();

    // readLockB -> writeLockA should fail.
    readLockB.lock();
    try {
      writeLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "ReadWriteB -> ReadWriteA", "ReadWriteA -> ReadWriteB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: writeLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testExplicitOrdering_acquiringMultipleLocksWithSameRank
 Body: {
    CycleDetectingLockFactory.WithExplicitOrdering<OtherOrder> factory =
        newInstanceWithExplicitOrdering(OtherOrder.class, Policies.THROW);
    Lock lockA = factory.newReentrantLock(OtherOrder.FIRST);
    Lock lockB = factory.newReentrantReadWriteLock(OtherOrder.FIRST).readLock();

    lockA.lock();
    try {
      lockB.lock();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }

    lockA.unlock();
    lockB.lock();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: lockB(matched - new object)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReadLock_deadlock
 Body: {
    readLockA.lock(); // Establish an ordering from readLockA -> lockB.
    lockB.lock();
    lockB.unlock();
    readLockA.unlock();

    lockB.lock();
    try {
      readLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockB -> ReadWriteA", "ReadWriteA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: readLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReadWriteLockDeadlock
 Body: {
    writeLockA.lock(); // Establish an ordering from writeLockA -> lockB
    lockB.lock();
    writeLockA.unlock();
    lockB.unlock();

    // lockB -> readLockA should fail.
    lockB.lock();
    try {
      readLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockB -> ReadWriteA", "ReadWriteA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(matched) - Predicate: N/A - Scenario: readLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testWriteToReadLockDowngrading
 Body: {
    writeLockA.lock(); // writeLockA downgrades to readLockA
    readLockA.lock();
    writeLockA.unlock();

    lockB.lock(); // readLockA -> lockB
    readLockA.unlock();

    // lockB -> writeLockA should fail
    try {
      writeLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockB -> ReadWriteA", "ReadWriteA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(unmatched) - Predicate: N/A - Scenario: writeLockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testDeadlock_threeLocks
 Body: {
    // Establish an ordering from lockA -> lockB.
    lockA.lock();
    lockB.lock();
    lockB.unlock();
    lockA.unlock();

    // Establish an ordering from lockB -> lockC.
    lockB.lock();
    lockC.lock();
    lockB.unlock();

    // lockC -> lockA should fail.
    try {
      lockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(expected, "LockC -> LockA", "LockB -> LockC", "LockA -> LockB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(unmatched) - Predicate: N/A - Scenario: lockA(unmatched - actionReference)

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testWriteLock_threeLockDeadLock
 Body: {
    // Establish an ordering from writeLockA -> writeLockB.
    writeLockA.lock();
    writeLockB.lock();
    writeLockB.unlock();
    writeLockA.unlock();

    // Establish an ordering from writeLockB -> writeLockC.
    writeLockB.lock();
    writeLockC.lock();
    writeLockB.unlock();

    // writeLockC -> writeLockA should fail.
    try {
      writeLockA.lock();
      fail("Expected PotentialDeadlockException");
    } catch (PotentialDeadlockException expected) {
      checkMessage(
          expected,
          "ReadWriteC -> ReadWriteA",
          "ReadWriteB -> ReadWriteC",
          "ReadWriteA -> ReadWriteB");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: lock(unmatched) - Predicate: N/A - Scenario: writeLockA(unmatched - actionReference)

Project: guava
 Class: DefaultNetworkImplementationsTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    network.addNode(N1);
    network.addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      network.addEdge(N1, N2, E12);
      assertThat(networkForTest.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: EnumHashBiMapTest
 Method: testCreateFromMap
 Body: {
    /* Test with non-empty Map. */
    Map<Currency, String> map =
        ImmutableMap.of(
            Currency.DOLLAR, "dollar",
            Currency.PESO, "peso",
            Currency.FRANC, "franc");
    EnumHashBiMap<Currency, String> bimap = EnumHashBiMap.create(map);
    assertEquals("dollar", bimap.get(Currency.DOLLAR));
    assertEquals(Currency.DOLLAR, bimap.inverse().get("dollar"));

    /* Map must have at least one entry if not an EnumHashBiMap. */
    try {
      EnumHashBiMap.create(Collections.<Currency, String>emptyMap());
      fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException expected) {
    }

    /* Map can be empty if it's an EnumHashBiMap. */
    Map<Currency, String> emptyBimap = EnumHashBiMap.create(Currency.class);
    bimap = EnumHashBiMap.create(emptyBimap);
    assertTrue(bimap.isEmpty());

    /* Map can be empty if it's an EnumBiMap. */
    Map<Currency, Country> emptyBimap2 = EnumBiMap.create(Currency.class, Country.class);
    EnumHashBiMap<Currency, Country> bimap2 = EnumHashBiMap.create(emptyBimap2);
    assertTrue(bimap2.isEmpty());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: create(oneMC) - Predicate: get(outer) - Scenario: bimap(outer1)

Project: guava
 Class: TypeTokenSubtypeTest
 Method: testGetSubtypeOf_impossibleWildcard
 Body: {
    TypeToken<List<? extends Number>> numberList = new TypeToken<List<? extends Number>>() {};
    abstract class StringList implements List<String> {}
    try {
      numberList.getSubtype(StringList.class);
      fail();
    } catch (IllegalArgumentException expected) {}
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getSubtype(oneMC) - Predicate: N/A - Scenario: 

Project: guava
 Class: BiMapPutTester
 Method: testPutWithSameValueFails
 Body: {
    getMap().put(k0(), v0());
    try {
      getMap().put(k1(), v0());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
      // success
    }
    // verify that the bimap is unchanged
    expectAdded(e0());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: N/A - Scenario: getMap()(matched - actionReference)

Project: guava
 Class: MultimapPutIterableTester
 Method: testPutAllNullValueNullFirst_unsupported
 Body: {
    int size = getNumElements();

    try {
      multimap().putAll(k3(), Lists.newArrayList(null, v3()));
      fail();
    } catch (NullPointerException expected) {
    }

    /*
     * In principle, a Multimap implementation could add e3 first before failing on the null. But
     * that seems unlikely enough to be worth complicating the test over, especially if there's any
     * chance that a permissive test could mask a bug.
     */
    expectUnchanged();
    // Be extra thorough in case internal state was corrupted by the expected null.
    assertEquals(Lists.newArrayList(), Lists.newArrayList(multimap().get(k3())));
    assertEquals(size, multimap().size());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(oneMC) - Predicate: newArrayList(outer) - Scenario: size(outer1)

Project: guava
 Class: CreationTests
 Method: testBuilderAddCollectionHandlesNulls
 Body: {
      List<String> elements = Arrays.asList("a", null, "b");
      ImmutableList.Builder<String> builder = ImmutableList.builder();
      try {
        builder.addAll(elements);
        fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
      ImmutableList<String> result = builder.build();
      assertEquals(ImmutableList.of("a"), result);
      assertEquals(1, result.size());
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addAll(oneMC) - Predicate: of(outer) - Scenario: builder(outer1)

Project: guava
 Class: PairedStatsTest
 Method: testFromByteArrayWithTooShortArrayInputThrowsIllegalArgumentException
 Body: {
    byte[] buffer = MANY_VALUES_PAIRED_STATS.toByteArray();
    byte[] tooShortByteArray =
        ByteBuffer.allocate(buffer.length - 1)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer, 0, buffer.length - 1)
            .array();
    try {
      PairedStats.fromByteArray(tooShortByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: fromByteArray(oneMC) - Predicate: N/A - Scenario: tooShortByteArray(outer1)

Project: guava
 Class: PairedStatsTest
 Method: testFromByteArray_withTooLongArrayInputThrowsIllegalArgumentException
 Body: {
    byte[] buffer = MANY_VALUES_PAIRED_STATS.toByteArray();
    byte[] tooLongByteArray =
        ByteBuffer.allocate(buffer.length + 2)
            .order(ByteOrder.LITTLE_ENDIAN)
            .put(buffer)
            .putChar('.')
            .array();
    try {
      PairedStats.fromByteArray(tooLongByteArray);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: fromByteArray(oneMC) - Predicate: N/A - Scenario: tooLongByteArray(outer1)

Project: guava
 Class: PeekingIteratorTest
 Method: testCantRemoveAfterPeek
 Body: {
    List<String> list = Lists.newArrayList("A", "B", "C");
    Iterator<String> iterator = list.iterator();
    PeekingIterator<?> peekingIterator = Iterators.peekingIterator(iterator);

    assertEquals("A", peekingIterator.next());
    assertEquals("B", peekingIterator.peek());

    /* Should complain on attempt to remove() after peek(). */
    try {
      peekingIterator.remove();
      fail("remove() should throw IllegalStateException after a peek()");
    } catch (IllegalStateException e) {
      /* expected */
    }

    assertEquals(
        "After remove() throws exception, peek should still be ok", "B", peekingIterator.peek());

    /* Should recover to be able to remove() after next(). */
    assertEquals("B", peekingIterator.next());
    peekingIterator.remove();
    assertEquals("Should have removed an element", 2, list.size());
    assertFalse("Second element should be gone", list.contains("B"));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: next(outer) - Scenario: peekingIterator(outer1)

Project: guava
 Class: PeekingIteratorTest
 Method: testPeekOnEmptyList
 Body: {
    List<?> list = Collections.emptyList();
    Iterator<?> iterator = list.iterator();
    PeekingIterator<?> peekingIterator = Iterators.peekingIterator(iterator);

    try {
      peekingIterator.peek();
      fail("Should throw NoSuchElementException if nothing to peek()");
    } catch (NoSuchElementException e) {
      /* expected */
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: peek(oneMC) - Predicate: N/A - Scenario: peekingIterator(outer1)

Project: guava
 Class: ArrayBasedUnicodeEscaperTest
 Method: testReplacements
 Body: {
    // In reality this is not a very sensible escaper to have (if you are only
    // escaping elements from a map you would use a ArrayBasedCharEscaper).
    UnicodeEscaper escaper =
        new ArrayBasedUnicodeEscaper(
            SIMPLE_REPLACEMENTS, Character.MIN_VALUE, Character.MAX_CODE_POINT, null) {
          @Override
          protected char[] escapeUnsafe(int c) {
            return NO_CHARS;
          }
        };
    EscaperAsserts.assertBasic(escaper);
    assertEquals("<tab>Fish <and> Chips<newline>", escaper.escape("\tFish & Chips\n"));

    // Verify that everything else is left unescaped.
    String safeChars = "\0\u0100\uD800\uDC00\uFFFF";
    assertEquals(safeChars, escaper.escape(safeChars));

    // Ensure that Unicode escapers behave correctly wrt badly formed input.
    String badUnicode = "\uDC00\uD800";
    try {
      escaper.escape(badUnicode);
      fail("should fail for bad Unicode");
    } catch (IllegalArgumentException e) {
      // Pass
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: escape(oneMC) - Predicate: N/A(outer) - Scenario: badUnicode(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadCheckedException
 Body: {
    Exception e = new Exception();
    CacheLoader<Object, Object> loader = exceptionLoader(e);
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertSame(e, expected.getCause());
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: getCause(unmatched) - Scenario: stats(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadError
 Body: {
    Error e = new Error();
    CacheLoader<Object, Object> loader = errorLoader(e);
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionError expected) {
      assertSame(e, expected.getCause());
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: getCause(unmatched) - Scenario: stats(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testReloadAfterFailure
 Body: {
    final AtomicInteger count = new AtomicInteger();
    final Exception e = new IllegalStateException("exception to trigger failure on first load()");
    CacheLoader<Integer, String> failOnceFunction =
        new CacheLoader<Integer, String>() {

          @Override
          public String load(Integer key) throws Exception {
            if (count.getAndIncrement() == 0) {
              throw e;
            }
            return key.toString();
          }
        };
    CountingRemovalListener<Integer, String> removalListener = countingRemovalListener();
    LoadingCache<Integer, String> cache =
        CacheBuilder.newBuilder().removalListener(removalListener).build(failOnceFunction);

    try {
      cache.getUnchecked(1);
      fail();
    } catch (UncheckedExecutionException ue) {
      assertSame(e, ue.getCause());
    }

    assertEquals("1", cache.getUnchecked(1));
    assertEquals(0, removalListener.getCount());

    count.set(0);
    cache.refresh(2);
    checkLoggedCause(e);

    assertEquals("2", cache.getUnchecked(2));
    assertEquals(0, removalListener.getCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(oneMC) - Predicate: getCause(unmatched) - Scenario: cache(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadInterruptedException
 Body: {
    Exception e = new InterruptedException();
    CacheLoader<Object, Object> loader = exceptionLoader(e);
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException expected) {
      assertSame(e, expected.getCause());
    }
    assertTrue(currentThread().interrupted());
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: getCause(unmatched) - Scenario: stats(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoad_partial
 Body: {
    final Object extraKey = new Object();
    final Object extraValue = new Object();
    CacheLoader<Object, Object> loader =
        new CacheLoader<Object, Object>() {
          @Override
          public Object load(Object key) throws Exception {
            throw new AssertionError();
          }

          @Override
          public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
            Map<Object, Object> result = Maps.newHashMap();
            // ignore request keys
            result.put(extraKey, extraValue);
            return result;
          }
        };
    LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);

    Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
    try {
      cache.getAll(asList(lookupKeys));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    assertSame(extraValue, cache.asMap().get(extraKey));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: get(outer) - Scenario: lookupKeys(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadNullMap
 Body: {
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .recordStats()
            .build(
                new CacheLoader<Object, Object>() {
                  @Override
                  public Object load(Object key) {
                    throw new AssertionError();
                  }

                  @Override
                  public Map<Object, Object> loadAll(Iterable<?> keys) {
                    return null;
                  }
                });

    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: missCount(outer) - Scenario: stats(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadNull
 Body: {
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (InvalidCacheLoadException expected) {
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: missCount(outer) - Scenario: stats(outer1)

Project: guava
 Class: CacheLoadingTest
 Method: testBulkLoadUncheckedException
 Body: {
    Exception e = new RuntimeException();
    CacheLoader<Object, Object> loader = exceptionLoader(e);
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
    CacheStats stats = cache.stats();
    assertEquals(0, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());

    try {
      cache.getAll(asList(new Object()));
      fail();
    } catch (UncheckedExecutionException expected) {
      assertSame(e, expected.getCause());
    }
    stats = cache.stats();
    assertEquals(1, stats.missCount());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(1, stats.loadExceptionCount());
    assertEquals(0, stats.hitCount());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getAll(oneMC) - Predicate: getCause(unmatched) - Scenario: stats(outer1)

Project: guava
 Class: ConfigurableUndirectedGraphTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableUndirectedGraphTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = graph.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.successors(N1)).containsExactlyElementsIn(successors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableUndirectedGraphTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);
    try {
      incidentEdges.add(EndpointPair.unordered(N1, N2));
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: incidentEdges(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedGraphTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = graph.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: SimpleTimeLimiterTest
 Method: testNewProxy_goodMethodWithNotEnoughTime
 Body: {
    SampleImpl target = new SampleImpl(9999);
    Sample proxy = service.newProxy(target, Sample.class, NOT_ENOUGH_MS, MILLISECONDS);
    Stopwatch stopwatch = Stopwatch.createStarted();

    try {
      proxy.sleepThenReturnInput("x");
      fail("no exception thrown");
    } catch (UncheckedTimeoutException expected) {
    }

    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(NOT_ENOUGH_MS, DELAY_MS * 2));
    // Is it still computing away anyway?
    assertThat(target.finished).isFalse();
    MILLISECONDS.sleep(ENOUGH_MS);
    assertThat(target.finished).isFalse();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: sleepThenReturnInput(oneMC) - Predicate: closed(outer) - Scenario: stopwatch(outer1)

Project: guava
 Class: SimpleTimeLimiterTest
 Method: testNewProxy_badMethodWithEnoughTime
 Body: {
    SampleImpl target = new SampleImpl(DELAY_MS);
    Sample proxy = service.newProxy(target, Sample.class, ENOUGH_MS, MILLISECONDS);
    Stopwatch stopwatch = Stopwatch.createStarted();

    try {
      proxy.sleepThenThrowException();
      fail("no exception thrown");
    } catch (SampleException expected) {
    }

    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(DELAY_MS, ENOUGH_MS));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: sleepThenThrowException(oneMC) - Predicate: closed(outer) - Scenario: stopwatch(outer1)

Project: guava
 Class: SimpleTimeLimiterTest
 Method: testNewProxy_badMethodWithNotEnoughTime
 Body: {
    SampleImpl target = new SampleImpl(9999);
    Sample proxy = service.newProxy(target, Sample.class, NOT_ENOUGH_MS, MILLISECONDS);
    Stopwatch stopwatch = Stopwatch.createStarted();

    try {
      proxy.sleepThenThrowException();
      fail("no exception thrown");
    } catch (UncheckedTimeoutException expected) {
    }

    assertThat(stopwatch.elapsed(MILLISECONDS)).isIn(Range.closed(NOT_ENOUGH_MS, DELAY_MS * 2));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: sleepThenThrowException(oneMC) - Predicate: closed(outer) - Scenario: stopwatch(outer1)

Project: guava
 Class: TrustedListenableFutureTaskTest
 Method: testCancelled
 Body: {
    TrustedListenableFutureTask<Integer> task = TrustedListenableFutureTask.create(returning(2));
    assertFalse(task.isDone());
    task.cancel(false);
    assertTrue(task.isDone());
    assertTrue(task.isCancelled());
    assertFalse(task.wasInterrupted());
    try {
      getDone(task);
      fail();
    } catch (CancellationException expected) {
    }
    verifyThreadWasNotInterrupted();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: isDone(outer) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: TrustedListenableFutureTaskTest
 Method: testCancel_interrupted
 Body: {
    final AtomicBoolean interruptedExceptionThrown = new AtomicBoolean();
    final CountDownLatch enterLatch = new CountDownLatch(1);
    final CountDownLatch exitLatch = new CountDownLatch(1);
    final TrustedListenableFutureTask<Integer> task =
        TrustedListenableFutureTask.create(
            new Callable<Integer>() {
              @Override
              public Integer call() throws Exception {
                enterLatch.countDown();
                try {
                  new CountDownLatch(1).await(); // wait forever
                  throw new AssertionError();
                } catch (InterruptedException e) {
                  interruptedExceptionThrown.set(true);
                  throw e;
                } finally {
                }
              }
            });
    assertFalse(task.isDone());
    Thread thread =
        new Thread(
            new Runnable() {
              @Override
              public void run() {
                try {
                  task.run();
                } finally {
                  exitLatch.countDown();
                }
              }
            });
    thread.start();
    enterLatch.await();
    assertFalse(task.isDone());
    task.cancel(true);
    assertTrue(task.isDone());
    assertTrue(task.isCancelled());
    assertTrue(task.wasInterrupted());
    try {
      task.get();
      fail();
    } catch (CancellationException expected) {
    }
    exitLatch.await();
    assertTrue(interruptedExceptionThrown.get());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: isDone(outer) - Scenario: task(unmatched - new object)

Project: guava
 Class: TrustedListenableFutureTaskTest
 Method: testFailed
 Body: {
    final Exception e = new Exception();
    TrustedListenableFutureTask<Integer> task =
        TrustedListenableFutureTask.create(
            new Callable<Integer>() {
              @Override
              public Integer call() throws Exception {
                throw e;
              }
            });
    task.run();
    assertTrue(task.isDone());
    assertFalse(task.isCancelled());
    try {
      getDone(task);
      fail();
    } catch (ExecutionException executionException) {
      assertEquals(e, executionException.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getDone(unmatched) - Predicate: getCause(unmatched) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: CreationTests
 Method: testBuilderPutImmutableEntryWithNullKeyFailsAtomically
 Body: {
      Builder<String, Integer> builder = new Builder<>();
      try {
        builder.put(Maps.immutableEntry((String) null, 1));
        fail();
      } catch (NullPointerException expected) {
      }
      builder.put("foo", 2);
      assertMapEquals(builder.build(), "foo", 2);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(oneMC) - Predicate: build(outer) - Scenario: builder(outer1)

Project: guava
 Class: CreationTests
 Method: testBuilderPutNullKeyFailsAtomically
 Body: {
      Builder<String, Integer> builder = new Builder<>();
      try {
        builder.put(null, 1);
        fail();
      } catch (NullPointerException expected) {
      }
      builder.put("foo", 2);
      assertMapEquals(builder.build(), "foo", 2);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(oneMC) - Predicate: build(outer) - Scenario: builder(outer1)

Project: guava
 Class: CreationTests
 Method: testBuilderPutMutableEntryWithNullKeyFailsAtomically
 Body: {
      Builder<String, Integer> builder = new Builder<>();
      try {
        builder.put(new SimpleEntry<String, Integer>(null, 1));
        fail();
      } catch (NullPointerException expected) {
      }
      builder.put("foo", 2);
      assertMapEquals(builder.build(), "foo", 2);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(oneMC) - Predicate: build(outer) - Scenario: builder(outer1)

Project: guava
 Class: CollectionRemoveTester
 Method: testIteratorRemove_unsupported
 Body: {
    Iterator<E> iterator = collection.iterator();
    iterator.next();
    try {
      iterator.remove();
      fail("iterator.remove() should throw UnsupportedOperationException");
    } catch (UnsupportedOperationException expected) {
    }
    expectUnchanged();
    assertTrue(collection.contains(e0()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(unmatched) - Predicate: contains(outer) - Scenario: iterator(matched - new object)

Project: guava
 Class: TestingExecutorsTest
 Method: testSameThreadScheduledExecutorWithException
 Body: {
    Runnable runnable =
        new Runnable() {
          @Override
          public void run() {
            throw new RuntimeException("Oh no!");
          }
        };

    Future<?> future = TestingExecutors.sameThreadScheduledExecutor().submit(runnable);
    try {
      future.get();
      fail("Should have thrown exception");
    } catch (ExecutionException e) {
      // pass
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: N/A - Scenario: future(outer1)

Project: guava
 Class: UninterruptibleFutureTest
 Method: testMakeUninterruptible_timeoutPreservedThroughInterruption
 Body: {

    repeatedlyInterruptTestThread(100, tearDownStack);

    try {
      getUninterruptibly(delayedFuture, 500, TimeUnit.MILLISECONDS);
      fail("expected to time out");
    } catch (TimeoutException expected) {
    }
    assertTrue(Thread.interrupted()); // clears the interrupt state, too

    assertFalse(sleeper.completed);
    assertTrue(getUninterruptibly(delayedFuture));

    assertTrue(Thread.interrupted()); // clears the interrupt state, too
    assertTrue(sleeper.completed);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUninterruptibly(unmatched) - Predicate: interrupted(outer) - Scenario: N/A

Project: guava
 Class: UninterruptibleFutureTest
 Method: testMakeUninterruptible_plainFutureSanityCheck
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    FutureTask<Boolean> wasInterrupted = untimedInterruptReporter(future, true);

    Thread waitingThread = new Thread(wasInterrupted);
    waitingThread.start();
    waitingThread.interrupt();
    try {
      wasInterrupted.get();
      fail();
    } catch (ExecutionException expected) {
      assertTrue(
          expected.getCause().toString(), expected.getCause() instanceof InterruptedException);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: toString(inner) - Scenario: wasInterrupted(unmatched - new object)

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testIteratorConcurrentModification
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(Lists.newArrayList(1, 2, 3, 4));
    Iterator<Integer> it = mmHeap.iterator();
    assertTrue("Iterator has reached end prematurely", it.hasNext());
    it.next();
    it.next();
    mmHeap.remove(4);
    try {
      it.next();
      fail("No exception thrown when iterating a modified heap");
    } catch (ConcurrentModificationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(unmatched) - Predicate: hasNext(outer) - Scenario: it(matched - new object)

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testIteratorPastEndException
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(Lists.newArrayList(1, 2));
    Iterator<Integer> it = mmHeap.iterator();
    assertTrue("Iterator has reached end prematurely", it.hasNext());
    it.next();
    it.next();
    try {
      it.next();
      fail("No exception thrown when iterating past end of heap");
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: hasNext(outer) - Scenario: it(matched - new object)

Project: guava
 Class: AbstractFutureTest
 Method: testCancel_notDoneNoInterrupt
 Body: {
    InterruptibleFuture future = new InterruptibleFuture();
    assertTrue(future.cancel(false));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertFalse(future.wasInterrupted());
    assertFalse(future.interruptTaskWasCalled);
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      // See AbstractFutureCancellationCauseTest for how to set causes
      assertNull(e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(unmatched) - Scenario: future(outer1)

Project: guava
 Class: AbstractFutureTest
 Method: testToString_notDone
 Body: {
    AbstractFuture<Object> testFuture =
        new AbstractFuture<Object>() {
          @Override
          public String pendingToString() {
            return "cause=[Because this test isn't done]";
          }
        };
    assertThat(testFuture.toString())
        .matches(
            "[^\\[]+\\[status=PENDING, info=\\[cause=\\[Because this test isn't done\\]\\]\\]");
    try {
      testFuture.get(1, TimeUnit.NANOSECONDS);
      fail();
    } catch (TimeoutException e) {
      assertThat(e.getMessage()).contains("1 nanoseconds");
      assertThat(e.getMessage()).contains("Because this test isn't done");
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: N/A(matched) - Scenario: testFuture(outer1)

Project: guava
 Class: AbstractFutureTest
 Method: testForwardExceptionFastPath
 Body: {
    class FailFuture extends InternalFutureFailureAccess implements ListenableFuture<String> {
      Throwable failure;

      FailFuture(Throwable throwable) {
        failure = throwable;
      }

      @Override
      public boolean cancel(boolean mayInterruptIfRunning) {
        throw new AssertionFailedError("cancel shouldn't be called on this object");
      }

      @Override
      public boolean isCancelled() {
        return false;
      }

      @Override
      public boolean isDone() {
        return true;
      }

      @Override
      public String get() throws InterruptedException, ExecutionException {
        throw new AssertionFailedError("get() shouldn't be called on this object");
      }

      @Override
      public String get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException {
        return get();
      }

      @Override
      protected Throwable tryInternalFastPathGetFailure() {
        return failure;
      }

      @Override
      public void addListener(Runnable listener, Executor executor) {
        throw new AssertionFailedError("addListener() shouldn't be called on this object");
      }
    }

    final RuntimeException exception = new RuntimeException("you still didn't say the magic word!");
    SettableFuture<String> normalFuture = SettableFuture.create();
    normalFuture.setFuture(new FailFuture(exception));
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertSame(exception, e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: getCause(unmatched) - Scenario: normalFuture(matched - new object)

Project: guava
 Class: AbstractFutureTest
 Method: testSetIndirectSelf_toString
 Body: {
    final SettableFuture<Object> orig = SettableFuture.create();
    // unlike the above this indirection defeats the trivial cycle detection and causes a SOE
    orig.set(
        new Object() {
          @Override
          public String toString() {
            return orig.toString();
          }
        });
    try {
      orig.toString();
      fail();
    } catch (StackOverflowError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: toString(unmatched) - Predicate: N/A - Scenario: orig(matched - new object)

Project: guava
 Class: AbstractFutureTest
 Method: testCancel_notDoneInterrupt
 Body: {
    InterruptibleFuture future = new InterruptibleFuture();
    assertTrue(future.cancel(true));
    assertTrue(future.isCancelled());
    assertTrue(future.isDone());
    assertTrue(future.wasInterrupted());
    assertTrue(future.interruptTaskWasCalled);
    try {
      future.get();
      fail("Expected CancellationException");
    } catch (CancellationException e) {
      // See AbstractFutureCancellationCauseTest for how to set causes
      assertNull(e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(unmatched) - Scenario: future(outer1)

Project: guava
 Class: AbstractFutureTest
 Method: testEvilFuture_setFuture
 Body: {
    final RuntimeException exception = new RuntimeException("you didn't say the magic word!");
    AbstractFuture<String> evilFuture =
        new AbstractFuture<String>() {
          @Override
          public void addListener(Runnable r, Executor e) {
            throw exception;
          }
        };
    AbstractFuture<String> normalFuture = new AbstractFuture<String>() {};
    normalFuture.setFuture(evilFuture);
    assertTrue(normalFuture.isDone());
    try {
      normalFuture.get();
      fail();
    } catch (ExecutionException e) {
      assertSame(exception, e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: getCause(unmatched) - Scenario: normalFuture(matched - new object)

Project: guava
 Class: MediaTypeTest
 Method: testWithParameters_invalidAttribute
 Body: {
    MediaType mediaType = MediaType.parse("text/plain");
    ImmutableListMultimap<String, String> parameters =
        ImmutableListMultimap.of("a", "1", "@", "2", "b", "3");
    try {
      mediaType.withParameters(parameters);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: withParameters(oneMC) - Predicate: N/A - Scenario: parameters(outer1)

Project: guava
 Class: FunctionalTest
 Method: testStop_failed
 Body: {
      final Exception exception = new Exception("deliberate");
      AbstractIdleService service =
          new DefaultService() {
            @Override
            protected void shutDown() throws Exception {
              throw exception;
            }
          };
      service.startAsync().awaitRunning();
      try {
        service.stopAsync().awaitTerminated();
        fail();
      } catch (RuntimeException e) {
        assertSame(exception, e.getCause());
      }
      assertEquals(Service.State.FAILED, service.state());
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: getCause(unmatched) - Scenario: service.stopAsync()(unmatched - new object)

Project: guava
 Class: FunctionalTest
 Method: testStart_failed
 Body: {
      final Exception exception = new Exception("deliberate");
      AbstractIdleService service =
          new DefaultService() {
            @Override
            protected void startUp() throws Exception {
              throw exception;
            }
          };
      try {
        service.startAsync().awaitRunning();
        fail();
      } catch (RuntimeException e) {
        assertSame(exception, e.getCause());
      }
      assertEquals(Service.State.FAILED, service.state());
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(oneMC) - Predicate: getCause(unmatched) - Scenario: service(outer1)

Project: guava
 Class: MultimapsTest
 Method: testFilteredKeysSetMultimapReplaceValues
 Body: {
    SetMultimap<String, Integer> multimap = LinkedHashMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("baz", 3);
    multimap.put("bar", 4);

    SetMultimap<String, Integer> filtered =
        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of("foo", "bar")));

    assertEquals(ImmutableSet.of(), filtered.replaceValues("baz", ImmutableSet.<Integer>of()));

    try {
      filtered.replaceValues("baz", ImmutableSet.of(5));
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: replaceValues(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: OrderingTest
 Method: testExplicit_two
 Body: {
    Comparator<Integer> c = Ordering.explicit(42, 5);
    assertEquals(0, c.compare(5, 5));
    assertTrue(c.compare(5, 42) > 0);
    assertTrue(c.compare(42, 5) < 0);
    try {
      c.compare(5, 666);
      fail();
    } catch (IncomparableValueException expected) {
      assertEquals(666, expected.value);
    }
    new EqualsTester()
        .addEqualityGroup(c, Ordering.explicit(42, 5))
        .addEqualityGroup(Ordering.explicit(5, 42))
        .addEqualityGroup(Ordering.explicit(42))
        .testEquals();
    reserializeAndAssert(c);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: compare(oneMC) - Predicate: N/A(unmatched) - Scenario: c(outer1)

Project: guava
 Class: OrderingTest
 Method: testExplicit_one
 Body: {
    Comparator<Integer> c = Ordering.explicit(0);
    assertEquals(0, c.compare(0, 0));
    try {
      c.compare(0, 1);
      fail();
    } catch (IncomparableValueException expected) {
      assertEquals(1, expected.value);
    }
    reserializeAndAssert(c);
    assertEquals("Ordering.explicit([0])", c.toString());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: compare(oneMC) - Predicate: N/A(unmatched) - Scenario: c(outer1)

Project: guava
 Class: OrderingTest
 Method: testImmutableSortedCopy
 Body: {
    ImmutableList<Integer> unsortedInts = ImmutableList.of(5, 3, 0, 9, 3);
    ImmutableList<Integer> sortedInts = numberOrdering.immutableSortedCopy(unsortedInts);
    assertEquals(Arrays.asList(0, 3, 3, 5, 9), sortedInts);

    assertEquals(
        Collections.<Integer>emptyList(),
        numberOrdering.immutableSortedCopy(Collections.<Integer>emptyList()));

    List<Integer> listWithNull = Arrays.asList(5, 3, null, 9);
    try {
      Ordering.natural().nullsFirst().immutableSortedCopy(listWithNull);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: immutableSortedCopy(oneMC) - Predicate: asList(outer) - Scenario: listWithNull(outer1)

Project: guava
 Class: OrderingTest
 Method: testExplicit_none
 Body: {
    Comparator<Integer> c = Ordering.explicit(Collections.<Integer>emptyList());
    try {
      c.compare(0, 0);
      fail();
    } catch (IncomparableValueException expected) {
      assertEquals(0, expected.value);
    }
    reserializeAndAssert(c);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: compare(oneMC) - Predicate: N/A(inner) - Scenario: c(outer1)

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testAdd_laterFewWithOverflow
 Body: {
    final int INITIAL_COUNT = 92384930;
    final int COUNT_TO_ADD = Integer.MAX_VALUE - INITIAL_COUNT + 1;

    when(backingMap.get(KEY)).thenReturn(new AtomicInteger(INITIAL_COUNT));

    try {
      multiset.add(KEY, COUNT_TO_ADD);
      fail("Must reject arguments that would cause counter overflow.");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A - Scenario: multiset(unmatched - new object)

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testRemoveExactly
 Body: {
    ConcurrentHashMultiset<String> cms = ConcurrentHashMultiset.create();
    cms.add("a", 2);
    cms.add("b", 3);

    try {
      cms.removeExactly("a", -2);
      fail();
    } catch (IllegalArgumentException expected) {
    }

    assertTrue(cms.removeExactly("a", 0));
    assertEquals(2, cms.count("a"));
    assertTrue(cms.removeExactly("c", 0));
    assertEquals(0, cms.count("c"));

    assertFalse(cms.removeExactly("a", 4));
    assertEquals(2, cms.count("a"));
    assertTrue(cms.removeExactly("a", 2));
    assertEquals(0, cms.count("a"));
    assertTrue(cms.removeExactly("b", 2));
    assertEquals(1, cms.count("b"));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: removeExactly(unmatched) - Predicate: removeExactly(outer) - Scenario: cms(matched - new object)

Project: guava
 Class: FuturesTransformAsyncTest
 Method: testFutureGetThrowsCancellationIfOutputCancelled
 Body: {
    inputFuture.set(SLOW_OUTPUT_VALID_INPUT_DATA);
    outputFuture.cancel(true); // argument is ignored
    try {
      resultFuture.get();
      fail(
          "Result future must throw CancellationException"
              + " if function output future is cancelled.");
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A - Scenario: resultFuture(unmatched - actionReference)

Project: guava
 Class: FuturesTransformAsyncTest
 Method: testFutureGetThrowsCancellationIfInputCancelled
 Body: {
    inputFuture.cancel(true); // argument is ignored
    try {
      resultFuture.get();
      fail("Result future must throw CancellationException" + " if input future is cancelled.");
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: N/A - Scenario: resultFuture(unmatched - actionReference)

Project: guava
 Class: FuturesTransformAsyncTest
 Method: testFutureGetThrowsRuntimeException
 Body: {
    BadFuture badInput = new BadFuture(Futures.immediateFuture(20));
    ListenableFuture<String> chain = buildChainingFuture(badInput);
    try {
      chain.get();
      fail("Future.get must throw an exception when the input future fails.");
    } catch (ExecutionException e) {
      assertSame(RuntimeException.class, e.getCause().getClass());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getClass(inner) - Scenario: chain(outer1)

Project: guava
 Class: FuturesTransformAsyncTest
 Method: testFutureCancellableBeforeOutputCompletion
 Body: {
    inputFuture.set(SLOW_OUTPUT_VALID_INPUT_DATA);
    assertTrue(resultFuture.cancel(true));
    assertTrue(resultFuture.isCancelled());
    assertFalse(inputFuture.isCancelled());
    assertTrue(outputFuture.isCancelled());
    try {
      resultFuture.get();
      fail("Result future is cancelled and should have thrown a" + " CancellationException");
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: cancel(outer) - Scenario: resultFuture(unmatched - actionReference)

Project: guava
 Class: TraverserTest
 Method: forTree_withUndirectedNetwork_throws
 Body: {
    MutableNetwork<String, Integer> network = NetworkBuilder.undirected().build();
    network.addEdge("a", "b", 11);

    try {
      Traverser.forTree(network);
      fail("Expected exception");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: forTree(unmatched) - Predicate: N/A - Scenario: Traverser(unmatched - new object)

Project: guava
 Class: TraverserTest
 Method: forTree_withUndirectedValueGraph_throws
 Body: {
    MutableValueGraph<String, Integer> valueGraph = ValueGraphBuilder.undirected().build();
    valueGraph.putEdgeValue("a", "b", 11);

    try {
      Traverser.forTree(valueGraph);
      fail("Expected exception");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: forTree(unmatched) - Predicate: N/A - Scenario: Traverser(unmatched - new object)

Project: guava
 Class: TraverserTest
 Method: forTree_withUndirectedGraph_throws
 Body: {
    MutableGraph<String> graph = GraphBuilder.undirected().build();
    graph.putEdge("a", "b");

    try {
      Traverser.forTree(graph);
      fail("Expected exception");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: forTree(unmatched) - Predicate: N/A - Scenario: Traverser(unmatched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.successors(N1)).containsExactlyElementsIn(successors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: addEdge_parallelSelfLoopEdge
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
      fail("Adding a parallel self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addEdge(matched) - Predicate: N/A(inner) - Scenario: N/A

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: PredicatesTest
 Method: testSubtypeOf_apply
 Body: {
    Predicate<Class<?>> isInteger = Predicates.subtypeOf(Integer.class);

    assertTrue(isInteger.apply(Integer.class));
    assertFalse(isInteger.apply(Float.class));

    try {
      isInteger.apply(null);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: apply(oneMC) - Predicate: apply(outer) - Scenario: isInteger(outer1)

Project: guava
 Class: FuturesGetUncheckedTest
 Method: testGetUnchecked_cancelled
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    future.cancel(true);
    try {
      getUnchecked(future);
      fail();
    } catch (CancellationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getUnchecked(unmatched) - Predicate: N/A - Scenario: N/A(unmatched - new object)

Project: guava
 Class: IteratorsTest
 Method: testGet_empty
 Body: {
    List<String> list = newArrayList();
    Iterator<String> iterator = list.iterator();
    try {
      get(iterator, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    assertFalse(iterator.hasNext());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: IteratorsTest
 Method: testGet_negativeIndex
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterator<String> iterator = list.iterator();
    try {
      get(iterator, -1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: N/A - Scenario: iterator(outer1)

Project: guava
 Class: IteratorsTest
 Method: testCycleWhenRemoveIsNotSupported
 Body: {
    Iterable<String> iterable = asList("a", "b");
    Iterator<String> cycle = Iterators.cycle(iterable);
    cycle.next();
    try {
      cycle.remove();
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(unmatched) - Predicate: N/A - Scenario: cycle(matched - new object)

Project: guava
 Class: IteratorsTest
 Method: testGet_withDefault_negativeIndex
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    try {
      get(iterator, -1, "c");
      fail();
    } catch (IndexOutOfBoundsException expected) {
      // pass
    }
    assertTrue(iterator.hasNext());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: hasNext(outer) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: IteratorsTest
 Method: testForArrayEmpty
 Body: {
    String[] array = new String[0];
    Iterator<String> iterator = Iterators.forArray(array);
    assertFalse(iterator.hasNext());
    try {
      iterator.next();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: IteratorsTest
 Method: testCycleRemoveSameElementTwice
 Body: {
    Iterator<String> cycle = Iterators.cycle("a", "b");
    cycle.next();
    cycle.remove();
    try {
      cycle.remove();
      fail("no exception thrown");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(matched) - Predicate: N/A - Scenario: cycle(matched - new object)

Project: guava
 Class: IteratorsTest
 Method: testLimit
 Body: {
    List<String> list = newArrayList();
    try {
      Iterators.limit(list.iterator(), -1);
      fail("expected exception");
    } catch (IllegalArgumentException expected) {
    }

    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());
    assertFalse(Iterators.limit(list.iterator(), 1).hasNext());

    list.add("cool");
    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());
    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 1)));
    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 2)));

    list.add("pants");
    assertFalse(Iterators.limit(list.iterator(), 0).hasNext());
    assertEquals(ImmutableList.of("cool"), newArrayList(Iterators.limit(list.iterator(), 1)));
    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 2)));
    assertEquals(list, newArrayList(Iterators.limit(list.iterator(), 3)));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: limit(oneMC) - Predicate: hasNext(outer) - Scenario: list(outer1)

Project: guava
 Class: IteratorsTest
 Method: testPoorlyBehavedTransform
 Body: {
    Iterator<String> input = asList("1", null, "3").iterator();
    Iterator<Integer> result =
        Iterators.transform(
            input,
            new Function<String, Integer>() {
              @Override
              public Integer apply(String from) {
                return Integer.valueOf(from);
              }
            });

    result.next();
    try {
      result.next();
      fail("Expected NFE");
    } catch (NumberFormatException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: N/A - Scenario: result(matched - new object)

Project: guava
 Class: IteratorsTest
 Method: testForEnumerationEmpty
 Body: {
    Enumeration<Integer> enumer = enumerate();
    Iterator<Integer> iter = Iterators.forEnumeration(enumer);

    assertFalse(iter.hasNext());
    try {
      iter.next();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: hasNext(outer) - Scenario: iter(outer1)

Project: guava
 Class: IteratorsTest
 Method: testAdvance_illegalArgument
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterator<String> iterator = list.iterator();
    try {
      advance(iterator, -1);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: advance(oneMC) - Predicate: N/A - Scenario: iterator(outer1)

Project: guava
 Class: IteratorsTest
 Method: testCycleRemoveWithoutNext
 Body: {
    Iterator<String> cycle = Iterators.cycle("a", "b");
    assertTrue(cycle.hasNext());
    try {
      cycle.remove();
      fail("no exception thrown");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: hasNext(outer) - Scenario: cycle(outer1)

Project: guava
 Class: IteratorsTest
 Method: testAsEnumerationEmpty
 Body: {
    Iterator<Integer> iter = Iterators.emptyIterator();
    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);

    assertFalse(enumer.hasMoreElements());
    try {
      enumer.nextElement();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: nextElement(oneMC) - Predicate: hasMoreElements(outer) - Scenario: enumer(outer1)

Project: guava
 Class: IteratorsTest
 Method: testAsEnumerationSingleton
 Body: {
    Iterator<Integer> iter = ImmutableList.of(1).iterator();
    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);

    assertTrue(enumer.hasMoreElements());
    assertTrue(enumer.hasMoreElements());
    assertEquals(1, (int) enumer.nextElement());
    assertFalse(enumer.hasMoreElements());
    try {
      enumer.nextElement();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: nextElement(oneMC) - Predicate: hasMoreElements(outer) - Scenario: enumer(outer1)

Project: guava
 Class: IteratorsTest
 Method: testForArrayOffset
 Body: {
    String[] array = {"foo", "bar", "cat", "dog"};
    Iterator<String> iterator = Iterators.forArray(array, 1, 2, 0);
    assertTrue(iterator.hasNext());
    assertEquals("bar", iterator.next());
    assertTrue(iterator.hasNext());
    assertEquals("cat", iterator.next());
    assertFalse(iterator.hasNext());
    try {
      Iterators.forArray(array, 2, 3, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: forArray(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: IteratorsTest
 Method: testGet_pastEnd
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    try {
      get(iterator, 5);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    assertFalse(iterator.hasNext());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: hasNext(outer) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: IteratorsTest
 Method: testGet_atSize
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    try {
      get(iterator, 2);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    assertFalse(iterator.hasNext());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: hasNext(outer) - Scenario: N/A(unmatched - new object)

Project: guava
 Class: IteratorsTest
 Method: testConsumingIterator_duelingIterators
 Body: {
    // Test data
    List<String> list = Lists.newArrayList("a", "b");

    // Test & Verify
    Iterator<String> i1 = Iterators.consumingIterator(list.iterator());
    Iterator<String> i2 = Iterators.consumingIterator(list.iterator());

    i1.next();
    try {
      i2.next();
      fail("Concurrent modification should throw an exception.");
    } catch (ConcurrentModificationException cme) {
      // Pass
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: N/A - Scenario: i2(matched - new object)

Project: guava
 Class: IteratorsTest
 Method: testCycleNoSuchElementException
 Body: {
    Iterable<String> iterable = Lists.newArrayList("a");
    Iterator<String> cycle = Iterators.cycle(iterable);
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    cycle.remove();
    assertFalse(cycle.hasNext());
    try {
      cycle.next();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(unmatched) - Predicate: hasNext(outer) - Scenario: cycle(matched - new object)

Project: guava
 Class: IteratorsTest
 Method: testFind_notPresent
 Body: {
    Iterable<String> list = Lists.newArrayList("cool", "pants");
    Iterator<String> iterator = list.iterator();
    try {
      Iterators.find(iterator, Predicates.alwaysFalse());
      fail();
    } catch (NoSuchElementException e) {
    }
    assertFalse(iterator.hasNext());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: find(oneMC) - Predicate: hasNext(outer) - Scenario: iterator(outer1)

Project: guava
 Class: MapsTest
 Method: testSubMap_unnaturalOrdering
 Body: {
    ImmutableSortedMap<Integer, Integer> map =
        ImmutableSortedMap.<Integer, Integer>reverseOrder()
            .put(2, 0)
            .put(4, 0)
            .put(6, 0)
            .put(8, 0)
            .put(10, 0)
            .build();

    try {
      Maps.subMap(map, Range.closed(4, 8));
      fail("IllegalArgumentException expected");
    } catch (IllegalArgumentException expected) {
    }

    // These results are all incorrect, but there's no way (short of iterating over the result)
    // to verify that with an arbitrary ordering or comparator.
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0), Maps.subMap(map, Range.atLeast(4)));
    assertEquals(ImmutableSortedMap.of(8, 0, 10, 0), Maps.subMap(map, Range.atMost(8)));
    assertEquals(
        ImmutableSortedMap.of(2, 0, 4, 0, 6, 0, 8, 0, 10, 0),
        Maps.subMap(map, Range.<Integer>all()));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: subMap(oneMC) - Predicate: of(outer) - Scenario: map(outer1)

Project: guava
 Class: MapsTest
 Method: testImmutableEntryNull
 Body: {
    Entry<String, Integer> e = Maps.immutableEntry((String) null, (Integer) null);
    assertNull(e.getKey());
    assertNull(e.getValue());
    try {
      e.setValue(null);
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    assertEquals("null=null", e.toString());
    assertEquals(0, e.hashCode());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(oneMC) - Predicate: getKey(outer) - Scenario: e(outer1)

Project: guava
 Class: MapsTest
 Method: testFromPropertiesNullKey
 Body: {
    Properties properties =
        new Properties() {
          @Override
          public Enumeration<?> propertyNames() {
            return Iterators.asEnumeration(Arrays.asList(null, "first", "second").iterator());
          }
        };
    properties.setProperty("first", "true");
    properties.setProperty("second", "null");

    try {
      Maps.fromProperties(properties);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: fromProperties(unmatched) - Predicate: N/A - Scenario: Maps(unmatched - new object)

Project: guava
 Class: MapsTest
 Method: testAsConverter_noMapping
 Body: {
    ImmutableBiMap<String, Integer> biMap =
        ImmutableBiMap.of(
            "one", 1,
            "two", 2);
    Converter<String, Integer> converter = Maps.asConverter(biMap);
    try {
      converter.convert("three");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: convert(oneMC) - Predicate: N/A - Scenario: converter(outer1)

Project: guava
 Class: MapsTest
 Method: testImmutableEntry
 Body: {
    Entry<String, Integer> e = Maps.immutableEntry("foo", 1);
    assertEquals("foo", e.getKey());
    assertEquals(1, (int) e.getValue());
    try {
      e.setValue(2);
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    assertEquals("foo=1", e.toString());
    assertEquals(101575, e.hashCode());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(oneMC) - Predicate: getKey(outer) - Scenario: e(outer1)

Project: guava
 Class: MapsTest
 Method: testAsConverter_withNullMapping
 Body: {
    BiMap<String, Integer> biMap = HashBiMap.create();
    biMap.put("one", 1);
    biMap.put("two", 2);
    biMap.put("three", null);
    try {
      Maps.asConverter(biMap).convert("three");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: convert(unmatched) - Predicate: N/A - Scenario: Maps.asConverter(biMap)(unmatched - new object)

Project: guava
 Class: MapsTest
 Method: testAsConverter_isAView
 Body: {
    BiMap<String, Integer> biMap = HashBiMap.create();
    biMap.put("one", 1);
    biMap.put("two", 2);
    Converter<String, Integer> converter = Maps.asConverter(biMap);

    assertSame(1, converter.convert("one"));
    assertSame(2, converter.convert("two"));
    try {
      converter.convert("three");
      fail();
    } catch (IllegalArgumentException expected) {
    }

    biMap.put("three", 3);

    assertSame(1, converter.convert("one"));
    assertSame(2, converter.convert("two"));
    assertSame(3, converter.convert("three"));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: convert(unmatched) - Predicate: convert(outer) - Scenario: converter(matched - new object)

Project: guava
 Class: SettableFutureTest
 Method: testSetFuture_genericsHierarchy
 Body: {
    SettableFuture<Foo> future = SettableFuture.create();
    SettableFuture<FooChild> nested = SettableFuture.create();
    assertTrue(future.setFuture(nested));
    // Later attempts to set the future should return false.
    assertFalse(future.set(new Foo()));
    assertFalse(future.setException(new Exception("bar")));
    assertFalse(future.setFuture(SettableFuture.<Foo>create()));
    // Check that the future has been set properly.
    assertFalse(future.isDone());
    assertFalse(future.isCancelled());
    try {
      future.get(0, TimeUnit.MILLISECONDS);
      fail("Expected TimeoutException");
    } catch (TimeoutException expected) {
      /* expected */
    }
    FooChild value = new FooChild();
    nested.set(value);
    assertTrue(future.isDone());
    assertFalse(future.isCancelled());
    assertSame(value, future.get());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: setFuture(outer) - Scenario: nested(outer1)

Project: guava
 Class: SettableFutureTest
 Method: testSetFuture
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    SettableFuture<String> nested = SettableFuture.create();
    assertTrue(future.setFuture(nested));
    // Later attempts to set the future should return false.
    assertFalse(future.set("x"));
    assertFalse(future.setException(new Exception("bar")));
    assertFalse(future.setFuture(SettableFuture.<String>create()));
    // Check that the future has been set properly.
    assertFalse(future.isDone());
    assertFalse(future.isCancelled());
    try {
      future.get(0, TimeUnit.MILLISECONDS);
      fail("Expected TimeoutException");
    } catch (TimeoutException expected) {
      /* expected */
    }
    nested.set("foo");
    assertTrue(future.isDone());
    assertFalse(future.isCancelled());
    assertEquals("foo", future.get());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: setFuture(outer) - Scenario: nested(outer1)

Project: guava
 Class: SettableFutureTest
 Method: testCancel_innerCancelsAsync
 Body: {
    SettableFuture<Object> async = SettableFuture.create();
    SettableFuture<Object> inner = SettableFuture.create();
    async.setFuture(inner);
    inner.cancel(true);
    assertTrue(async.isCancelled());
    try {
      async.get();
      fail("Expected CancellationException");
    } catch (CancellationException expected) {
      /* expected */
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: isCancelled(outer) - Scenario: async(unmatched - new object)

Project: guava
 Class: SettableFutureTest
 Method: testCancel_resultCancelsInner_interrupted
 Body: {
    SettableFuture<Object> async = SettableFuture.create();
    SettableFuture<Object> inner = SettableFuture.create();
    async.setFuture(inner);
    async.cancel(true);
    assertTrue(inner.isCancelled());
    assertTrue(inner.wasInterrupted());
    try {
      inner.get();
      fail("Expected CancellationException");
    } catch (CancellationException expected) {
      /* expected */
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: isCancelled(outer) - Scenario: inner(matched - new object)

Project: guava
 Class: SettableFutureTest
 Method: testSetException
 Body: {
    SettableFuture<Object> future = SettableFuture.create();
    Exception e = new Exception("foobarbaz");
    assertTrue(future.setException(e));
    // Later attempts to set the future should return false.
    assertFalse(future.set(23));
    assertFalse(future.setException(new Exception("quux")));
    assertFalse(future.setFuture(SettableFuture.create()));
    // Check that the future has been set properly.
    assertTrue(future.isDone());
    assertFalse(future.isCancelled());
    try {
      future.get();
      fail("Expected ExecutionException");
    } catch (ExecutionException ee) {
      assertSame(e, ee.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(unmatched) - Scenario: e(outer1)

Project: guava
 Class: SettableFutureTest
 Method: testCancel_resultCancelsInner
 Body: {
    SettableFuture<Object> async = SettableFuture.create();
    SettableFuture<Object> inner = SettableFuture.create();
    async.setFuture(inner);
    async.cancel(false);
    assertTrue(inner.isCancelled());
    assertFalse(inner.wasInterrupted());
    try {
      inner.get();
      fail("Expected CancellationException");
    } catch (CancellationException expected) {
      /* expected */
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: isCancelled(outer) - Scenario: inner(matched - new object)

Project: guava
 Class: CharSinkTest
 Method: testClosesOnErrors_whenWriteThrows
 Body: {
    TestCharSink failSink = new TestCharSink(WRITE_THROWS);
    try {
      new TestCharSource(STRING).copyTo(failSink);
      fail();
    } catch (IOException expected) {
    }
    assertTrue(failSink.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: failSink(outer1)

Project: guava
 Class: CharSinkTest
 Method: testClosesOnErrors_whenWritingFromReaderThatThrows
 Body: {
    TestCharSink okSink = new TestCharSink();
    try {
      okSink.writeFrom(new TestReader(READ_THROWS));
      fail();
    } catch (IOException expected) {
    }
    assertTrue(okSink.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: writeFrom(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: okSink(outer1)

Project: guava
 Class: AbstractIteratorTest
 Method: testCantRemove
 Body: {
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          boolean haveBeenCalled;

          @Override
          public Integer computeNext() {
            if (haveBeenCalled) {
              endOfData();
            }
            haveBeenCalled = true;
            return 0;
          }
        };

    assertEquals(0, (int) iter.next());

    try {
      iter.remove();
      fail("No exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: remove(oneMC) - Predicate: N/A(outer) - Scenario: iter(outer1)

Project: guava
 Class: AbstractIteratorTest
 Method: testDefaultBehaviorOfNextAndHasNext
 Body: {

    // This sample AbstractIterator returns 0 on the first call, 1 on the
    // second, then signals that it's reached the end of the data
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          private int rep;

          @Override
          public Integer computeNext() {
            switch (rep++) {
              case 0:
                return 0;
              case 1:
                return 1;
              case 2:
                return endOfData();
              default:
                fail("Should not have been invoked again");
                return null;
            }
          }
        };

    assertTrue(iter.hasNext());
    assertEquals(0, (int) iter.next());

    // verify idempotence of hasNext()
    assertTrue(iter.hasNext());
    assertTrue(iter.hasNext());
    assertTrue(iter.hasNext());
    assertEquals(1, (int) iter.next());

    assertFalse(iter.hasNext());

    // Make sure computeNext() doesn't get invoked again
    assertFalse(iter.hasNext());

    try {
      iter.next();
      fail("no exception thrown");
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(oneMC) - Predicate: hasNext(outer) - Scenario: iter(outer1)

Project: guava
 Class: AbstractIteratorTest
 Method: testException
 Body: {
    final SomeUncheckedException exception = new SomeUncheckedException();
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          @Override
          public Integer computeNext() {
            throw exception;
          }
        };

    // It should pass through untouched
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (SomeUncheckedException e) {
      assertSame(exception, e);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: hasNext(oneMC) - Predicate: N/A(inner) - Scenario: iter(outer1)

Project: guava
 Class: ListenableFutureTaskTest
 Method: testListenerCalledOnException
 Body: {
    throwException = true;

    // Start up the task and unblock the latch to finish the task.
    exec.execute(task);
    runLatch.await();
    taskLatch.countDown();

    try {
      task.get(5, TimeUnit.SECONDS);
      fail("Should have propagated the failure.");
    } catch (ExecutionException e) {
      assertEquals(IllegalStateException.class, e.getCause().getClass());
    }

    assertTrue(listenerLatch.await(5, TimeUnit.SECONDS));
    assertTrue(task.isDone());
    assertFalse(task.isCancelled());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: getClass(unmatched) - Scenario: task(unmatched - actionReference)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredEntriesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.put("cow", 7);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredKeysIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredValuesIllegalPut
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.put("yyy", 3);
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: put(matched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredValuesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      unfiltered.put("b", 4);
      unfiltered.put("c", 5);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 4, "zzz", 5, "b", 6));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredEntriesIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5), filtered);

      filtered.put("chicken", 7);
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);

      try {
        filtered.putAll(ImmutableMap.of("sheep", 5, "cow", 7));
        fail();
      } catch (IllegalArgumentException expected) {
      }
      assertEquals(ImmutableMap.of("cat", 3, "horse", 5, "chicken", 7), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredValuesIllegalSetValue
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      filtered.put("a", 2);
      filtered.put("b", 4);
      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);

      Entry<String, Integer> entry = filtered.entrySet().iterator().next();
      try {
        entry.setValue(5);
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 2, "b", 4), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: setValue(unmatched) - Predicate: of(outer) - Scenario: entry(matched - new object)

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredKeysIllegalPutAll
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      filtered.put("a", 1);
      filtered.put("b", 2);
      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);

      try {
        filtered.putAll(ImmutableMap.of("c", 3, "zzz", 4, "b", 5));
        fail();
      } catch (IllegalArgumentException expected) {
      }

      assertEquals(ImmutableMap.of("a", 1, "b", 2), filtered);
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: putAll(unmatched) - Predicate: of(outer) - Scenario: filtered(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedGraphTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = graph.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedGraphTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = graph.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(graph.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedGraphTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<EndpointPair<Integer>> incidentEdges = graph.incidentEdges(N1);
    try {
      incidentEdges.add(EndpointPair.ordered(N1, N2));
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(incidentEdges).containsExactlyElementsIn(graph.incidentEdges(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: incidentEdges(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedGraphTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = graph.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_SET);
    } catch (UnsupportedOperationException e) {
      putEdge(N1, N2);
      assertThat(successors).containsExactlyElementsIn(graph.successors(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: successors(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testCopyOfNullKey
 Body: {
    HashMultimap<String, Integer> input = HashMultimap.create();
    input.put(null, 1);
    try {
      ImmutableSetMultimap.copyOf(input);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyOf(unmatched) - Predicate: N/A - Scenario: ImmutableSetMultimap(unmatched - new object)

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testCopyOfNullValue
 Body: {
    HashMultimap<String, Integer> input = HashMultimap.create();
    input.putAll("foo", Arrays.asList(1, null, 3));
    try {
      ImmutableSetMultimap.copyOf(input);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyOf(unmatched) - Predicate: N/A - Scenario: ImmutableSetMultimap(unmatched - new object)

Project: guava
 Class: ArrayTableTest
 Method: testCreateEmptyRowsXColumns
 Body: {
    ArrayTable<String, String, Character> table =
        ArrayTable.create(Arrays.<String>asList(), Arrays.<String>asList());
    assertThat(table).isEmpty();
    assertThat(table).hasSize(0);
    assertThat(table.columnKeyList()).isEmpty();
    assertThat(table.rowKeyList()).isEmpty();
    assertThat(table.columnKeySet()).isEmpty();
    assertThat(table.rowKeySet()).isEmpty();
    try {
      table.at(0, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: at(oneMC) - Predicate: N/A(outer) - Scenario: table(outer1)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(successors).containsExactlyElementsIn(network.successors(N1));
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: successors(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: edgesConnecting_checkReturnedSetMutability
 Body: {
    addNode(N1);
    addNode(N2);
    Set<String> edgesConnecting = network.edgesConnecting(N1, N2);
    try {
      edgesConnecting.add(E23);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: edgesConnecting(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: successors_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> successors = network.successors(N1);
    try {
      successors.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.successors(N1)).containsExactlyElementsIn(successors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: successors(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: inEdges_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<String> inEdges = network.inEdges(N2);
    try {
      inEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.inEdges(N2)).containsExactlyElementsIn(inEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: inEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: outEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> outEdges = network.outEdges(N1);
    try {
      outEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.outEdges(N1)).containsExactlyElementsIn(outEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: outEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: addEdge_parallelSelfLoopEdge
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
      fail("Adding a parallel self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addEdge(matched) - Predicate: N/A(inner) - Scenario: N/A

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: adjacentNodes_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<Integer> adjacentNodes = network.adjacentNodes(N1);
    try {
      adjacentNodes.add(N2);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: adjacentNodes(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: incidentEdges_checkReturnedSetMutability
 Body: {
    addNode(N1);
    Set<String> incidentEdges = network.incidentEdges(N1);
    try {
      incidentEdges.add(E12);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: incidentEdges(matched - new object)

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: predecessors_checkReturnedSetMutability
 Body: {
    addNode(N2);
    Set<Integer> predecessors = network.predecessors(N2);
    try {
      predecessors.add(N1);
      fail(ERROR_MODIFIABLE_COLLECTION);
    } catch (UnsupportedOperationException e) {
      addEdge(N1, N2, E12);
      assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(unmatched) - Predicate: N/A(inner) - Scenario: predecessors(matched - new object)

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testFailOnExceptionFromRun
 Body: {
    TestService service = new TestService();
    service.runException = new Exception();
    service.startAsync().awaitRunning();
    service.runFirstBarrier.await();
    service.runSecondBarrier.await();
    try {
      future.get();
      fail();
    } catch (CancellationException expected) {
    }
    // An execution exception holds a runtime exception (from throwables.propogate) that holds our
    // original exception.
    assertEquals(service.runException, service.failureCause());
    assertEquals(Service.State.FAILED, service.state());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(unmatched) - Predicate: failureCause(outer) - Scenario: future(unmatched - new object)

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testFailOnExceptionFromShutDown
 Body: {
    TestService service = new TestService();
    service.shutDownException = new Exception();
    service.startAsync().awaitRunning();
    service.runFirstBarrier.await();
    service.stopAsync();
    service.runSecondBarrier.await();
    try {
      service.awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(service.shutDownException, e.getCause());
    }
    assertEquals(Service.State.FAILED, service.state());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: getCause(unmatched) - Scenario: service(matched - new object)

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testDefaultExecutorIsShutdownWhenServiceFails
 Body: {
    final AtomicReference<ScheduledExecutorService> executor = Atomics.newReference();
    AbstractScheduledService service =
        new AbstractScheduledService() {
          @Override
          protected void startUp() throws Exception {
            throw new Exception("Failed");
          }

          @Override
          protected void runOneIteration() throws Exception {}

          @Override
          protected ScheduledExecutorService executor() {
            executor.set(super.executor());
            return executor.get();
          }

          @Override
          protected Scheduler scheduler() {
            return newFixedDelaySchedule(0, 1, TimeUnit.MILLISECONDS);
          }
        };

    try {
      service.startAsync().awaitRunning();
      fail("Expected service to fail during startup");
    } catch (IllegalStateException expected) {
    }

    assertTrue(executor.get().awaitTermination(100, TimeUnit.MILLISECONDS));
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(oneMC) - Predicate: awaitTermination(outer) - Scenario: service(outer1)

Project: guava
 Class: CallablesTest
 Method: testAsAsyncCallable_exception
 Body: {
    final Exception expected = new IllegalArgumentException();
    Callable<String> callable =
        new Callable<String>() {
          @Override
          public String call() throws Exception {
            throw expected;
          }
        };

    AsyncCallable<String> asyncCallable =
        Callables.asAsyncCallable(callable, MoreExecutors.newDirectExecutorService());

    ListenableFuture<String> future = asyncCallable.call();
    try {
      future.get();
      fail("Expected exception to be thrown");
    } catch (ExecutionException e) {
      assertSame(expected, e.getCause());
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: get(oneMC) - Predicate: getCause(inner) - Scenario: future(outer1)

Project: guava
 Class: CallablesTest
 Method: testRenaming_exceptionalReturn
 Body: {
    String oldName = Thread.currentThread().getName();
    final Supplier<String> newName = Suppliers.ofInstance("MyCrazyThreadName");
    class MyException extends Exception {}
    Callable<Void> callable =
        new Callable<Void>() {
          @Override
          public Void call() throws Exception {
            assertEquals(Thread.currentThread().getName(), newName.get());
            throw new MyException();
          }
        };
    try {
      Callables.threadRenaming(callable, newName).call();
      fail();
    } catch (MyException expected) {
    }
    assertEquals(oldName, Thread.currentThread().getName());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: call(oneMC) - Predicate: getName(outer) - Scenario: callable(outer1)

Project: guava
 Class: AbstractIdleServiceTest
 Method: testStart_failed
 Body: {
    final Exception exception = new Exception("deliberate");
    TestService service =
        new TestService() {
          @Override
          protected void startUp() throws Exception {
            super.startUp();
            throw exception;
          }
        };
    assertEquals(0, service.startUpCalled);
    try {
      service.startAsync().awaitRunning();
      fail();
    } catch (RuntimeException e) {
      assertSame(exception, e.getCause());
    }
    assertEquals(1, service.startUpCalled);
    assertEquals(Service.State.FAILED, service.state());
    assertThat(service.transitionStates).containsExactly(Service.State.STARTING);
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitRunning(oneMC) - Predicate: getCause(unmatched) - Scenario: service(outer1)

Project: guava
 Class: AbstractIdleServiceTest
 Method: testStop_failed
 Body: {
    final Exception exception = new Exception("deliberate");
    TestService service =
        new TestService() {
          @Override
          protected void shutDown() throws Exception {
            super.shutDown();
            throw exception;
          }
        };
    service.startAsync().awaitRunning();
    assertEquals(1, service.startUpCalled);
    assertEquals(0, service.shutDownCalled);
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (RuntimeException e) {
      assertSame(exception, e.getCause());
    }
    assertEquals(1, service.startUpCalled);
    assertEquals(1, service.shutDownCalled);
    assertEquals(Service.State.FAILED, service.state());
    assertThat(service.transitionStates)
        .containsExactly(Service.State.STARTING, Service.State.STOPPING)
        .inOrder();
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: awaitTerminated(unmatched) - Predicate: getCause(unmatched) - Scenario: service.stopAsync()(unmatched - new object)

Project: guava
 Class: ByteSinkTest
 Method: testClosesOnErrors_whenWriteThrows
 Body: {
    TestByteSink failSink = new TestByteSink(WRITE_THROWS);
    try {
      new TestByteSource(new byte[10]).copyTo(failSink);
      fail();
    } catch (IOException expected) {
    }
    assertTrue(failSink.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: failSink(outer1)

Project: guava
 Class: ByteSinkTest
 Method: testClosesOnErrors_writingFromInputStreamThatThrows
 Body: {
    TestByteSink okSink = new TestByteSink();
    try {
      TestInputStream in = new TestInputStream(new ByteArrayInputStream(new byte[10]), READ_THROWS);
      okSink.writeFrom(in);
      fail();
    } catch (IOException expected) {
    }
    assertTrue(okSink.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: writeFrom(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: okSink(outer1)

Project: guava
 Class: ImmutableSortedSetTest
 Method: testOf_subSet
 Body: {
    SortedSet<String> set = of("e", "f", "b", "d", "c");
    assertTrue(set.subSet("c", "e") instanceof ImmutableSortedSet);
    assertThat(set.subSet("c", "e")).containsExactly("c", "d").inOrder();
    assertThat(set.subSet("a", "g")).containsExactly("b", "c", "d", "e", "f").inOrder();
    assertSame(of(), set.subSet("a", "b"));
    assertSame(of(), set.subSet("g", "h"));
    assertSame(of(), set.subSet("c", "c"));
    try {
      set.subSet("e", "c");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: subSet(oneMC) - Predicate: N/A(outer) - Scenario: set(outer1)

Project: guava
 Class: ImmutableSortedSetTest
 Method: testExplicit_subSet
 Body: {
    SortedSet<String> set =
        ImmutableSortedSet.orderedBy(STRING_LENGTH)
            .add("in", "the", "quick", "jumped", "over", "a")
            .build();
    assertTrue(set.subSet("the", "quick") instanceof ImmutableSortedSet);
    assertTrue(set.subSet("", "b") instanceof ImmutableSortedSet);
    assertThat(set.subSet("the", "quick")).containsExactly("the", "over").inOrder();
    assertThat(set.subSet("a", "california"))
        .containsExactly("a", "in", "the", "over", "quick", "jumped")
        .inOrder();
    assertTrue(set.subSet("", "b").isEmpty());
    assertTrue(set.subSet("vermont", "california").isEmpty());
    assertTrue(set.subSet("aaa", "zzz").isEmpty());
    try {
      set.subSet("quick", "the");
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: subSet(oneMC) - Predicate: N/A(outer) - Scenario: set(outer1)

Project: guava
 Class: ByteSourceTest
 Method: testClosesOnErrors_copyingToOutputStreamThatThrows
 Body: {
    TestByteSource okSource = new TestByteSource(bytes);
    try {
      OutputStream out = new TestOutputStream(ByteStreams.nullOutputStream(), WRITE_THROWS);
      okSource.copyTo(out);
      fail();
    } catch (IOException expected) {
    }
    assertTrue(okSource.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: okSource(outer1)

Project: guava
 Class: ByteSourceTest
 Method: testClosesOnErrors_whenReadThrows
 Body: {
    TestByteSource failSource = new TestByteSource(bytes, READ_THROWS);
    try {
      failSource.copyTo(new TestByteSink());
      fail();
    } catch (IOException expected) {
    }
    assertTrue(failSource.wasStreamClosed());
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: copyTo(oneMC) - Predicate: wasStreamClosed(outer) - Scenario: failSource(outer1)

Project: guava
 Class: SchedulerTest
 Method: testFixedDelayScheduleFarFuturePotentiallyOverflowingScheduleIsNeverReached
 Body: {
      TestAbstractScheduledCustomService service =
          new TestAbstractScheduledCustomService() {
            @Override
            protected Scheduler scheduler() {
              return newFixedDelaySchedule(Long.MAX_VALUE, Long.MAX_VALUE, SECONDS);
            }
          };
      service.startAsync().awaitRunning();
      try {
        service.firstBarrier.await(5, SECONDS);
        fail();
      } catch (TimeoutException expected) {
      }
      assertEquals(0, service.numIterations.get());
      service.stopAsync();
      service.awaitTerminated();
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: await(unmatched) - Predicate: get(outer) - Scenario: service.firstBarrier(unmatched - new object)

Project: guava
 Class: SchedulerTest
 Method: testCustomSchedulerFarFuturePotentiallyOverflowingScheduleIsNeverReached
 Body: {
      TestAbstractScheduledCustomService service =
          new TestAbstractScheduledCustomService() {
            @Override
            protected Scheduler scheduler() {
              return new AbstractScheduledService.CustomScheduler() {
                @Override
                protected Schedule getNextSchedule() throws Exception {
                  return new Schedule(Long.MAX_VALUE, SECONDS);
                }
              };
            }
          };
      service.startAsync().awaitRunning();
      try {
        service.firstBarrier.await(5, SECONDS);
        fail();
      } catch (TimeoutException expected) {
      }
      assertEquals(0, service.numIterations.get());
      service.stopAsync();
      service.awaitTerminated();
    }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: await(unmatched) - Predicate: get(outer) - Scenario: service.firstBarrier(unmatched - new object)

Project: guava
 Class: ListAddAllAtIndexTester
 Method: testAddAllAtIndex_nullUnsupported
 Body: {
    List<E> containsNull = singletonList(null);
    try {
      getList().addAll(0, containsNull);
      fail("addAll(n, containsNull) should throw");
    } catch (NullPointerException expected) {
    }
    expectUnchanged();
    expectNullMissingWhenNullUnsupported(
        "Should not contain null after unsupported addAll(n, containsNull)");
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: addAll(oneMC) - Predicate: N/A - Scenario: containsNull(outer1)

Project: guava
 Class: LittleEndianDataInputStreamTest
 Method: testReadUnsignedShort_eof
 Body: {
    byte[] buf = {23};
    DataInput in = new LittleEndianDataInputStream(new ByteArrayInputStream(buf));
    try {
      in.readUnsignedShort();
      fail();
    } catch (EOFException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: readUnsignedShort(oneMC) - Predicate: N/A - Scenario: in(outer1)

Project: guava
 Class: SubscriberTest
 Method: testInvokeSubscriberMethod_errorPassthrough
 Body: {
    Method method = getTestSubscriberMethod("errorThrowingMethod");
    Subscriber subscriber = Subscriber.create(bus, this, method);

    try {
      subscriber.invokeSubscriberMethod(FIXTURE_ARGUMENT);
      fail("Subscribers whose methods throw Errors must rethrow them");
    } catch (JudgmentError expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: invokeSubscriberMethod(oneMC) - Predicate: N/A - Scenario: subscriber(outer1)

Project: guava
 Class: SubscriberTest
 Method: testInvokeSubscriberMethod_exceptionWrapping
 Body: {
    Method method = getTestSubscriberMethod("exceptionThrowingMethod");
    Subscriber subscriber = Subscriber.create(bus, this, method);

    try {
      subscriber.invokeSubscriberMethod(FIXTURE_ARGUMENT);
      fail("Subscribers whose methods throw must throw InvocationTargetException");
    } catch (InvocationTargetException expected) {
      assertThat(expected.getCause()).isInstanceOf(IntentionalException.class);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: invokeSubscriberMethod(oneMC) - Predicate: N/A(inner) - Scenario: subscriber(outer1)

Project: guava
 Class: ThrowablesTest
 Method: testGetCausalChain
 Body: {
    SomeUncheckedException sue = new SomeUncheckedException();
    IllegalArgumentException iae = new IllegalArgumentException(sue);
    RuntimeException re = new RuntimeException(iae);
    IllegalStateException ex = new IllegalStateException(re);

    assertEquals(asList(ex, re, iae, sue), Throwables.getCausalChain(ex));
    assertSame(sue, Iterables.getOnlyElement(Throwables.getCausalChain(sue)));

    List<Throwable> causes = Throwables.getCausalChain(ex);
    try {
      causes.add(new RuntimeException());
      fail("List should be unmodifiable");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: add(oneMC) - Predicate: asList(outer) - Scenario: causes(outer1)

Project: guava
 Class: ThrowablesTest
 Method: testGetCasualChainLoop
 Body: {
    Exception cause = new Exception();
    Exception exception = new Exception(cause);
    cause.initCause(exception);
    try {
      Throwables.getCausalChain(cause);
      fail("Should have throw IAE");
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasCauseThat().isSameAs(cause);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getCausalChain(unmatched) - Predicate: N/A(inner) - Scenario: Throwables(unmatched - new object)

Project: guava
 Class: ThrowablesTest
 Method: testGetRootCause_Loop
 Body: {
    Exception cause = new Exception();
    Exception exception = new Exception(cause);
    cause.initCause(exception);
    try {
      Throwables.getRootCause(cause);
      fail("Should have throw IAE");
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasCauseThat().isSameAs(cause);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getRootCause(unmatched) - Predicate: N/A(inner) - Scenario: Throwables(unmatched - new object)

Project: guava
 Class: ThrowablesTest
 Method: testGetCauseAs
 Body: {
    SomeCheckedException cause = new SomeCheckedException();
    SomeChainingException thrown = new SomeChainingException(cause);

    assertThat(thrown.getCause()).isSameAs(cause);
    assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause);
    assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);

    try {
      Throwables.getCauseAs(thrown, IllegalStateException.class);
      fail("Should have thrown CCE");
    } catch (ClassCastException expected) {
      assertThat(expected.getCause()).isSameAs(thrown);
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: getCauseAs(oneMC) - Predicate: N/A(matched) - Scenario: thrown(outer1)

Project: guava
 Class: FluentIterableTest
 Method: testConcatNullPointerException
 Body: {
    List<Integer> list1 = newArrayList(1);
    List<Integer> list2 = newArrayList(4);

    try {
      FluentIterable.concat(list1, null, list2);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: concat(oneMC) - Predicate: N/A - Scenario: list2(outer1)

Project: guava
 Class: FluentIterableTest
 Method: testTransformWith_poorlyBehavedTransform
 Body: {
    List<String> input = asList("1", null, "3");
    Iterable<Integer> iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());

    Iterator<Integer> resultIterator = iterable.iterator();
    resultIterator.next();

    try {
      resultIterator.next();
      fail("Transforming null to int should throw NumberFormatException");
    } catch (NumberFormatException expected) {
    }
  }
 Pattern Name: TryCatchPattern_AnyLOC_EmbeddedAssert - Action: next(matched) - Predicate: N/A - Scenario: resultIterator(matched - new object)

