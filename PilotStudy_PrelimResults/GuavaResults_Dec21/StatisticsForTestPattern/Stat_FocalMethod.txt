Project: guava
 Class: LocalCacheTest
 Method: testCompute
 Body: {
    CountingLoader loader = new CountingLoader();
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
    assertEquals(0, loader.getCount());

    Object key = new Object();
    Object value = map.get(key, loader);
    assertEquals(1, loader.getCount());
    assertEquals(value, map.get(key, loader));
    assertEquals(1, loader.getCount());
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: LocalCacheTest
 Method: testComputeExpiredEntry
 Body: {
    CacheBuilder<Object, Object> builder =
        createCacheBuilder().expireAfterWrite(1, TimeUnit.NANOSECONDS);
    CountingLoader loader = new CountingLoader();
    LocalCache<Object, Object> map = makeLocalCache(builder);
    assertEquals(0, loader.getCount());

    Object key = new Object();
    Object one = map.get(key, loader);
    assertEquals(1, loader.getCount());

    Object two = map.get(key, loader);
    assertNotSame(one, two);
    assertEquals(2, loader.getCount());
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: SetsTest
 Method: testSubSet_halfBoundedRange
 Body: {
    ImmutableSortedSet<Integer> set = ImmutableSortedSet.of(2, 4, 6, 8, 10);
    ImmutableSortedSet<Integer> empty = ImmutableSortedSet.of();

    assertEquals(set, Sets.subSet(set, Range.atLeast(0)));
    assertEquals(ImmutableSortedSet.of(4, 6, 8, 10), Sets.subSet(set, Range.atLeast(4)));
    assertEquals(ImmutableSortedSet.of(8, 10), Sets.subSet(set, Range.atLeast(7)));
    assertEquals(empty, Sets.subSet(set, Range.atLeast(20)));

    assertEquals(set, Sets.subSet(set, Range.greaterThan(0)));
    assertEquals(ImmutableSortedSet.of(6, 8, 10), Sets.subSet(set, Range.greaterThan(4)));
    assertEquals(ImmutableSortedSet.of(8, 10), Sets.subSet(set, Range.greaterThan(7)));
    assertEquals(empty, Sets.subSet(set, Range.greaterThan(20)));

    assertEquals(empty, Sets.subSet(set, Range.lessThan(0)));
    assertEquals(ImmutableSortedSet.of(2), Sets.subSet(set, Range.lessThan(4)));
    assertEquals(ImmutableSortedSet.of(2, 4, 6), Sets.subSet(set, Range.lessThan(7)));
    assertEquals(set, Sets.subSet(set, Range.lessThan(20)));

    assertEquals(empty, Sets.subSet(set, Range.atMost(0)));
    assertEquals(ImmutableSortedSet.of(2, 4), Sets.subSet(set, Range.atMost(4)));
    assertEquals(ImmutableSortedSet.of(2, 4, 6), Sets.subSet(set, Range.atMost(7)));
    assertEquals(set, Sets.subSet(set, Range.atMost(20)));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: empty

Project: guava
 Class: SetsTest
 Method: testCartesianProduct_contains
 Body: {
    Set<List<Integer>> actual = Sets.cartesianProduct(set(1, 2), set(3, 4));
    assertTrue(actual.contains(list(1, 3)));
    assertTrue(actual.contains(list(1, 4)));
    assertTrue(actual.contains(list(2, 3)));
    assertTrue(actual.contains(list(2, 4)));
    assertFalse(actual.contains(list(3, 1)));
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: actual

Project: guava
 Class: SetsTest
 Method: testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero
 Body: {
    Set<Object> sumToEighthMaxIntElements =
        newHashSet(objectWithHashCode(1 << 29), objectWithHashCode(0));
    assertPowerSetHashCode(1 << 30, sumToEighthMaxIntElements);

    Set<Object> sumToQuarterMaxIntElements =
        newHashSet(objectWithHashCode(1 << 30), objectWithHashCode(0));
    assertPowerSetHashCode(1 << 31, sumToQuarterMaxIntElements);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: sumToQuarterMaxIntElements

Project: guava
 Class: SetsTest
 Method: testSubSet_boundedRange
 Body: {
    ImmutableSortedSet<Integer> set = ImmutableSortedSet.of(2, 4, 6, 8, 10);
    ImmutableSortedSet<Integer> empty = ImmutableSortedSet.of();

    assertEquals(set, Sets.subSet(set, Range.closed(0, 12)));
    assertEquals(ImmutableSortedSet.of(2, 4), Sets.subSet(set, Range.closed(0, 4)));
    assertEquals(ImmutableSortedSet.of(2, 4, 6), Sets.subSet(set, Range.closed(2, 6)));
    assertEquals(ImmutableSortedSet.of(4, 6), Sets.subSet(set, Range.closed(3, 7)));
    assertEquals(empty, Sets.subSet(set, Range.closed(20, 30)));

    assertEquals(set, Sets.subSet(set, Range.open(0, 12)));
    assertEquals(ImmutableSortedSet.of(2), Sets.subSet(set, Range.open(0, 4)));
    assertEquals(ImmutableSortedSet.of(4), Sets.subSet(set, Range.open(2, 6)));
    assertEquals(ImmutableSortedSet.of(4, 6), Sets.subSet(set, Range.open(3, 7)));
    assertEquals(empty, Sets.subSet(set, Range.open(20, 30)));

    assertEquals(set, Sets.subSet(set, Range.openClosed(0, 12)));
    assertEquals(ImmutableSortedSet.of(2, 4), Sets.subSet(set, Range.openClosed(0, 4)));
    assertEquals(ImmutableSortedSet.of(4, 6), Sets.subSet(set, Range.openClosed(2, 6)));
    assertEquals(ImmutableSortedSet.of(4, 6), Sets.subSet(set, Range.openClosed(3, 7)));
    assertEquals(empty, Sets.subSet(set, Range.openClosed(20, 30)));

    assertEquals(set, Sets.subSet(set, Range.closedOpen(0, 12)));
    assertEquals(ImmutableSortedSet.of(2), Sets.subSet(set, Range.closedOpen(0, 4)));
    assertEquals(ImmutableSortedSet.of(2, 4), Sets.subSet(set, Range.closedOpen(2, 6)));
    assertEquals(ImmutableSortedSet.of(4, 6), Sets.subSet(set, Range.closedOpen(3, 7)));
    assertEquals(empty, Sets.subSet(set, Range.closedOpen(20, 30)));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: empty

Project: guava
 Class: HtmlEscapersTest
 Method: testHtmlEscaper
 Body: {
    assertEquals("xxx", htmlEscaper().escape("xxx"));
    assertEquals("&quot;test&quot;", htmlEscaper().escape("\"test\""));
    assertEquals("&#39;test&#39;", htmlEscaper().escape("\'test'"));
    assertEquals("test &amp; test &amp; test", htmlEscaper().escape("test & test & test"));
    assertEquals("test &lt;&lt; 1", htmlEscaper().escape("test << 1"));
    assertEquals("test &gt;&gt; 1", htmlEscaper().escape("test >> 1"));
    assertEquals("&lt;tab&gt;", htmlEscaper().escape("<tab>"));

    // Test simple escape of '&'.
    assertEquals("foo&amp;bar", htmlEscaper().escape("foo&bar"));

    // If the string contains no escapes, it should return the arg.
    // Note: assert<b>Same</b> for this implementation.
    String s = "blah blah farhvergnugen";
    assertSame(s, htmlEscaper().escape(s));

    // Tests escapes at begin and end of string.
    assertEquals("&lt;p&gt;", htmlEscaper().escape("<p>"));

    // Test all escapes.
    assertEquals("a&quot;b&lt;c&gt;d&amp;", htmlEscaper().escape("a\"b<c>d&"));

    // Test two escapes in a row.
    assertEquals("foo&amp;&amp;bar", htmlEscaper().escape("foo&&bar"));

    // Test many non-escaped characters.
    s =
        "!@#$%^*()_+=-/?\\|]}[{,.;:"
            + "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
            + "1234567890";
    assertSame(s, htmlEscaper().escape(s));
  }
 Pattern Name: FocalMethod_Match - Action: escape - Predicate: N/A - Scenario: s

Project: guava
 Class: NullPointerTesterTest
 Method: testDontAcceptIae
 Body: {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(ThrowsNpe.class);
    tester.testAllPublicStaticMethods(ThrowsUoe.class);
    try {
      tester.testAllPublicStaticMethods(ThrowsIae.class);
    } catch (AssertionFailedError expected) {
      return;
    }
    fail();
  }
 Pattern Name: FocalMethod_Match - Action: testAllPublicStaticMethods - Predicate: N/A - Scenario: tester

Project: guava
 Class: NullPointerTesterTest
 Method: testTwoArgNormalNullable
 Body: {
    Method method = TwoArg.class.getMethod("normalNullable", String.class, Integer.class);
    for (TwoArg.Action first : TwoArg.Action.values()) {
      for (TwoArg.Action second : TwoArg.Action.values()) {
        TwoArg bar = new TwoArg(first, second);
        if (first.equals(TwoArg.Action.THROW_A_NPE)) {
          verifyBarPass(method, bar); // only pass if 1st param throws NPE
        } else {
          verifyBarFail(method, bar);
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: equals - Predicate: N/A - Scenario: first

Project: guava
 Class: NullPointerTesterTest
 Method: testTwoArgNullableNormal
 Body: {
    Method method = TwoArg.class.getMethod("nullableNormal", String.class, Integer.class);
    for (TwoArg.Action first : TwoArg.Action.values()) {
      for (TwoArg.Action second : TwoArg.Action.values()) {
        TwoArg bar = new TwoArg(first, second);
        if (second.equals(TwoArg.Action.THROW_A_NPE)) {
          verifyBarPass(method, bar); // only pass if 2nd param throws NPE
        } else {
          verifyBarFail(method, bar);
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: first

Project: guava
 Class: NullPointerTesterTest
 Method: testTwoArgNormalNormal
 Body: {
    Method method = TwoArg.class.getMethod("normalNormal", String.class, Integer.class);
    for (TwoArg.Action first : TwoArg.Action.values()) {
      for (TwoArg.Action second : TwoArg.Action.values()) {
        TwoArg bar = new TwoArg(first, second);
        if (first.equals(TwoArg.Action.THROW_A_NPE) && second.equals(TwoArg.Action.THROW_A_NPE)) {
          verifyBarPass(method, bar); // require both params to throw NPE
        } else {
          verifyBarFail(method, bar);
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: equals - Predicate: N/A - Scenario: first

Project: guava
 Class: NullPointerTesterTest
 Method: testMessageOtherException
 Body: {
    Method method = OneArg.class.getMethod("staticOneArgThrowsOtherThanNpe", String.class);
    boolean foundProblem = false;
    try {
      new NullPointerTester().testMethodParameter(new OneArg(), method, 0);
    } catch (AssertionFailedError expected) {
      assertThat(expected.getMessage()).contains("index 0");
      assertThat(expected.getMessage()).contains("[null]");
      foundProblem = true;
    }
    assertTrue("Should report error when different exception is thrown", foundProblem);
  }
 Pattern Name: FocalMethod_Match - Action: testMethodParameter - Predicate: N/A - Scenario: method

Project: guava
 Class: NullPointerTesterTest
 Method: testMessageNoException
 Body: {
    Method method = OneArg.class.getMethod("staticOneArgShouldThrowNpeButDoesnt", String.class);
    boolean foundProblem = false;
    try {
      new NullPointerTester().testMethodParameter(new OneArg(), method, 0);
    } catch (AssertionFailedError expected) {
      assertThat(expected.getMessage()).contains("index 0");
      assertThat(expected.getMessage()).contains("[null]");
      foundProblem = true;
    }
    assertTrue("Should report error when no exception is thrown", foundProblem);
  }
 Pattern Name: FocalMethod_Match - Action: testMethodParameter - Predicate: N/A - Scenario: method

Project: guava
 Class: NullPointerTesterTest
 Method: testTwoArgNullableNullable
 Body: {
    Method method = TwoArg.class.getMethod("nullableNullable", String.class, Integer.class);
    for (TwoArg.Action first : TwoArg.Action.values()) {
      for (TwoArg.Action second : TwoArg.Action.values()) {
        TwoArg bar = new TwoArg(first, second);
        verifyBarPass(method, bar); // All args nullable:  anything goes!
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: first

Project: guava
 Class: NullPointerTesterTest
 Method: testInterfaceStaticMethod
 Body: {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicStaticMethods(InterfaceStaticMethodChecksNull.class);
    try {
      tester.testAllPublicStaticMethods(InterfaceStaticMethodFailsToCheckNull.class);
    } catch (AssertionError expected) {
      return;
    }
    fail();
  }
 Pattern Name: FocalMethod_Match - Action: testAllPublicStaticMethods - Predicate: N/A - Scenario: tester

Project: guava
 Class: NullPointerTesterTest
 Method: testStaticOneArgMethodsThatShouldFail
 Body: {
    for (String methodName : STATIC_ONE_ARG_METHODS_SHOULD_FAIL) {
      Method method = OneArg.class.getMethod(methodName, String.class);
      boolean foundProblem = false;
      try {
        new NullPointerTester().testMethodParameter(new OneArg(), method, 0);
      } catch (AssertionFailedError expected) {
        foundProblem = true;
      }
      assertTrue("Should report error in method " + methodName, foundProblem);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMethod - Predicate: N/A - Scenario: method

Project: guava
 Class: NullPointerTesterTest
 Method: testNonStaticOneArgMethodsThatShouldFail
 Body: {
    OneArg foo = new OneArg();
    for (String methodName : NONSTATIC_ONE_ARG_METHODS_SHOULD_FAIL) {
      Method method = OneArg.class.getMethod(methodName, String.class);
      boolean foundProblem = false;
      try {
        new NullPointerTester().testMethodParameter(foo, method, 0);
      } catch (AssertionFailedError expected) {
        foundProblem = true;
      }
      assertTrue("Should report error in method " + methodName, foundProblem);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMethod - Predicate: N/A - Scenario: method

Project: guava
 Class: NullPointerTesterTest
 Method: testNonStaticInnerClass
 Body: {
    try {
      new NullPointerTester().testAllPublicConstructors(Inner.class);
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("inner class");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: NullPointerTesterTest
 Method: testInterfaceDefaultMethod
 Body: {
    NullPointerTester tester = new NullPointerTester();
    tester.testAllPublicInstanceMethods(InterfaceDefaultMethodChecksNull.create());
    try {
      tester.testAllPublicInstanceMethods(InterfaceDefaultMethodFailsToCheckNull.create());
    } catch (AssertionError expected) {
      return;
    }
    fail();
  }
 Pattern Name: FocalMethod_Match - Action: testAllPublicInstanceMethods - Predicate: N/A - Scenario: tester

Project: guava
 Class: RangeTest
 Method: testAtLeast
 Body: {
    Range<Integer> range = Range.atLeast(6);
    assertFalse(range.contains(5));
    assertTrue(range.contains(6));
    assertTrue(range.contains(Integer.MAX_VALUE));
    assertTrue(range.hasLowerBound());
    assertEquals(6, (int) range.lowerEndpoint());
    assertEquals(CLOSED, range.lowerBoundType());
    assertUnboundedAbove(range);
    assertFalse(range.isEmpty());
    assertEquals("[6..+\u221e)", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testEncloses_closed
 Body: {
    Range<Integer> range = Range.closed(2, 5);
    assertTrue(range.encloses(range));
    assertTrue(range.encloses(Range.open(2, 5)));
    assertTrue(range.encloses(Range.openClosed(2, 5)));
    assertTrue(range.encloses(Range.closedOpen(2, 5)));
    assertTrue(range.encloses(Range.closed(3, 5)));
    assertTrue(range.encloses(Range.closed(2, 4)));

    assertFalse(range.encloses(Range.open(1, 6)));
    assertFalse(range.encloses(Range.greaterThan(3)));
    assertFalse(range.encloses(Range.lessThan(3)));
    assertFalse(range.encloses(Range.atLeast(3)));
    assertFalse(range.encloses(Range.atMost(3)));
    assertFalse(range.encloses(Range.<Integer>all()));
  }
 Pattern Name: FocalMethod_Match - Action: encloses - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testSingleton
 Body: {
    Range<Integer> range = Range.closed(4, 4);
    assertFalse(range.contains(3));
    assertTrue(range.contains(4));
    assertFalse(range.contains(5));
    assertTrue(range.hasLowerBound());
    assertEquals(4, (int) range.lowerEndpoint());
    assertEquals(CLOSED, range.lowerBoundType());
    assertTrue(range.hasUpperBound());
    assertEquals(4, (int) range.upperEndpoint());
    assertEquals(CLOSED, range.upperBoundType());
    assertFalse(range.isEmpty());
    assertEquals("[4..4]", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testSpan_general
 Body: {
    Range<Integer> range = Range.closed(4, 8);

    // separate below
    assertEquals(Range.closed(0, 8), range.span(Range.closed(0, 2)));
    assertEquals(Range.atMost(8), range.span(Range.atMost(2)));

    // adjacent below
    assertEquals(Range.closed(2, 8), range.span(Range.closedOpen(2, 4)));
    assertEquals(Range.atMost(8), range.span(Range.lessThan(4)));

    // overlap below
    assertEquals(Range.closed(2, 8), range.span(Range.closed(2, 6)));
    assertEquals(Range.atMost(8), range.span(Range.atMost(6)));

    // enclosed with same start
    assertEquals(range, range.span(Range.closed(4, 6)));

    // enclosed, interior
    assertEquals(range, range.span(Range.closed(5, 7)));

    // enclosed with same end
    assertEquals(range, range.span(Range.closed(6, 8)));

    // equal
    assertEquals(range, range.span(range));

    // enclosing with same start
    assertEquals(Range.closed(4, 10), range.span(Range.closed(4, 10)));
    assertEquals(Range.atLeast(4), range.span(Range.atLeast(4)));

    // enclosing with same end
    assertEquals(Range.closed(2, 8), range.span(Range.closed(2, 8)));
    assertEquals(Range.atMost(8), range.span(Range.atMost(8)));

    // enclosing, exterior
    assertEquals(Range.closed(2, 10), range.span(Range.closed(2, 10)));
    assertEquals(Range.<Integer>all(), range.span(Range.<Integer>all()));

    // overlap above
    assertEquals(Range.closed(4, 10), range.span(Range.closed(6, 10)));
    assertEquals(Range.atLeast(4), range.span(Range.atLeast(6)));

    // adjacent above
    assertEquals(Range.closed(4, 10), range.span(Range.openClosed(8, 10)));
    assertEquals(Range.atLeast(4), range.span(Range.greaterThan(8)));

    // separate above
    assertEquals(Range.closed(4, 12), range.span(Range.closed(10, 12)));
    assertEquals(Range.atLeast(4), range.span(Range.atLeast(10)));
  }
 Pattern Name: FocalMethod_Match - Action: span - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testContainsAll
 Body: {
    Range<Integer> range = Range.closed(3, 5);
    assertTrue(range.containsAll(asList(3, 3, 4, 5)));
    assertFalse(range.containsAll(asList(3, 3, 4, 5, 6)));

    // We happen to know that natural-order sorted sets use a different code
    // path, so we test that separately
    assertTrue(range.containsAll(ImmutableSortedSet.of(3, 3, 4, 5)));
    assertTrue(range.containsAll(ImmutableSortedSet.of(3)));
    assertTrue(range.containsAll(ImmutableSortedSet.<Integer>of()));
    assertFalse(range.containsAll(ImmutableSortedSet.of(3, 3, 4, 5, 6)));

    assertTrue(Range.openClosed(3, 3).containsAll(Collections.<Integer>emptySet()));
  }
 Pattern Name: FocalMethod_Match - Action: containsAll - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testGap_general
 Body: {
    Range<Integer> openRange = Range.open(4, 8);
    Range<Integer> closedRange = Range.closed(4, 8);

    // first range open end, second range open start
    assertEquals(Range.closed(2, 4), Range.lessThan(2).gap(openRange));
    assertEquals(Range.closed(2, 4), openRange.gap(Range.lessThan(2)));

    // first range closed end, second range open start
    assertEquals(Range.openClosed(2, 4), Range.atMost(2).gap(openRange));
    assertEquals(Range.openClosed(2, 4), openRange.gap(Range.atMost(2)));

    // first range open end, second range closed start
    assertEquals(Range.closedOpen(2, 4), Range.lessThan(2).gap(closedRange));
    assertEquals(Range.closedOpen(2, 4), closedRange.gap(Range.lessThan(2)));

    // first range closed end, second range closed start
    assertEquals(Range.open(2, 4), Range.atMost(2).gap(closedRange));
    assertEquals(Range.open(2, 4), closedRange.gap(Range.atMost(2)));
  }
 Pattern Name: FocalMethod_Match - Action: gap - Predicate: N/A - Scenario: openRange

Project: guava
 Class: RangeTest
 Method: testEncloses_open
 Body: {
    Range<Integer> range = Range.open(2, 5);
    assertTrue(range.encloses(range));
    assertTrue(range.encloses(Range.open(2, 4)));
    assertTrue(range.encloses(Range.open(3, 5)));
    assertTrue(range.encloses(Range.closed(3, 4)));

    assertFalse(range.encloses(Range.openClosed(2, 5)));
    assertFalse(range.encloses(Range.closedOpen(2, 5)));
    assertFalse(range.encloses(Range.closed(1, 4)));
    assertFalse(range.encloses(Range.closed(3, 6)));
    assertFalse(range.encloses(Range.greaterThan(3)));
    assertFalse(range.encloses(Range.lessThan(3)));
    assertFalse(range.encloses(Range.atLeast(3)));
    assertFalse(range.encloses(Range.atMost(3)));
    assertFalse(range.encloses(Range.<Integer>all()));
  }
 Pattern Name: FocalMethod_Match - Action: encloses - Predicate: N/A - Scenario: range

Project: guava
 Class: RangeTest
 Method: testApply
 Body: {
    Predicate<Integer> predicate = Range.closed(2, 3);
    assertFalse(predicate.apply(1));
    assertTrue(predicate.apply(2));
    assertTrue(predicate.apply(3));
    assertFalse(predicate.apply(4));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: predicate

Project: guava
 Class: MapEntrySetTester
 Method: testSetValueWithNullValuesPresent
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      if (entry.getKey().equals(k0())) {
        assertEquals("entry.setValue() should return the old value", v0(), entry.setValue(null));
        break;
      }
    }
    expectReplacement(entry(k0(), (V) null));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: MapEntrySetTester
 Method: testSetValueWithNullValuesAbsent
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      try {
        entry.setValue(null);
        fail("Expected NullPointerException");
      } catch (NullPointerException exception) {
        break;
      }
    }
    expectUnchanged();
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: MapEntrySetTester
 Method: testSetValue
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      if (entry.getKey().equals(k0())) {
        assertEquals("entry.setValue() should return the old value", v0(), entry.setValue(v3()));
        break;
      }
    }
    expectReplacement(entry(k0(), v3()));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: SerializableTesterTest
 Method: testClassWhichIsAlwaysEqualButHasDifferentHashcodes
 Body: {
    ClassWhichIsAlwaysEqualButHasDifferentHashcodes orig =
        new ClassWhichIsAlwaysEqualButHasDifferentHashcodes();
    boolean errorNotThrown = false;
    try {
      SerializableTester.reserializeAndAssert(orig);
      errorNotThrown = true;
    } catch (AssertionFailedError error) {
      // expected
      assertContains("must be equal to the Object#hashCode", error.getMessage());
    }
    assertFalse(errorNotThrown);
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: error

Project: guava
 Class: SerializableTesterTest
 Method: testObjectWhichIsEqualButChangesClass
 Body: {
    ObjectWhichIsEqualButChangesClass orig = new ObjectWhichIsEqualButChangesClass();
    boolean errorNotThrown = false;
    try {
      SerializableTester.reserializeAndAssert(orig);
      errorNotThrown = true;
    } catch (AssertionFailedError error) {
      // expected
      assertContains("expected:<class ", error.getMessage());
    }
    assertFalse(errorNotThrown);
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: error

Project: guava
 Class: SerializableTesterTest
 Method: testClassWhichDoesNotImplementEquals
 Body: {
    ClassWhichDoesNotImplementEquals orig = new ClassWhichDoesNotImplementEquals();
    boolean errorNotThrown = false;
    try {
      SerializableTester.reserializeAndAssert(orig);
      errorNotThrown = true;
    } catch (AssertionFailedError error) {
      // expected
      assertContains("must be Object#equals to", error.getMessage());
    }
    assertFalse(errorNotThrown);
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: error

Project: guava
 Class: SerializableTesterTest
 Method: testStringAssertions
 Body: {
    String original = "hello world";
    String copy = SerializableTester.reserializeAndAssert(original);
    assertEquals(original, copy);
    assertNotSame(original, copy);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: ToStringHelperTest
 Method: testToStringHelperLenient_localInnerNestedClass
 Body: {
    class LocalInnerClass {
      class LocalInnerNestedClass {}
    }
    String toTest =
        MoreObjects.toStringHelper(new LocalInnerClass().new LocalInnerNestedClass()).toString();
    assertTrue(toTest, toTest.matches(".*\\{\\}"));
  }
 Pattern Name: FocalMethod_Match - Action: matches - Predicate: N/A - Scenario: toTest

Project: guava
 Class: ToStringHelperTest
 Method: testToStringHelperLenient_localInnerClass
 Body: {
    class LocalInnerClass {}
    String toTest = MoreObjects.toStringHelper(new LocalInnerClass()).toString();
    assertTrue(toTest, toTest.matches(".*\\{\\}"));
  }
 Pattern Name: FocalMethod_Match - Action: matches - Predicate: N/A - Scenario: toTest

Project: guava
 Class: ToStringHelperTest
 Method: testToString_complexFields
 Body: {

    Map<String, Integer> map =
        ImmutableMap.<String, Integer>builder().put("abc", 1).put("def", 2).put("ghi", 3).build();
    String toTest =
        MoreObjects.toStringHelper(new TestClass())
            .add("field1", "This is string.")
            .add("field2", Arrays.asList("abc", "def", "ghi"))
            .add("field3", map)
            .toString();
    final String expected =
        "TestClass{"
            + "field1=This is string., field2=[abc, def, ghi], field3={abc=1, def=2, ghi=3}}";

    assertEquals(expected, toTest);
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: map

Project: guava
 Class: ToStringHelperTest
 Method: testToStringLenient_complexFields
 Body: {

    Map<String, Integer> map =
        ImmutableMap.<String, Integer>builder().put("abc", 1).put("def", 2).put("ghi", 3).build();
    String toTest =
        MoreObjects.toStringHelper(new TestClass())
            .add("field1", "This is string.")
            .add("field2", Arrays.asList("abc", "def", "ghi"))
            .add("field3", map)
            .toString();
    final String expectedRegex =
        ".*\\{"
            + "field1\\=This is string\\., "
            + "field2\\=\\[abc, def, ghi\\], "
            + "field3=\\{abc\\=1, def\\=2, ghi\\=3\\}\\}";

    assertTrue(toTest, toTest.matches(expectedRegex));
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: map

Project: guava
 Class: MultimapGetTester
 Method: testPropagatesAddAllToMultimap
 Body: {
    Collection<V> result = multimap().get(k0());
    assertTrue(result.addAll(Collections.singletonList(v3())));
    assertTrue(multimap().containsKey(k0()));
    assertEquals(getNumElements() + 1, multimap().size());
    assertTrue(multimap().containsEntry(k0(), v3()));
  }
 Pattern Name: FocalMethod_Match - Action: addAll - Predicate: N/A - Scenario: result

Project: guava
 Class: MultimapGetTester
 Method: testPropagatesAddToMultimap
 Body: {
    Collection<V> result = multimap().get(k0());
    assertTrue(result.add(v3()));
    assertTrue(multimap().containsKey(k0()));
    assertEquals(getNumElements() + 1, multimap().size());
    assertTrue(multimap().containsEntry(k0(), v3()));
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: result

Project: guava
 Class: CharSinkTester
 Method: testOpenBufferedStream
 Body: {
    Writer writer = sink.openBufferedStream();
    try {
      writer.write(data);
    } finally {
      writer.close();
    }

    assertContainsExpectedString();
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: CharSinkTester
 Method: testOpenStream
 Body: {
    Writer writer = sink.openStream();
    try {
      writer.write(data);
    } finally {
      writer.close();
    }

    assertContainsExpectedString();
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: MoreExecutorsTest
 Method: testGetExitingScheduledExecutorService_executorSetToUseDaemonThreads
 Body: {
    TestApplication application = new TestApplication();
    ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);
    assertNotNull(application.getExitingScheduledExecutorService(executor));
    assertTrue(executor.getThreadFactory().newThread(EMPTY_RUNNABLE).isDaemon());
  }
 Pattern Name: FocalMethod_Match - Action: getExitingScheduledExecutorService - Predicate: N/A - Scenario: application

Project: guava
 Class: MoreExecutorsTest
 Method: testGetExitingExecutorService_executorSetToUseDaemonThreads
 Body: {
    TestApplication application = new TestApplication();
    ThreadPoolExecutor executor =
        new ThreadPoolExecutor(1, 2, 3, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1));
    assertNotNull(application.getExitingExecutorService(executor));
    assertTrue(executor.getThreadFactory().newThread(EMPTY_RUNNABLE).isDaemon());
  }
 Pattern Name: FocalMethod_Match - Action: getExitingExecutorService - Predicate: N/A - Scenario: application

Project: guava
 Class: MoreExecutorsTest
 Method: testListeningDecorator
 Body: {
    ListeningExecutorService service = listeningDecorator(newDirectExecutorService());
    assertSame(service, listeningDecorator(service));
    List<Callable<String>> callables = ImmutableList.of(Callables.returning("x"));
    List<Future<String>> results;

    results = service.invokeAll(callables);
    assertThat(getOnlyElement(results)).isInstanceOf(TrustedListenableFutureTask.class);

    results = service.invokeAll(callables, 1, SECONDS);
    assertThat(getOnlyElement(results)).isInstanceOf(TrustedListenableFutureTask.class);

    /*
     * TODO(cpovirk): move ForwardingTestCase somewhere common, and use it to
     * test the forwarded methods
     */
  }
 Pattern Name: FocalMethod_Match - Action: isInstanceOf - Predicate: N/A - Scenario: results

Project: guava
 Class: QuantilesAlgorithmTest
 Method: testMultipleQuantile
 Body: {
    ImmutableSet<Integer> indexes = ImmutableSet.of(50, 90, 99);
    Map<Integer, Double> referenceQuantiles =
        REFERENCE_ALGORITHM.multipleQuantiles(indexes, 100, dataset.clone());
    assertThat(referenceQuantiles.keySet()).isEqualTo(indexes);
    for (QuantilesAlgorithm algorithm : NON_REFERENCE_ALGORITHMS) {
      Map<Integer, Double> quantiles = algorithm.multipleQuantiles(indexes, 100, dataset.clone());
      assertWithMessage("Wrong keys from " + algorithm).that(quantiles.keySet()).isEqualTo(indexes);
      for (int i : indexes) {
        assertWithMessage("Mismatch between %s and %s at %s", algorithm, REFERENCE_ALGORITHM, i)
            .that(quantiles.get(i))
            .isWithin(ALLOWED_ERROR)
            .of(referenceQuantiles.get(i));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: referenceQuantiles

Project: guava
 Class: ConverterTest
 Method: testNullIsNotPassedThrough
 Body: {
    Converter<String, String> nullsAreHandled = sillyConverter(true);
    assertEquals("forward", nullsAreHandled.convert("foo"));
    assertEquals(null, nullsAreHandled.convert(null));
    assertEquals("backward", nullsAreHandled.reverse().convert("foo"));
    assertEquals(null, nullsAreHandled.reverse().convert(null));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: nullsAreHandled

Project: guava
 Class: ConverterTest
 Method: testSerialization_andThen
 Body: {
    Converter<String, Long> converterA = Longs.stringConverter();
    Converter<Long, String> reverseConverter = Longs.stringConverter().reverse();
    Converter<String, String> composedConverter = converterA.andThen(reverseConverter);
    SerializableTester.reserializeAndAssert(composedConverter);
  }
 Pattern Name: FocalMethod_Match - Action: andThen - Predicate: N/A - Scenario: reverseConverter

Project: guava
 Class: ConverterTest
 Method: testSerialization_from
 Body: {
    Converter<String, String> dumb = Converter.from(toStringFunction(), toStringFunction());
    SerializableTester.reserializeAndAssert(dumb);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: dumb

Project: guava
 Class: ConverterTest
 Method: testNullIsPassedThrough
 Body: {
    Converter<String, String> nullsArePassed = sillyConverter(false);
    assertEquals("forward", nullsArePassed.convert("foo"));
    assertEquals("forward", nullsArePassed.convert(null));
    assertEquals("backward", nullsArePassed.reverse().convert("foo"));
    assertEquals("backward", nullsArePassed.reverse().convert(null));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: nullsArePassed

Project: guava
 Class: ConverterTest
 Method: testAndThen
 Body: {
    Converter<StringWrapper, String> first =
        new Converter<StringWrapper, String>() {
          @Override
          protected String doForward(StringWrapper object) {
            return object.value;
          }

          @Override
          protected StringWrapper doBackward(String object) {
            return new StringWrapper(object);
          }

          @Override
          public String toString() {
            return "StringWrapper";
          }
        };

    Converter<StringWrapper, Long> converter = first.andThen(STR_TO_LONG);

    assertEquals(LONG_VAL, converter.convert(new StringWrapper(STR_VAL)));
    assertEquals(STR_VAL, converter.reverse().convert(LONG_VAL).value);

    assertEquals("StringWrapper.andThen(string2long)", converter.toString());

    assertEquals(first.andThen(STR_TO_LONG), first.andThen(STR_TO_LONG));
  }
 Pattern Name: FocalMethod_Match - Action: andThen - Predicate: N/A - Scenario: first

Project: guava
 Class: JoinerTest
 Method: testEntries
 Body: {
    MapJoiner j = Joiner.on(";").withKeyValueSeparator(":");
    assertEquals("", j.join(ImmutableMultimap.of().entries()));
    assertEquals("", j.join(ImmutableMultimap.of().entries().iterator()));
    assertEquals(":", j.join(ImmutableMultimap.of("", "").entries()));
    assertEquals(":", j.join(ImmutableMultimap.of("", "").entries().iterator()));
    assertEquals("1:a;1:b", j.join(ImmutableMultimap.of("1", "a", "1", "b").entries()));
    assertEquals("1:a;1:b", j.join(ImmutableMultimap.of("1", "a", "1", "b").entries().iterator()));

    Map<String, String> mapWithNulls = Maps.newLinkedHashMap();
    mapWithNulls.put("a", null);
    mapWithNulls.put(null, "b");
    Set<Entry<String, String>> entriesWithNulls = mapWithNulls.entrySet();

    try {
      j.join(entriesWithNulls);
      fail();
    } catch (NullPointerException expected) {
    }

    try {
      j.join(entriesWithNulls.iterator());
      fail();
    } catch (NullPointerException expected) {
    }

    assertEquals("a:00;00:b", j.useForNull("00").join(entriesWithNulls));
    assertEquals("a:00;00:b", j.useForNull("00").join(entriesWithNulls.iterator()));

    StringBuilder sb1 = new StringBuilder();
    j.appendTo(sb1, ImmutableMultimap.of(1, 2, 3, 4, 5, 6, 1, 3, 5, 10).entries());
    assertEquals("1:2;1:3;3:4;5:6;5:10", sb1.toString());

    StringBuilder sb2 = new StringBuilder();
    j.appendTo(sb2, ImmutableMultimap.of(1, 2, 3, 4, 5, 6, 1, 3, 5, 10).entries().iterator());
    assertEquals("1:2;1:3;3:4;5:6;5:10", sb2.toString());
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: mapWithNulls

Project: guava
 Class: ByteSinkTester
 Method: testOpenStream
 Body: {
    OutputStream out = sink.openStream();
    try {
      ByteStreams.copy(new ByteArrayInputStream(data), out);
    } finally {
      out.close();
    }

    assertContainsExpectedBytes();
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: out

Project: guava
 Class: ByteSinkTester
 Method: testOpenBufferedStream
 Body: {
    OutputStream out = sink.openBufferedStream();
    try {
      ByteStreams.copy(new ByteArrayInputStream(data), out);
    } finally {
      out.close();
    }

    assertContainsExpectedBytes();
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: out

Project: guava
 Class: TreeRangeSetTest
 Method: testAllTwoRangesEnclosing
 Body: {
    for (Range<Integer> range1 : QUERY_RANGES) {
      for (Range<Integer> range2 : QUERY_RANGES) {
        TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
        rangeSet.add(range1);
        rangeSet.add(range2);
        testEnclosing(rangeSet);
        testEnclosing(rangeSet.complement());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: TreeRangeSetTest
 Method: testAllTwoRangesIntersecting
 Body: {
    for (Range<Integer> range1 : QUERY_RANGES) {
      for (Range<Integer> range2 : QUERY_RANGES) {
        TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
        rangeSet.add(range1);
        rangeSet.add(range2);
        testIntersects(rangeSet);
        testIntersects(rangeSet.complement());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: TreeRangeSetTest
 Method: testCreateCopy
 Body: {
    for (Range<Integer> range1 : QUERY_RANGES) {
      for (Range<Integer> range2 : QUERY_RANGES) {
        TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
        rangeSet.add(range1);
        rangeSet.add(range2);

        assertEquals(rangeSet, TreeRangeSet.create(rangeSet));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: TreeRangeSetTest
 Method: testComplement
 Body: {
    for (Range<Integer> range1 : QUERY_RANGES) {
      for (Range<Integer> range2 : QUERY_RANGES) {
        TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
        rangeSet.add(range1);
        rangeSet.add(range2);
        testViewAgainstExpected(expectedComplement(rangeSet), rangeSet.complement());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: TreeRangeSetTest
 Method: testRangesByUpperBound
 Body: {
    for (Range<Integer> range1 : QUERY_RANGES) {
      for (Range<Integer> range2 : QUERY_RANGES) {
        TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
        rangeSet.add(range1);
        rangeSet.add(range2);

        NavigableMap<Cut<Integer>, Range<Integer>> expectedRangesByUpperBound = Maps.newTreeMap();
        for (Range<Integer> range : rangeSet.asRanges()) {
          expectedRangesByUpperBound.put(range.upperBound, range);
        }
        testNavigationAgainstExpected(
            expectedRangesByUpperBound,
            new TreeRangeSet.RangesByUpperBound<Integer>(rangeSet.rangesByLowerBound),
            CUTS_TO_TEST);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: ConfigurableDirectedGraphTest
 Method: addEdge_selfLoop
 Body: {
    try {
      putEdge(N1, N1);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: FilesTest
 Method: testCreateTempDir
 Body: {
    File temp = Files.createTempDir();
    assertTrue(temp.exists());
    assertTrue(temp.isDirectory());
    assertThat(temp.listFiles()).isEmpty();
    assertTrue(temp.delete());
  }
 Pattern Name: FocalMethod_Match - Action: exists - Predicate: N/A - Scenario: temp

Project: guava
 Class: FilesTest
 Method: testPredicates
 Body: {
    File asciiFile = getTestFile("ascii.txt");
    File dir = asciiFile.getParentFile();
    assertTrue(Files.isDirectory().apply(dir));
    assertFalse(Files.isFile().apply(dir));

    assertFalse(Files.isDirectory().apply(asciiFile));
    assertTrue(Files.isFile().apply(asciiFile));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: dir

Project: guava
 Class: SynchronizedNavigableSetTest
 Method: testDescendingSet
 Body: {
    NavigableSet<String> set = create();
    NavigableSet<String> descendingSet = set.descendingSet();
    assertTrue(descendingSet instanceof SynchronizedNavigableSet);
    assertSame(set, ((SynchronizedNavigableSet<String>) descendingSet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: descendingSet - Predicate: N/A - Scenario: descendingSet

Project: guava
 Class: SynchronizedNavigableSetTest
 Method: testHeadSet_E
 Body: {
    NavigableSet<String> set = create();
    SortedSet<String> headSet = set.headSet("a");
    assertTrue(headSet instanceof SynchronizedSortedSet);
    assertSame(set, ((SynchronizedSortedSet<String>) headSet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: headSet - Predicate: N/A - Scenario: headSet

Project: guava
 Class: SynchronizedNavigableSetTest
 Method: testHeadSet_E_B
 Body: {
    NavigableSet<String> set = create();
    NavigableSet<String> headSet = set.headSet("a", true);
    assertTrue(headSet instanceof SynchronizedNavigableSet);
    assertSame(set, ((SynchronizedNavigableSet<String>) headSet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: headSet - Predicate: N/A - Scenario: headSet

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: addEdge_existingEdgeBetweenDifferentNodes_selfLoops
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N2, E11);
      fail("Reusing an existing self-loop edge to connect different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    try {
      addEdge(N2, N2, E11);
      fail("Reusing an existing self-loop edge to make a different self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    addEdge(N1, N2, E12);
    try {
      addEdge(N1, N1, E12);
      fail("Reusing an existing edge to add a self-loop edge between different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: MultimapKeySetTester
 Method: testKeySetRemovePropagatesToMultimap
 Body: {
    int key0Count = multimap().get(k0()).size();
    assertEquals(key0Count > 0, multimap().keySet().remove(k0()));
    assertEquals(getNumElements() - key0Count, multimap().size());
    assertGet(k0());
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: key0Count

Project: guava
 Class: FinalizableReferenceQueueClassLoaderUnloadingTest
 Method: testUnloadableWithSecurityManager
 Body: {
    if (isJdk9OrHigher()) {
      return;
    }
    Policy oldPolicy = Policy.getPolicy();
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      Policy.setPolicy(new PermissivePolicy());
      System.setSecurityManager(new SecurityManager());
      doTestUnloadable();
    } finally {
      System.setSecurityManager(oldSecurityManager);
      Policy.setPolicy(oldPolicy);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setSecurityManager - Predicate: N/A - Scenario: oldSecurityManager

Project: guava
 Class: FinalizableReferenceQueueClassLoaderUnloadingTest
 Method: testUnloadableInStaticFieldIfClosed
 Body: {
    if (isJdk9OrHigher()) {
      return;
    }
    Policy oldPolicy = Policy.getPolicy();
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      Policy.setPolicy(new PermissivePolicy());
      System.setSecurityManager(new SecurityManager());
      WeakReference<ClassLoader> loaderRef = doTestUnloadableInStaticFieldIfClosed();
      GcFinalization.awaitClear(loaderRef);
    } finally {
      System.setSecurityManager(oldSecurityManager);
      Policy.setPolicy(oldPolicy);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setSecurityManager - Predicate: N/A - Scenario: oldSecurityManager

Project: guava
 Class: FinalizableReferenceQueueClassLoaderUnloadingTest
 Method: testUnloadableWithoutSecurityManager
 Body: {
    if (isJdk9OrHigher()) {
      return;
    }
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      System.setSecurityManager(null);
      doTestUnloadable();
    } finally {
      System.setSecurityManager(oldSecurityManager);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setSecurityManager - Predicate: N/A - Scenario: oldSecurityManager

Project: guava
 Class: XmlEscapersTest
 Method: testXmlContentEscaper
 Body: {
    CharEscaper xmlContentEscaper = (CharEscaper) XmlEscapers.xmlContentEscaper();
    assertBasicXmlEscaper(xmlContentEscaper, false, false);
    // Test quotes are not escaped.
    assertEquals("\"test\"", xmlContentEscaper.escape("\"test\""));
    assertEquals("'test'", xmlContentEscaper.escape("'test'"));
  }
 Pattern Name: FocalMethod_Match - Action: xmlContentEscaper - Predicate: N/A - Scenario: xmlContentEscaper

Project: guava
 Class: XmlEscapersTest
 Method: testXmlAttributeEscaper
 Body: {
    CharEscaper xmlAttributeEscaper = (CharEscaper) XmlEscapers.xmlAttributeEscaper();
    assertBasicXmlEscaper(xmlAttributeEscaper, true, true);
    // Test quotes are escaped.
    assertEquals("&quot;test&quot;", xmlAttributeEscaper.escape("\"test\""));
    assertEquals("&apos;test&apos;", xmlAttributeEscaper.escape("\'test'"));
    // Test all escapes
    assertEquals(
        "a&quot;b&lt;c&gt;d&amp;e&quot;f&apos;", xmlAttributeEscaper.escape("a\"b<c>d&e\"f'"));
    // Test '\t', '\n' and '\r' are escaped.
    assertEquals("a&#x9;b&#xA;c&#xD;d", xmlAttributeEscaper.escape("a\tb\nc\rd"));
  }
 Pattern Name: FocalMethod_Match - Action: xmlAttributeEscaper - Predicate: N/A - Scenario: xmlAttributeEscaper

Project: guava
 Class: AbstractIteratorTest
 Method: testSneakyThrow
 Body: {
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          boolean haveBeenCalled;

          @Override
          public Integer computeNext() {
            if (haveBeenCalled) {
              fail("Should not have been called again");
            } else {
              haveBeenCalled = true;
              sneakyThrow(new SomeCheckedException());
            }
            return null; // never reached
          }
        };

    // The first time, the sneakily-thrown exception comes out
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (Exception e) {
      if (!(e instanceof SomeCheckedException)) {
        throw e;
      }
    }

    // But the second time, AbstractIterator itself throws an ISE
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: e

Project: guava
 Class: ImmutableRangeMapTest
 Method: testAsMapOfRanges
 Body: {
    for (Range<Integer> range1 : RANGES) {
      for (Range<Integer> range2 : RANGES) {
        if (!range1.isConnected(range2) || range1.intersection(range2).isEmpty()) {
          ImmutableRangeMap<Integer, Integer> rangeMap =
              ImmutableRangeMap.<Integer, Integer>builder().put(range1, 1).put(range2, 2).build();

          ImmutableMap<Range<Integer>, Integer> expectedAsMap =
              ImmutableMap.of(range1, 1, range2, 2);
          ImmutableMap<Range<Integer>, Integer> asMap = rangeMap.asMapOfRanges();
          ImmutableMap<Range<Integer>, Integer> descendingMap = rangeMap.asDescendingMapOfRanges();
          assertEquals(expectedAsMap, asMap);
          assertEquals(expectedAsMap, descendingMap);
          SerializableTester.reserializeAndAssert(asMap);
          SerializableTester.reserializeAndAssert(descendingMap);
          assertEquals(
              ImmutableList.copyOf(asMap.entrySet()).reverse(),
              ImmutableList.copyOf(descendingMap.entrySet()));

          for (Range<Integer> query : RANGES) {
            assertEquals(expectedAsMap.get(query), asMap.get(query));
          }
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: asMapOfRanges - Predicate: N/A - Scenario: asMap

Project: guava
 Class: TreeMultisetTest
 Method: testCreateFromIterable
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Arrays.asList("foo", "bar", "foo"));
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals("[bar, foo x 2]", multiset.toString());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: multiset

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetBridgeMethods
 Body: {
    for (Method m : TreeMultiset.class.getMethods()) {
      if (m.getName().equals("elementSet") && m.getReturnType().equals(SortedSet.class)) {
        return;
      }
    }
    fail("No bridge method found");
  }
 Pattern Name: FocalMethod_Match - Action: getName - Predicate: N/A - Scenario: m

Project: guava
 Class: BiMapInverseTester
 Method: testInverseSerialization
 Body: {
    BiMapPair<K, V> pair = new BiMapPair<>(getMap());
    BiMapPair<K, V> copy = SerializableTester.reserialize(pair);
    assertEquals(pair.forward, copy.forward);
    assertEquals(pair.backward, copy.backward);
    assertSame(copy.backward, copy.forward.inverse());
    assertSame(copy.forward, copy.backward.inverse());
  }
 Pattern Name: FocalMethod_Match - Action: inverse - Predicate: N/A - Scenario: copy

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testString
 Body: {
    Random random = new Random();
    for (int i = 0; i < 100; i++) {
      byte[] bytes = new byte[64];
      random.nextBytes(bytes);
      String s = new String(bytes, UTF_16LE); // so all random strings are valid
      assertEquals(
          new Sink(4).putUnencodedChars(s).hash(),
          new Sink(4).putBytes(s.getBytes(UTF_16LE)).hash());
      assertEquals(
          new Sink(4).putUnencodedChars(s).hash(), new Sink(4).putString(s, UTF_16LE).hash());
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextBytes - Predicate: N/A - Scenario: s

Project: guava
 Class: CountingInputStreamTest
 Method: testMarkNotSet
 Body: {
    try {
      counter.reset();
      fail();
    } catch (IOException expected) {
      assertThat(expected).hasMessage("Mark not set");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: InternersTest
 Method: testStrong_simplistic
 Body: {
    String canonical = "a";
    String not = new String("a");

    Interner<String> pool = Interners.newStrongInterner();
    assertSame(canonical, pool.intern(canonical));
    assertSame(canonical, pool.intern(not));
  }
 Pattern Name: FocalMethod_Match - Action: intern - Predicate: N/A - Scenario: pool

Project: guava
 Class: InternersTest
 Method: testWeak_simplistic
 Body: {
    String canonical = "a";
    String not = new String("a");

    Interner<String> pool = Interners.newWeakInterner();
    assertSame(canonical, pool.intern(canonical));
    assertSame(canonical, pool.intern(not));
  }
 Pattern Name: FocalMethod_Match - Action: intern - Predicate: N/A - Scenario: pool

Project: guava
 Class: InternersTest
 Method: testWeak_afterGC
 Body: {
    Integer canonical = new Integer(5);
    Integer not = new Integer(5);

    Interner<Integer> pool = Interners.newWeakInterner();
    assertSame(canonical, pool.intern(canonical));

    WeakReference<Integer> signal = new WeakReference<>(canonical);
    canonical = null; // Hint to the JIT that canonical is unreachable

    GcFinalization.awaitClear(signal);
    assertSame(not, pool.intern(not));
  }
 Pattern Name: FocalMethod_Match - Action: intern - Predicate: N/A - Scenario: pool

Project: guava
 Class: LocalCacheMapComputeTest
 Method: testComputeEviction
 Body: {
    // b/80241237

    Cache<String, String> c = CacheBuilder.newBuilder().maximumSize(1).build();

    assertThat(c.asMap().compute("hash-1", (k, v) -> "a")).isEqualTo("a");
    assertThat(c.asMap().compute("hash-1", (k, v) -> "b")).isEqualTo("b");
    assertThat(c.asMap().compute("hash-1", (k, v) -> "c")).isEqualTo("c");
    assertThat(c.size()).isEqualTo(1);
    assertThat(c.asMap().computeIfAbsent("hash-2", k -> "")).isEqualTo("");
  }
 Pattern Name: FocalMethod_Match - Action: newBuilder - Predicate: N/A - Scenario: c

Project: guava
 Class: LocalCacheMapComputeTest
 Method: testComputeIfAbsentEviction
 Body: {
    // b/80241237

    Cache<String, String> c = CacheBuilder.newBuilder().maximumSize(1).build();

    assertThat(c.asMap().computeIfAbsent("hash-1", k -> "")).isEqualTo("");
    assertThat(c.asMap().computeIfAbsent("hash-1", k -> "")).isEqualTo("");
    assertThat(c.asMap().computeIfAbsent("hash-1", k -> "")).isEqualTo("");
    assertThat(c.size()).isEqualTo(1);
    assertThat(c.asMap().computeIfAbsent("hash-2", k -> "")).isEqualTo("");
  }
 Pattern Name: FocalMethod_Match - Action: newBuilder - Predicate: N/A - Scenario: c

Project: guava
 Class: MoreCollectorsTest
 Method: testToOptionalMultiple
 Body: {
    try {
      Stream.of(1, 2).collect(MoreCollectors.toOptional());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("1, 2");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: MoreCollectorsTest
 Method: testOnlyElementMany
 Body: {
    try {
      Stream.of(1, 2, 3, 4, 5, 6).collect(MoreCollectors.onlyElement());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("1, 2, 3, 4, 5, ...");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: MoreCollectorsTest
 Method: testToOptionalMany
 Body: {
    try {
      Stream.of(1, 2, 3, 4, 5, 6).collect(MoreCollectors.toOptional());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("1, 2, 3, 4, 5, ...");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: MoreCollectorsTest
 Method: testOnlyElementMultiple
 Body: {
    try {
      Stream.of(1, 2).collect(MoreCollectors.onlyElement());
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("1, 2");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: FakeTickerTest
 Method: testAutoIncrementStep_seconds
 Body: {
    FakeTicker ticker = new FakeTicker().setAutoIncrementStep(3, TimeUnit.SECONDS);
    assertEquals(0, ticker.read());
    assertEquals(3000000000L, ticker.read());
    assertEquals(6000000000L, ticker.read());
  }
 Pattern Name: FocalMethod_Match - Action: read - Predicate: N/A - Scenario: ticker

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_edgeDirectionsDiffer
 Body: {
    graph.putEdge(N1, N2);

    MutableGraph<Integer> g2 = createGraph(edgeType);
    g2.putEdge(N2, N1);

    switch (edgeType) {
      case UNDIRECTED:
        assertThat(graph).isEqualTo(g2);
        break;
      case DIRECTED:
        assertThat(graph).isNotEqualTo(g2);
        break;
      default:
        throw new IllegalStateException("Unexpected edge type: " + edgeType);
    }
  }
 Pattern Name: FocalMethod_Match - Action: putEdge - Predicate: N/A - Scenario: g2

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testPutAndGetInstance
 Body: {
    assertNull(map.putInstance(Integer.class, new Integer(5)));

    Integer oldValue = map.putInstance(Integer.class, new Integer(7));
    assertEquals(5, (int) oldValue);

    Integer newValue = map.getInstance(Integer.class);
    assertEquals(7, (int) newValue);
    assertEquals(7, (int) map.getInstance(TypeToken.of(Integer.class)));

    // Won't compile: map.putInstance(Double.class, new Long(42));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: newValue

Project: guava
 Class: ListsTest
 Method: testPartition_1_2
 Body: {
    List<Integer> source = Collections.singletonList(1);
    List<List<Integer>> partitions = Lists.partition(source, 2);
    assertEquals(1, partitions.size());
    assertEquals(Collections.singletonList(1), partitions.get(0));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testCartesianProduct_contains
 Body: {
    List<List<Integer>> actual = Lists.cartesianProduct(list(1, 2), list(3, 4));
    assertTrue(actual.contains(list(1, 3)));
    assertTrue(actual.contains(list(1, 4)));
    assertTrue(actual.contains(list(2, 3)));
    assertTrue(actual.contains(list(2, 4)));
    assertFalse(actual.contains(list(3, 1)));
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: actual

Project: guava
 Class: ListsTest
 Method: testPartition_3_2
 Body: {
    List<Integer> source = asList(1, 2, 3);
    List<List<Integer>> partitions = Lists.partition(source, 2);
    assertEquals(2, partitions.size());
    assertEquals(asList(1, 2), partitions.get(0));
    assertEquals(asList(3), partitions.get(1));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testCartesianProduct_indexOf
 Body: {
    List<List<Integer>> actual = Lists.cartesianProduct(list(1, 2), list(3, 4));
    assertEquals(actual.indexOf(list(1, 3)), 0);
    assertEquals(actual.indexOf(list(1, 4)), 1);
    assertEquals(actual.indexOf(list(2, 3)), 2);
    assertEquals(actual.indexOf(list(2, 4)), 3);
    assertEquals(actual.indexOf(list(3, 1)), -1);

    assertEquals(actual.indexOf(list(1)), -1);
    assertEquals(actual.indexOf(list(1, 1, 1)), -1);
  }
 Pattern Name: FocalMethod_Match - Action: indexOf - Predicate: N/A - Scenario: actual

Project: guava
 Class: ListsTest
 Method: testPartitionRandomAccessFalse
 Body: {
    List<Integer> source = Lists.newLinkedList(asList(1, 2, 3));
    List<List<Integer>> partitions = Lists.partition(source, 2);
    assertFalse(partitions instanceof RandomAccess);
    assertFalse(partitions.get(0) instanceof RandomAccess);
    assertFalse(partitions.get(1) instanceof RandomAccess);
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testPartition_2_1
 Body: {
    List<Integer> source = asList(1, 2);
    List<List<Integer>> partitions = Lists.partition(source, 1);
    assertEquals(2, partitions.size());
    assertEquals(Collections.singletonList(1), partitions.get(0));
    assertEquals(Collections.singletonList(2), partitions.get(1));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testPartitionRandomAccessTrue
 Body: {
    List<Integer> source = asList(1, 2, 3);
    List<List<Integer>> partitions = Lists.partition(source, 2);

    assertTrue(
        "partition should be RandomAccess, but not: " + partitions.getClass(),
        partitions instanceof RandomAccess);

    assertTrue(
        "partition[0] should be RandomAccess, but not: " + partitions.get(0).getClass(),
        partitions.get(0) instanceof RandomAccess);

    assertTrue(
        "partition[1] should be RandomAccess, but not: " + partitions.get(1).getClass(),
        partitions.get(1) instanceof RandomAccess);
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testPartition_1_1
 Body: {
    List<Integer> source = Collections.singletonList(1);
    List<List<Integer>> partitions = Lists.partition(source, 1);
    assertEquals(1, partitions.size());
    assertEquals(Collections.singletonList(1), partitions.get(0));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testPartition_empty
 Body: {
    List<Integer> source = Collections.emptyList();
    List<List<Integer>> partitions = Lists.partition(source, 1);
    assertTrue(partitions.isEmpty());
    assertEquals(0, partitions.size());
  }
 Pattern Name: FocalMethod_Match - Action: isEmpty - Predicate: N/A - Scenario: partitions

Project: guava
 Class: ListsTest
 Method: testArraysAsList
 Body: {
    List<String> ourWay = Lists.newArrayList("foo", "bar", "baz");
    List<String> otherWay = asList("foo", "bar", "baz");

    // They're logically equal
    assertEquals(ourWay, otherWay);

    // The result of Arrays.asList() is mutable
    otherWay.set(0, "FOO");
    assertEquals("FOO", otherWay.get(0));

    // But it can't grow
    try {
      otherWay.add("nope");
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }

    // And it can't shrink
    try {
      otherWay.remove(2);
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: otherWay

Project: guava
 Class: ImmutableMapTest
 Method: testViewSerialization
 Body: {
    Map<String, Integer> map = ImmutableMap.of("one", 1, "two", 2, "three", 3);
    LenientSerializableTester.reserializeAndAssertLenient(map.entrySet());
    LenientSerializableTester.reserializeAndAssertLenient(map.keySet());

    Collection<Integer> reserializedValues = reserialize(map.values());
    assertEquals(Lists.newArrayList(map.values()), Lists.newArrayList(reserializedValues));
    assertTrue(reserializedValues instanceof ImmutableCollection);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: ImmutableMapTest
 Method: testMutableValues
 Body: {
    IntHolder holderA = new IntHolder(1);
    IntHolder holderB = new IntHolder(2);
    Map<String, IntHolder> map = ImmutableMap.of("a", holderA, "b", holderB);
    holderA.value = 3;
    assertTrue(map.entrySet().contains(Maps.immutableEntry("a", new IntHolder(3))));
    Map<String, Integer> intMap = ImmutableMap.of("a", 3, "b", 2);
    assertEquals(intMap.hashCode(), map.entrySet().hashCode());
    assertEquals(intMap.hashCode(), map.hashCode());
  }
 Pattern Name: FocalMethod_Match - Action: hashCode - Predicate: N/A - Scenario: intMap

Project: guava
 Class: ImmutableMapTest
 Method: testResistsHashFloodingOnGet
 Body: {
    CallsCounter smallCounter = new CallsCounter();
    List<CountsHashCodeAndEquals> haveSameHashesSmall = createAdversarialInput(10, smallCounter);
    int smallSize = haveSameHashesSmall.size();
    ImmutableMap<?, ?> smallMap =
        ConstructionPathway.BUILDER_PUT_ONE_BY_ONE.create(
            haveSameHashesSmall, "valueObject", smallCounter);
    long worstCaseQuerySmall = worstCaseQueryOperations(smallMap, smallCounter);

    CallsCounter largeCounter = new CallsCounter();
    List<CountsHashCodeAndEquals> haveSameHashesLarge = createAdversarialInput(15, largeCounter);
    int largeSize = haveSameHashesLarge.size();
    ImmutableMap<?, ?> largeMap =
        ConstructionPathway.BUILDER_PUT_ONE_BY_ONE.create(
            haveSameHashesLarge, "valueObject", largeCounter);
    long worstCaseQueryLarge = worstCaseQueryOperations(largeMap, largeCounter);

    double ratio = (double) worstCaseQueryLarge / worstCaseQuerySmall;
    assertThat(ratio)
        .named(
            "Ratio of worst case query operations for an ImmutableMap of size %s versus %s",
            largeSize, smallSize)
        .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
    // allow up to 2x wobble in the constant factors
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: largeMap

Project: guava
 Class: AbstractByteHasherTest
 Method: testString
 Body: {
    Random random = new Random();
    for (int i = 0; i < 100; i++) {
      byte[] bytes = new byte[64];
      random.nextBytes(bytes);
      String s = new String(bytes, UTF_16LE); // so all random strings are valid
      assertEquals(
          new TestHasher().putUnencodedChars(s).hash(),
          new TestHasher().putBytes(s.getBytes(UTF_16LE)).hash());
      assertEquals(
          new TestHasher().putUnencodedChars(s).hash(),
          new TestHasher().putString(s, UTF_16LE).hash());
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextBytes - Predicate: N/A - Scenario: s

Project: guava
 Class: CharSourceTest
 Method: testReadLines_withProcessor_stopsOnFalse
 Body: {
    TestCharSource lines = new TestCharSource(LINES);
    List<String> list =
        lines.readLines(
            new LineProcessor<List<String>>() {
              List<String> list = Lists.newArrayList();

              @Override
              public boolean processLine(String line) throws IOException {
                list.add(line);
                return false;
              }

              @Override
              public List<String> getResult() {
                return list;
              }
            });
    assertEquals(ImmutableList.of("foo"), list);
    assertTrue(lines.wasStreamOpened() && lines.wasStreamClosed());
  }
 Pattern Name: FocalMethod_Match - Action: readLines - Predicate: N/A - Scenario: list

Project: guava
 Class: CharSourceTest
 Method: testOpenBufferedStream
 Body: {
    BufferedReader reader = source.openBufferedStream();
    assertTrue(source.wasStreamOpened());
    assertFalse(source.wasStreamClosed());

    StringWriter writer = new StringWriter();
    char[] buf = new char[64];
    int read;
    while ((read = reader.read(buf)) != -1) {
      writer.write(buf, 0, read);
    }
    reader.close();
    writer.close();

    assertTrue(source.wasStreamClosed());
    assertEquals(STRING, writer.toString());
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: CharSourceTest
 Method: testLines
 Body: {
    source = new TestCharSource(LINES);

    ImmutableList<String> lines;
    try (Stream<String> linesStream = source.lines()) {
      assertTrue(source.wasStreamOpened());
      assertFalse(source.wasStreamClosed());

      lines = linesStream.collect(toImmutableList());
    }

    assertTrue(source.wasStreamClosed());
    assertEquals(SPLIT_LINES, lines);
  }
 Pattern Name: FocalMethod_Match - Action: lines - Predicate: N/A - Scenario: source

Project: guava
 Class: CharSourceTest
 Method: testReadLines_withProcessor
 Body: {
    TestCharSource lines = new TestCharSource(LINES);
    List<String> list =
        lines.readLines(
            new LineProcessor<List<String>>() {
              List<String> list = Lists.newArrayList();

              @Override
              public boolean processLine(String line) throws IOException {
                list.add(line);
                return true;
              }

              @Override
              public List<String> getResult() {
                return list;
              }
            });
    assertEquals(ImmutableList.of("foo", "bar", "baz", "something"), list);
    assertTrue(lines.wasStreamOpened() && lines.wasStreamClosed());
  }
 Pattern Name: FocalMethod_Match - Action: readLines - Predicate: N/A - Scenario: list

Project: guava
 Class: SynchronizedNavigableMapTest
 Method: testKeySet
 Body: {
    Map<String, Integer> map = create();
    Set<String> keySet = map.keySet();
    assertTrue(keySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) keySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: map

Project: guava
 Class: SynchronizedNavigableMapTest
 Method: testDescendingMap
 Body: {
    NavigableMap<String, Integer> map = create();
    NavigableMap<String, Integer> descendingMap = map.descendingMap();
    assertTrue(descendingMap instanceof SynchronizedNavigableMap);
    assertSame(mutex, ((SynchronizedNavigableMap<String, Integer>) descendingMap).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: descendingMap - Predicate: N/A - Scenario: map

Project: guava
 Class: SynchronizedNavigableMapTest
 Method: testValues
 Body: {
    Map<String, Integer> map = create();
    Collection<Integer> values = map.values();
    assertTrue(values instanceof SynchronizedCollection);
    assertSame(mutex, ((SynchronizedCollection<?>) values).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: values

Project: guava
 Class: SynchronizedNavigableMapTest
 Method: testDescendingKeySet
 Body: {
    NavigableMap<String, Integer> map = create();
    NavigableSet<String> descendingKeySet = map.descendingKeySet();
    assertTrue(descendingKeySet instanceof SynchronizedNavigableSet);
    assertSame(mutex, ((SynchronizedNavigableSet<String>) descendingKeySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: descendingKeySet - Predicate: N/A - Scenario: descendingKeySet

Project: guava
 Class: SynchronizedNavigableMapTest
 Method: testEntrySet
 Body: {
    Map<String, Integer> map = create();
    Set<Entry<String, Integer>> entrySet = map.entrySet();
    assertTrue(entrySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) entrySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: UnsignedLongsTest
 Method: testDivideRemainderEuclideanProperty
 Body: {
    // Use a seed so that the test is deterministic:
    Random r = new Random(0L);
    for (int i = 0; i < 1000000; i++) {
      long dividend = r.nextLong();
      long divisor = r.nextLong();
      // Test that the Euclidean property is preserved:
      assertEquals(
          0,
          dividend
              - (divisor * UnsignedLongs.divide(dividend, divisor)
                  + UnsignedLongs.remainder(dividend, divisor)));
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextLong - Predicate: N/A - Scenario: r

Project: guava
 Class: BasicTests
 Method: testSerialization_multiple
 Body: {
      Collection<String> c = ImmutableList.of("a", "b", "c");
      SerializableTester.reserializeAndAssert(c);
    }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: c

Project: guava
 Class: BasicTests
 Method: testBuilderAddHandlesNullsCorrectly
 Body: {
      ImmutableList.Builder<String> builder = ImmutableList.builder();
      try {
        builder.add((String) null);
        fail("expected NullPointerException");
      } catch (NullPointerException expected) {
      }

      try {
        builder.add((String[]) null);
        fail("expected NullPointerException");
      } catch (NullPointerException expected) {
      }

      try {
        builder.add("a", null, "b");
        fail("expected NullPointerException");
      } catch (NullPointerException expected) {
      }
    }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: BasicTests
 Method: testSerialization_singleton
 Body: {
      Collection<String> c = ImmutableList.of("a");
      SerializableTester.reserializeAndAssert(c);
    }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: c

Project: guava
 Class: BasicTests
 Method: testEquals_immutableList
 Body: {
      Collection<String> c = ImmutableList.of("a", "b", "c");
      assertTrue(c.equals(ImmutableList.of("a", "b", "c")));
      assertFalse(c.equals(ImmutableList.of("a", "c", "b")));
      assertFalse(c.equals(ImmutableList.of("a", "b")));
      assertFalse(c.equals(ImmutableList.of("a", "b", "c", "d")));
    }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: c

Project: guava
 Class: CharSequenceReaderTest
 Method: testMethodsThrowWhenClosed
 Body: {
    CharSequenceReader reader = new CharSequenceReader("");
    reader.close();

    try {
      reader.read();
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.read(new char[10]);
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.read(new char[10], 0, 10);
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.read(CharBuffer.allocate(10));
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.skip(10);
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.ready();
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.mark(10);
      fail();
    } catch (IOException expected) {
    }

    try {
      reader.reset();
      fail();
    } catch (IOException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: close - Predicate: N/A - Scenario: reader

Project: guava
 Class: CharSequenceReaderTest
 Method: testIllegalArguments
 Body: {
    CharSequenceReader reader = new CharSequenceReader("12345");

    char[] buf = new char[10];
    try {
      reader.read(buf, 0, 11);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.read(buf, 10, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.read(buf, 11, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.read(buf, -1, 5);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.read(buf, 5, -1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.read(buf, 0, 11);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }

    try {
      reader.skip(-1);
      fail();
    } catch (IllegalArgumentException expected) {
    }

    try {
      reader.mark(-1);
      fail();
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: read - Predicate: N/A - Scenario: reader

Project: guava
 Class: PopulatedCachesTest
 Method: testEntrySet_populated
 Body: {
    for (LoadingCache<Object, Object> cache : caches()) {
      Set<Entry<Object, Object>> entries = cache.asMap().entrySet();
      List<Entry<Object, Object>> warmed = warmUp(cache, WARMUP_MIN, WARMUP_MAX);

      Set<?> expected = Maps.newHashMap(cache.asMap()).entrySet();
      assertThat(entries).containsExactlyElementsIn((Collection<Entry<Object, Object>>) expected);
      assertThat(entries.toArray())
          .asList()
          .containsExactlyElementsIn((Collection<Object>) expected);
      assertThat(entries.toArray(new Entry[0]))
          .asList()
          .containsExactlyElementsIn((Collection<Entry>) expected);

      new EqualsTester()
          .addEqualityGroup(cache.asMap().entrySet(), entries)
          .addEqualityGroup(ImmutableSet.of())
          .testEquals();
      assertEquals(WARMUP_SIZE, entries.size());
      for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
        Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);
        assertTrue(entries.contains(newEntry));
        assertTrue(entries.remove(newEntry));
        assertFalse(entries.remove(newEntry));
        assertFalse(entries.contains(newEntry));
      }
      checkEmpty(entries);
      checkEmpty(cache);
    }
  }
 Pattern Name: FocalMethod_Match - Action: containsExactlyElementsIn - Predicate: N/A - Scenario: entries

Project: guava
 Class: EndpointPairTest
 Method: testUnorderedEndpointPair
 Body: {
    EndpointPair<String> unordered = EndpointPair.unordered("chicken", "egg");
    assertThat(unordered.isOrdered()).isFalse();
    assertThat(unordered).containsExactly("chicken", "egg");
    assertThat(ImmutableSet.of(unordered.nodeU(), unordered.nodeV()))
        .containsExactly("chicken", "egg");
    assertThat(unordered.adjacentNode(unordered.nodeU())).isEqualTo(unordered.nodeV());
    assertThat(unordered.adjacentNode(unordered.nodeV())).isEqualTo(unordered.nodeU());
    assertThat(unordered.toString()).contains("chicken");
    assertThat(unordered.toString()).contains("egg");
  }
 Pattern Name: FocalMethod_Match - Action: unordered - Predicate: N/A - Scenario: unordered

Project: guava
 Class: AtomicDoubleTest
 Method: testDistinctZeros
 Body: {
    AtomicDouble at = new AtomicDouble(+0.0);
    assertFalse(at.compareAndSet(-0.0, 7.0));
    assertFalse(at.weakCompareAndSet(-0.0, 7.0));
    assertBitEquals(+0.0, at.get());
    assertTrue(at.compareAndSet(+0.0, -0.0));
    assertBitEquals(-0.0, at.get());
    assertFalse(at.compareAndSet(+0.0, 7.0));
    assertFalse(at.weakCompareAndSet(+0.0, 7.0));
    assertBitEquals(-0.0, at.get());
  }
 Pattern Name: FocalMethod_Match - Action: compareAndSet - Predicate: N/A - Scenario: at

Project: guava
 Class: AtomicDoubleArrayTest
 Method: testConstructor2NPE
 Body: {
    double[] a = null;
    try {
      new AtomicDoubleArray(a);
      fail();
    } catch (NullPointerException success) {
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: a

Project: guava
 Class: BloomFilterTest
 Method: testExpectedFpp
 Body: {
    BloomFilter<Object> bf = BloomFilter.create(HashTestUtils.BAD_FUNNEL, 10, 0.03);
    double fpp = bf.expectedFpp();
    assertEquals(0.0, fpp);
    // usually completed in less than 200 iterations
    while (fpp != 1.0) {
      boolean changed = bf.put(new Object());
      double newFpp = bf.expectedFpp();
      // if changed, the new fpp is strictly higher, otherwise it is the same
      assertTrue(changed ? newFpp > fpp : newFpp == fpp);
      fpp = newFpp;
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: changed

Project: guava
 Class: BloomFilterTest
 Method: testCustomSerialization
 Body: {
    Funnel<byte[]> funnel = Funnels.byteArrayFunnel();
    BloomFilter<byte[]> bf = BloomFilter.create(funnel, 100);
    for (int i = 0; i < 100; i++) {
      bf.put(Ints.toByteArray(i));
    }

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    bf.writeTo(out);

    assertEquals(bf, BloomFilter.readFrom(new ByteArrayInputStream(out.toByteArray()), funnel));
  }
 Pattern Name: FocalMethod_Match - Action: writeTo - Predicate: N/A - Scenario: out

Project: guava
 Class: BloomFilterTest
 Method: testLargeBloomFilterDoesntOverflow
 Body: {
    long numBits = Integer.MAX_VALUE;
    numBits++;

    LockFreeBitArray bitArray = new LockFreeBitArray(numBits);
    assertTrue(
        "BitArray.bitSize() must return a positive number, but was " + bitArray.bitSize(),
        bitArray.bitSize() > 0);

    // Ideally we would also test the bitSize() overflow of this BF, but it runs out of heap space
    // BloomFilter.create(Funnels.unencodedCharsFunnel(), 244412641, 1e-11);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: numBits

Project: guava
 Class: BloomFilterTest
 Method: testCopy
 Body: {
    BloomFilter<String> original = BloomFilter.create(Funnels.unencodedCharsFunnel(), 100);
    BloomFilter<String> copy = original.copy();
    assertNotSame(original, copy);
    assertEquals(original, copy);
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: copy

Project: guava
 Class: AbstractServiceTest
 Method: testFailureCause_throwsIfNotFailed
 Body: {
    StopFailingService service = new StopFailingService();
    try {
      service.failureCause();
      fail();
    } catch (IllegalStateException expected) {
    }
    service.startAsync().awaitRunning();
    try {
      service.failureCause();
      fail();
    } catch (IllegalStateException expected) {
    }
    try {
      service.stopAsync().awaitTerminated();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(EXCEPTION, service.failureCause());
      assertEquals(EXCEPTION, e.getCause());
    }
  }
 Pattern Name: FocalMethod_Match - Action: failureCause - Predicate: N/A - Scenario: e

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: ConfigurableSimpleUndirectedGraphTest
 Method: addEdge_selfLoop
 Body: {
    try {
      putEdge(N1, N1);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ElementTest
 Method: testPrivateMethod
 Body: {
    Element element = A.method("privateMethod");
    assertFalse(element.isAbstract());
    assertTrue(element.isPrivate());
    assertFalse(element.isPackagePrivate());
    assertFalse(element.isPublic());
    assertFalse(element.isProtected());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isAbstract - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testConstructor
 Body: {
    Element element = A.constructor();
    assertTrue(element.isPublic());
    assertFalse(element.isPackagePrivate());
    assertFalse(element.isAbstract());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPublic - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testPrivateField
 Body: {
    Element element = A.field("privateField");
    assertTrue(element.isPrivate());
    assertFalse(element.isAbstract());
    assertFalse(element.isPackagePrivate());
    assertFalse(element.isProtected());
    assertFalse(element.isPublic());
    assertFalse(element.isFinal());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testProtectedField
 Body: {
    Element element = A.field("protectedField");
    assertFalse(element.isPrivate());
    assertFalse(element.isPackagePrivate());
    assertTrue(element.isProtected());
    assertFalse(element.isPublic());
    assertFalse(element.isFinal());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testAbstractMethod
 Body: {
    Element element = A.method("abstractMethod");
    assertTrue(element.isPackagePrivate());
    assertTrue(element.isAbstract());
    assertFalse(element.isFinal());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPackagePrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testFinalField
 Body: {
    Element element = A.field("finalField");
    assertTrue(element.isFinal());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isFinal - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testProtectedMethod
 Body: {
    Element element = A.method("protectedMethod");
    assertFalse(element.isAbstract());
    assertFalse(element.isPrivate());
    assertFalse(element.isPackagePrivate());
    assertFalse(element.isFinal());
    assertFalse(element.isPublic());
    assertTrue(element.isProtected());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isAbstract - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testFinalMethod
 Body: {
    Element element = A.method("publicFinalMethod");
    assertFalse(element.isAbstract());
    assertFalse(element.isPrivate());
    assertTrue(element.isFinal());
    assertTrue(element.isPublic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isAbstract - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testPublicField
 Body: {
    Element element = A.field("publicField");
    assertFalse(element.isPrivate());
    assertFalse(element.isPackagePrivate());
    assertFalse(element.isProtected());
    assertTrue(element.isPublic());
    assertFalse(element.isFinal());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testPackagePrivateField
 Body: {
    Element element = A.field("packagePrivateField");
    assertFalse(element.isPrivate());
    assertTrue(element.isPackagePrivate());
    assertFalse(element.isProtected());
    assertFalse(element.isPublic());
    assertFalse(element.isFinal());
    assertFalse(element.isStatic());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: ElementTest
 Method: testOverridableMethod
 Body: {
    Element element = A.method("overridableMethod");
    assertTrue(element.isPackagePrivate());
    assertFalse(element.isAbstract());
    assertFalse(element.isFinal());
    assertTrue(element.isAnnotationPresent(Tested.class));
  }
 Pattern Name: FocalMethod_Match - Action: isPackagePrivate - Predicate: N/A - Scenario: element

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: EmptyCachesTest
 Method: testEntrySet_nullToArray
 Body: {
    for (LoadingCache<Object, Object> cache : caches()) {
      Set<Entry<Object, Object>> entries = cache.asMap().entrySet();
      try {
        entries.toArray((Entry<Object, Object>[]) null);
        fail();
      } catch (NullPointerException expected) {
      }
      checkEmpty(cache);
    }
  }
 Pattern Name: FocalMethod_Match - Action: toArray - Predicate: N/A - Scenario: entries

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testNameFormatWithPercentD_custom
 Body: {
    String format = "super-duper-thread-%d";
    ThreadFactory factory = builder.setNameFormat(format).build();
    for (int i = 0; i < 11; i++) {
      assertEquals(rootLocaleFormat(format, i), factory.newThread(monitoredRunnable).getName());
    }
  }
 Pattern Name: FocalMethod_Match - Action: setNameFormat - Predicate: N/A - Scenario: format

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testNameFormatWithPercentS_custom
 Body: {
    String format = "super-duper-thread-%s";
    ThreadFactory factory = builder.setNameFormat(format).build();
    for (int i = 0; i < 11; i++) {
      assertEquals(rootLocaleFormat(format, i), factory.newThread(monitoredRunnable).getName());
    }
  }
 Pattern Name: FocalMethod_Match - Action: setNameFormat - Predicate: N/A - Scenario: format

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testBuildMutateBuild
 Body: {
    ThreadFactory factory1 = builder.setPriority(1).build();
    assertEquals(1, factory1.newThread(monitoredRunnable).getPriority());

    ThreadFactory factory2 = builder.setPriority(2).build();
    assertEquals(1, factory1.newThread(monitoredRunnable).getPriority());
    assertEquals(2, factory2.newThread(monitoredRunnable).getPriority());
  }
 Pattern Name: FocalMethod_Match - Action: newThread - Predicate: N/A - Scenario: factory1

Project: guava
 Class: ListMultimapAsMapTester
 Method: testAsMapValuesImplementList
 Body: {
    for (Collection<V> valueCollection : multimap().asMap().values()) {
      assertTrue(valueCollection instanceof List);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: valueCollection

Project: guava
 Class: ListMultimapAsMapTester
 Method: testAsMapGetImplementsList
 Body: {
    for (K key : multimap().keySet()) {
      assertTrue(multimap().asMap().get(key) instanceof List);
    }
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: key

Project: guava
 Class: MultisetAddTester
 Method: testAddSeveralTimes
 Body: {
    int originalCount = getMultiset().count(e0());
    assertEquals(originalCount, getMultiset().add(e0(), 2));
    assertTrue(getMultiset().add(e0()));
    assertEquals(originalCount + 3, getMultiset().add(e0(), 1));
    assertEquals(originalCount + 4, getMultiset().count(e0()));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: originalCount

Project: guava
 Class: HelpersTest_gwt
 Method: testAssertContentsInOrder
 Body: {
  com.google.common.collect.testing.HelpersTest testCase = new com.google.common.collect.testing.HelpersTest();
  testCase.testAssertContentsInOrder();
}
 Pattern Name: FocalMethod_Match - Action: testAssertContentsInOrder - Predicate: N/A - Scenario: testCase

Project: guava
 Class: HelpersTest_gwt
 Method: testAssertEqualInOrder
 Body: {
  com.google.common.collect.testing.HelpersTest testCase = new com.google.common.collect.testing.HelpersTest();
  testCase.testAssertEqualInOrder();
}
 Pattern Name: FocalMethod_Match - Action: testAssertEqualInOrder - Predicate: N/A - Scenario: testCase

Project: guava
 Class: HelpersTest_gwt
 Method: testAssertContainsAllOf
 Body: {
  com.google.common.collect.testing.HelpersTest testCase = new com.google.common.collect.testing.HelpersTest();
  testCase.testAssertContainsAllOf();
}
 Pattern Name: FocalMethod_Match - Action: testAssertContainsAllOf - Predicate: N/A - Scenario: testCase

Project: guava
 Class: HelpersTest_gwt
 Method: testAssertContains
 Body: {
  com.google.common.collect.testing.HelpersTest testCase = new com.google.common.collect.testing.HelpersTest();
  testCase.testAssertContains();
}
 Pattern Name: FocalMethod_Match - Action: testAssertContains - Predicate: N/A - Scenario: testCase

Project: guava
 Class: UnsignedLongTest
 Method: testToStringRadixQuick
 Body: {
    int[] radices = {2, 3, 5, 7, 10, 12, 16, 21, 31, 36};
    for (int radix : radices) {
      for (long l : TEST_LONGS) {
        UnsignedLong value = UnsignedLong.fromLongBits(l);
        assertEquals(value.bigIntegerValue().toString(radix), value.toString(radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: UnsignedLongTest
 Method: testToStringRadix
 Body: {
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      for (long l : TEST_LONGS) {
        UnsignedLong value = UnsignedLong.fromLongBits(l);
        assertEquals(value.bigIntegerValue().toString(radix), value.toString(radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: addEdge_existingEdgeBetweenDifferentNodes_selfLoops
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N2, E11);
      fail("Reusing an existing self-loop edge to connect different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    try {
      addEdge(N2, N2, E11);
      fail("Reusing an existing self-loop edge to make a different self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    addEdge(N1, N2, E12);
    try {
      addEdge(N1, N1, E12);
      fail("Reusing an existing edge to add a self-loop edge between different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ResourcesTest
 Method: testGetResource_relativePath_notFound
 Body: {
    try {
      Resources.getResource(getClass(), "com/google/common/io/testdata/i18n.txt");
      fail();
    } catch (IllegalArgumentException e) {
      assertThat(e)
          .hasMessage(
              "resource com/google/common/io/testdata/i18n.txt"
                  + " relative to com.google.common.io.ResourcesTest not found.");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getResource - Predicate: N/A - Scenario: e

Project: guava
 Class: ResourcesTest
 Method: testGetResource_notFound
 Body: {
    try {
      Resources.getResource("no such resource");
      fail();
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessage("resource no such resource not found.");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getResource - Predicate: N/A - Scenario: e

Project: guava
 Class: MultimapPutAllMultimapTester
 Method: testPutAll
 Body: {
    Multimap<K, V> source =
        getSubjectGenerator().create(Helpers.mapEntry(k0(), v3()), Helpers.mapEntry(k3(), v3()));
    assertTrue(multimap().putAll(source));
    assertTrue(multimap().containsEntry(k0(), v3()));
    assertTrue(multimap().containsEntry(k3(), v3()));
  }
 Pattern Name: FocalMethod_Match - Action: putAll - Predicate: N/A - Scenario: source

Project: guava
 Class: SuppliersTest
 Method: testCompose
 Body: {
    Supplier<Integer> fiveSupplier =
        new Supplier<Integer>() {
          @Override
          public Integer get() {
            return 5;
          }
        };

    Function<Number, Integer> intValueFunction =
        new Function<Number, Integer>() {
          @Override
          public Integer apply(Number x) {
            return x.intValue();
          }
        };

    Supplier<Integer> squareSupplier = Suppliers.compose(intValueFunction, fiveSupplier);

    assertEquals(Integer.valueOf(5), squareSupplier.get());
  }
 Pattern Name: FocalMethod_Match - Action: compose - Predicate: N/A - Scenario: intValueFunction

Project: guava
 Class: CharSourceTester
 Method: testOpenStream
 Body: {
    Reader reader = source.openStream();

    StringWriter writer = new StringWriter();
    char[] buf = new char[64];
    int read;
    while ((read = reader.read(buf)) != -1) {
      writer.write(buf, 0, read);
    }
    reader.close();
    writer.close();

    assertExpectedString(writer.toString());
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: CharSourceTester
 Method: testOpenBufferedStream
 Body: {
    BufferedReader reader = source.openBufferedStream();

    StringWriter writer = new StringWriter();
    char[] buf = new char[64];
    int read;
    while ((read = reader.read(buf)) != -1) {
      writer.write(buf, 0, read);
    }
    reader.close();
    writer.close();

    assertExpectedString(writer.toString());
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: GraphsTest
 Method: builder_expectedNodeCount_negative
 Body: {
    try {
      NetworkBuilder.directed().expectedNodeCount(-1);
      fail("Should have rejected negative expected node count.");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_NEGATIVE_COUNT);
    }
  }
 Pattern Name: FocalMethod_Match - Action: directed - Predicate: N/A - Scenario: e

Project: guava
 Class: GraphsTest
 Method: builder_expectedEdgeCount_negative
 Body: {
    try {
      NetworkBuilder.directed().expectedEdgeCount(-1);
      fail("Should have rejected negative expected edge count.");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_NEGATIVE_COUNT);
    }
  }
 Pattern Name: FocalMethod_Match - Action: directed - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableSimpleUndirectedNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ImmutableMultimapTest
 Method: testBuilder_withImmutableEntryAndNullContents
 Body: {
    Builder<String, Integer> builder = new Builder<>();
    try {
      builder.put(Maps.immutableEntry("one", (Integer) null));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.put(Maps.immutableEntry((String) null, 1));
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: builder

Project: guava
 Class: SupplementalMonitorTest
 Method: testOccupiedMethods
 Body: {
    Monitor monitor = new Monitor();
    verifyOccupiedMethodsInCurrentThread(monitor, false, false, 0);
    verifyOccupiedMethodsInAnotherThread(monitor, false, false, 0);
    monitor.enter();
    try {
      verifyOccupiedMethodsInCurrentThread(monitor, true, true, 1);
      verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);
      monitor.enter();
      try {
        verifyOccupiedMethodsInCurrentThread(monitor, true, true, 2);
        verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);
      } finally {
        monitor.leave();
      }
      verifyOccupiedMethodsInCurrentThread(monitor, true, true, 1);
      verifyOccupiedMethodsInAnotherThread(monitor, true, false, 0);
    } finally {
      monitor.leave();
    }
    verifyOccupiedMethodsInCurrentThread(monitor, false, false, 0);
    verifyOccupiedMethodsInAnotherThread(monitor, false, false, 0);
  }
 Pattern Name: FocalMethod_Match - Action: enter - Predicate: N/A - Scenario: monitor

Project: guava
 Class: InternetDomainNameTest
 Method: testPublicSuffixExclusion
 Body: {
    InternetDomainName domain = InternetDomainName.from("foo.city.yokohama.jp");
    assertTrue(domain.hasPublicSuffix());
    assertEquals("yokohama.jp", domain.publicSuffix().toString());

    // Behold the weirdness!
    assertFalse(domain.publicSuffix().isPublicSuffix());
  }
 Pattern Name: FocalMethod_Match - Action: hasPublicSuffix - Predicate: N/A - Scenario: domain

Project: guava
 Class: InternetDomainNameTest
 Method: testInvalidTopPrivateDomain
 Body: {
    ImmutableSet<String> badCookieDomains = ImmutableSet.of("co.uk", "foo", "com");

    for (String domain : badCookieDomains) {
      try {
        InternetDomainName.from(domain).topPrivateDomain();
        fail(domain);
      } catch (IllegalStateException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: domain

Project: guava
 Class: InternetDomainNameTest
 Method: testRegistrySuffixMultipleUnders
 Body: {
    // PSL has both *.uk and *.sch.uk; the latter should win.
    // See http://code.google.com/p/guava-libraries/issues/detail?id=1176

    InternetDomainName domain = InternetDomainName.from("www.essex.sch.uk");
    assertTrue(domain.hasRegistrySuffix());
    assertEquals("essex.sch.uk", domain.registrySuffix().toString());
    assertEquals("www.essex.sch.uk", domain.topDomainUnderRegistrySuffix().toString());
  }
 Pattern Name: FocalMethod_Match - Action: hasRegistrySuffix - Predicate: N/A - Scenario: domain

Project: guava
 Class: InternetDomainNameTest
 Method: testRegistrySuffixExclusion
 Body: {
    InternetDomainName domain = InternetDomainName.from("foo.city.yokohama.jp");
    assertTrue(domain.hasRegistrySuffix());
    assertEquals("yokohama.jp", domain.registrySuffix().toString());

    // Behold the weirdness!
    assertFalse(domain.registrySuffix().isRegistrySuffix());
  }
 Pattern Name: FocalMethod_Match - Action: hasRegistrySuffix - Predicate: N/A - Scenario: domain

Project: guava
 Class: InternetDomainNameTest
 Method: testPublicSuffixMultipleUnders
 Body: {
    // PSL has both *.uk and *.sch.uk; the latter should win.
    // See http://code.google.com/p/guava-libraries/issues/detail?id=1176

    InternetDomainName domain = InternetDomainName.from("www.essex.sch.uk");
    assertTrue(domain.hasPublicSuffix());
    assertEquals("essex.sch.uk", domain.publicSuffix().toString());
    assertEquals("www.essex.sch.uk", domain.topPrivateDomain().toString());
  }
 Pattern Name: FocalMethod_Match - Action: hasPublicSuffix - Predicate: N/A - Scenario: domain

Project: guava
 Class: InternetDomainNameTest
 Method: testValidTopPrivateDomain
 Body: {
    InternetDomainName googleDomain = InternetDomainName.from("google.com");

    assertEquals(googleDomain, googleDomain.topPrivateDomain());
    assertEquals(googleDomain, googleDomain.child("mail").topPrivateDomain());
    assertEquals(googleDomain, googleDomain.child("foo.bar").topPrivateDomain());
  }
 Pattern Name: FocalMethod_Match - Action: topPrivateDomain - Predicate: N/A - Scenario: googleDomain

Project: guava
 Class: SipHashFunctionTest
 Method: testVectors
 Body: {
    for (int i = 0; i < EXPECTED.length; ++i) {
      byte[] msg = new byte[i];
      for (int j = 0; j < i; ++j) {
        msg[j] = (byte) j;
      }
      assertSip(msg, EXPECTED[i]);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: msg

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: NewCustomTableTest
 Method: testRowOrdering
 Body: {
    table = create("foo", 3, 'a', "bar", 1, 'b', "foo", 2, 'c');
    assertThat(table.row("foo").keySet()).containsExactly(2, 3).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: row - Predicate: N/A - Scenario: table

Project: guava
 Class: NewCustomTableTest
 Method: testRowKeySetOrdering
 Body: {
    table = create("foo", 3, 'a', "bar", 1, 'b', "foo", 2, 'c');
    assertThat(table.rowKeySet()).containsExactly("foo", "bar").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: MultiReaderTest
 Method: testReady
 Body: {
    CharSource source = newCharSource("a");
    Iterable<? extends CharSource> list = ImmutableList.of(source, source);
    Reader joinedReader = CharSource.concat(list).openStream();

    assertTrue(joinedReader.ready());
    assertEquals('a', joinedReader.read());
    assertEquals('a', joinedReader.read());
    assertEquals(-1, joinedReader.read());
    assertFalse(joinedReader.ready());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: source

Project: guava
 Class: MultiReaderTest
 Method: testSimple
 Body: {
    String testString = "abcdefgh";
    CharSource source = newCharSource(testString);
    Reader joinedReader = CharSource.concat(source, source).openStream();

    String expectedString = testString + testString;
    assertEquals(expectedString, CharStreams.toString(joinedReader));
  }
 Pattern Name: FocalMethod_Match - Action: concat - Predicate: N/A - Scenario: source

Project: guava
 Class: MultiReaderTest
 Method: testSkipZero
 Body: {
    CharSource source = newCharSource("a");
    Iterable<CharSource> list = ImmutableList.of(source, source);
    Reader joinedReader = CharSource.concat(list).openStream();

    assertEquals(0, joinedReader.skip(0));
    assertEquals('a', joinedReader.read());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: source

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedTimed_RuntimeException
 Body: {
    try {
      getChecked(RUNTIME_EXCEPTION_FUTURE, TwoArgConstructorException.class, 0, SECONDS);
      fail();
    } catch (RuntimeException expected) {
      assertEquals(RUNTIME_EXCEPTION, expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: FuturesGetCheckedTest
 Method: testGetCheckedUntimed_RuntimeException
 Body: {
    try {
      getChecked(RUNTIME_EXCEPTION_FUTURE, TwoArgConstructorException.class);
      fail();
    } catch (RuntimeException expected) {
      assertEquals(RUNTIME_EXCEPTION, expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: ConcurrentHashMultisetBasherTest
 Method: testAddAndRemove_MapMakerMap
 Body: {
    MapMaker mapMaker = new MapMaker();
    // force MapMaker to use its own MapMakerInternalMap
    mapMaker.useCustomMap = true;
    testAddAndRemove(mapMaker.<String, AtomicInteger>makeMap());
  }
 Pattern Name: FocalMethod_Match - Action: makeMap - Predicate: N/A - Scenario: mapMaker

Project: guava
 Class: ImmutableClassToInstanceMapTest
 Method: testPrimitiveAndWrapper
 Body: {
    ImmutableClassToInstanceMap<Number> ictim =
        new ImmutableClassToInstanceMap.Builder<Number>()
            .put(Integer.class, 0)
            .put(int.class, 1)
            .build();
    assertEquals(2, ictim.size());

    assertEquals(0, (int) ictim.getInstance(Integer.class));
    assertEquals(1, (int) ictim.getInstance(int.class));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: ictim

Project: guava
 Class: FloatsTest
 Method: testStringConverter_reverse
 Body: {
    Converter<String, Float> converter = Floats.stringConverter();
    assertEquals("1.0", converter.reverse().convert(1.0f));
    assertEquals("0.0", converter.reverse().convert(0.0f));
    assertEquals("-1.0", converter.reverse().convert(-1.0f));
    assertEquals("1000000.0", converter.reverse().convert(1e6f));
    assertEquals("1.0E-6", converter.reverse().convert(1e-6f));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: converter

Project: guava
 Class: FloatsTest
 Method: testStringConverter_convert
 Body: {
    Converter<String, Float> converter = Floats.stringConverter();
    assertEquals((Float) 1.0f, converter.convert("1.0"));
    assertEquals((Float) 0.0f, converter.convert("0.0"));
    assertEquals((Float) (-1.0f), converter.convert("-1.0"));
    assertEquals((Float) 1.0f, converter.convert("1"));
    assertEquals((Float) 0.0f, converter.convert("0"));
    assertEquals((Float) (-1.0f), converter.convert("-1"));
    assertEquals((Float) 1e6f, converter.convert("1e6"));
    assertEquals((Float) 1e-6f, converter.convert("1e-6"));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: converter

Project: guava
 Class: MoreFilesTest
 Method: testDeleteRecursively_nonDirectoryFile
 Body: {
    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {
      Path file = fs.getPath("dir/a");
      assertTrue(Files.isRegularFile(file, NOFOLLOW_LINKS));

      MoreFiles.deleteRecursively(file);

      assertFalse(Files.exists(file, NOFOLLOW_LINKS));

      Path symlink = fs.getPath("/symlinktodir");
      assertTrue(Files.isSymbolicLink(symlink));

      Path realSymlinkTarget = symlink.toRealPath();
      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));

      MoreFiles.deleteRecursively(symlink);

      assertFalse(Files.exists(symlink, NOFOLLOW_LINKS));
      assertTrue(Files.isDirectory(realSymlinkTarget, NOFOLLOW_LINKS));
    }
  }
 Pattern Name: FocalMethod_Match - Action: isDirectory - Predicate: N/A - Scenario: realSymlinkTarget

Project: guava
 Class: MoreFilesTest
 Method: testByteSource_size_ofSymlinkToRegularFile
 Body: {
    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {
      Path file = fs.getPath("file");
      Files.write(file, new byte[10]);
      Path link = fs.getPath("link");
      Files.createSymbolicLink(link, file);

      ByteSource source = MoreFiles.asByteSource(link);

      assertEquals(10L, (long) source.sizeIfKnown().get());
      assertEquals(10L, source.size());
    }
  }
 Pattern Name: FocalMethod_Match - Action: sizeIfKnown - Predicate: N/A - Scenario: source

Project: guava
 Class: MoreFilesTest
 Method: testByteSource_size_ofSymlinkToRegularFile_nofollowLinks
 Body: {
    try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {
      Path file = fs.getPath("file");
      Files.write(file, new byte[10]);
      Path link = fs.getPath("link");
      Files.createSymbolicLink(link, file);

      ByteSource source = MoreFiles.asByteSource(link, NOFOLLOW_LINKS);

      assertThat(source.sizeIfKnown()).isAbsent();

      try {
        source.size();
        fail();
      } catch (IOException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: sizeIfKnown - Predicate: N/A - Scenario: source

Project: guava
 Class: MultimapBuilderTest
 Method: testSerialization
 Body: {
    for (MultimapBuilderWithKeys<?> builderWithKeys :
        ImmutableList.of(
            MultimapBuilder.hashKeys(),
            MultimapBuilder.linkedHashKeys(),
            MultimapBuilder.treeKeys(),
            MultimapBuilder.enumKeys(RoundingMode.class))) {
      for (MultimapBuilder<?, ?> builder :
          ImmutableList.of(
              builderWithKeys.arrayListValues(),
              builderWithKeys.linkedListValues(),
              builderWithKeys.hashSetValues(),
              builderWithKeys.linkedHashSetValues(),
              builderWithKeys.treeSetValues(),
              builderWithKeys.enumSetValues(RoundingMode.class))) {
        /*
         * Temporarily inlining SerializableTester here for obscure internal reasons.
         */
        reserializeAndAssert(builder.build());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: arrayListValues - Predicate: N/A - Scenario: builder

Project: guava
 Class: NavigableSetNavigationTester
 Method: testDescendingNavigation
 Body: {
    List<E> descending = new ArrayList<E>();
    for (Iterator<E> i = navigableSet.descendingIterator(); i.hasNext(); ) {
      descending.add(i.next());
    }
    Collections.reverse(descending);
    assertEquals(values, descending);
  }
 Pattern Name: FocalMethod_Match - Action: descendingIterator - Predicate: N/A - Scenario: descending

Project: guava
 Class: StatsTest
 Method: testMin
 Body: {
    try {
      EMPTY_STATS_VARARGS.min();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    try {
      EMPTY_STATS_ITERABLE.min();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
    assertThat(ONE_VALUE_STATS.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
    assertThat(Stats.of(POSITIVE_INFINITY).min()).isPositiveInfinity();
    assertThat(Stats.of(NEGATIVE_INFINITY).min()).isNegativeInfinity();
    assertThat(Stats.of(NaN).min()).isNaN();
    assertThat(TWO_VALUES_STATS.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_VARARGS.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
    // For datasets of many double values created from an accumulator snapshot, we test many
    // combinations of finite and non-finite values:
    for (ManyValues values : ALL_MANY_VALUES) {
      StatsAccumulator accumulator = new StatsAccumulator();
      accumulator.addAll(values.asIterable());
      double min = accumulator.snapshot().min();
      if (values.hasAnyNaN()) {
        assertThat(min).named("min of " + values).isNaN();
      } else if (values.hasAnyNegativeInfinity()) {
        assertThat(min).named("min of " + values).isNegativeInfinity();
      } else {
        assertThat(min).named("min of " + values).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
      }
    }
    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min())
        .isWithin(ALLOWED_ERROR)
        .of(INTEGER_MANY_VALUES_MIN);
    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min())
        .isWithin(ALLOWED_ERROR)
        .of(INTEGER_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min())
        .isWithin(ALLOWED_ERROR)
        .of(LONG_MANY_VALUES_MIN);
    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min())
        .isWithin(ALLOWED_ERROR)
        .of(LONG_MANY_VALUES_MIN);
  }
 Pattern Name: FocalMethod_Match - Action: asIterable - Predicate: N/A - Scenario: values

Project: guava
 Class: CreationTests
 Method: testEmptyBuilder
 Body: {
      ImmutableBiMap<String, Integer> map = new Builder<String, Integer>().build();
      assertEquals(Collections.<String, Integer>emptyMap(), map);
      assertEquals(Collections.<Integer, String>emptyMap(), map.inverse());
      assertSame(ImmutableBiMap.of(), map);
    }
 Pattern Name: FocalMethod_Match - Action: inverse - Predicate: N/A - Scenario: map

Project: guava
 Class: CreationTests
 Method: testOfWithDuplicateKey
 Body: {
      try {
        ImmutableBiMap.of("one", 1, "one", 1);
        fail();
      } catch (IllegalArgumentException expected) {
        assertThat(expected.getMessage()).contains("one");
      }
    }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: CreationTests
 Method: testCopyOfEmptyMap
 Body: {
      ImmutableBiMap<String, Integer> copy =
          ImmutableBiMap.copyOf(Collections.<String, Integer>emptyMap());
      assertEquals(Collections.<String, Integer>emptyMap(), copy);
      assertSame(copy, ImmutableBiMap.copyOf(copy));
      assertSame(ImmutableBiMap.of(), copy);
    }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: copy

Project: guava
 Class: CollectionCreationTester
 Method: testCreateWithNull_supported
 Body: {
    E[] array = createArrayWithNullElement();
    collection = getSubjectGenerator().create(array);
    expectContents(array);
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: MutableClassToInstanceMapTest
 Method: testPutAndGetInstance
 Body: {
    assertNull(map.putInstance(Integer.class, new Integer(5)));

    Integer oldValue = map.putInstance(Integer.class, new Integer(7));
    assertEquals(5, (int) oldValue);

    Integer newValue = map.getInstance(Integer.class);
    assertEquals(7, (int) newValue);

    // Won't compile: map.putInstance(Double.class, new Long(42));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: newValue

Project: guava
 Class: ClassPathTest
 Method: testGetSimpleName
 Body: {
    ClassLoader classLoader = getClass().getClassLoader();
    assertEquals("Foo", new ClassInfo("Foo.class", classLoader).getSimpleName());
    assertEquals("Foo", new ClassInfo("a/b/Foo.class", classLoader).getSimpleName());
    assertEquals("Foo", new ClassInfo("a/b/Bar$Foo.class", classLoader).getSimpleName());
    assertEquals("", new ClassInfo("a/b/Bar$1.class", classLoader).getSimpleName());
    assertEquals("Foo", new ClassInfo("a/b/Bar$Foo.class", classLoader).getSimpleName());
    assertEquals("", new ClassInfo("a/b/Bar$1.class", classLoader).getSimpleName());
    assertEquals("Local", new ClassInfo("a/b/Bar$1Local.class", classLoader).getSimpleName());
  }
 Pattern Name: FocalMethod_Match - Action: getSimpleName - Predicate: N/A - Scenario: classLoader

Project: guava
 Class: ClassPathTest
 Method: testExistsThrowsSecurityException
 Body: {
    SecurityManager oldSecurityManager = System.getSecurityManager();
    try {
      doTestExistsThrowsSecurityException();
    } finally {
      System.setSecurityManager(oldSecurityManager);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setSecurityManager - Predicate: N/A - Scenario: oldSecurityManager

Project: guava
 Class: ClassPathTest
 Method: testGetClassPathUrls
 Body: {
    String oldPathSeparator = PATH_SEPARATOR.value();
    String oldClassPath = JAVA_CLASS_PATH.value();
    System.setProperty(PATH_SEPARATOR.key(), ":");
    System.setProperty(
        JAVA_CLASS_PATH.key(),
        Joiner.on(":")
            .join(
                "relative/path/to/some.jar",
                "/absolute/path/to/some.jar",
                "relative/path/to/class/root",
                "/absolute/path/to/class/root"));
    try {
      ImmutableList<URL> urls = ClassPath.Scanner.parseJavaClassPath();

      assertThat(urls.get(0).getProtocol()).isEqualTo("file");
      assertThat(urls.get(0).getAuthority()).isNull();
      assertThat(urls.get(0).getPath()).endsWith("/relative/path/to/some.jar");

      assertThat(urls.get(1)).isEqualTo(new URL("file:///absolute/path/to/some.jar"));

      assertThat(urls.get(2).getProtocol()).isEqualTo("file");
      assertThat(urls.get(2).getAuthority()).isNull();
      assertThat(urls.get(2).getPath()).endsWith("/relative/path/to/class/root");

      assertThat(urls.get(3)).isEqualTo(new URL("file:///absolute/path/to/class/root"));

      assertThat(urls).hasSize(4);
    } finally {
      System.setProperty(PATH_SEPARATOR.key(), oldPathSeparator);
      System.setProperty(JAVA_CLASS_PATH.key(), oldClassPath);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setProperty - Predicate: N/A - Scenario: oldPathSeparator

Project: guava
 Class: FuturesTest
 Method: testMakeChecked_propagatesFailedMappers
 Body: {
    SettableFuture<String> future = SettableFuture.create();

    CheckedFuture<String, TestException> checked =
        makeChecked(
            future,
            new Function<Exception, TestException>() {
              @Override
              public TestException apply(Exception from) {
                throw new NullPointerException();
              }
            });

    future.setException(new Exception("failed"));

    try {
      checked.checkedGet();
      fail();
    } catch (NullPointerException expected) {
    }

    try {
      checked.checkedGet(5, SECONDS);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_genericsHierarchy_AsyncFunction
 Body: {
    ListenableFuture<FooChild> future = immediateFuture(null);
    final BarChild barChild = new BarChild();
    AsyncFunction<Foo, BarChild> function =
        new AsyncFunction<Foo, BarChild>() {
          @Override
          public AbstractFuture<BarChild> apply(Foo unused) {
            AbstractFuture<BarChild> future = new AbstractFuture<BarChild>() {};
            future.set(barChild);
            return future;
          }
        };
    Bar bar = getDone(transformAsync(future, function, directExecutor()));
    assertSame(barChild, bar);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_logging_error
 Body: {
    assertEquals(
        newArrayList((Object) null),
        getDone(successfulAsList(immediateFailedFuture(new MyError()))));
    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
    assertThat(logged).hasSize(1); // errors are always logged
    assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
  }
 Pattern Name: FocalMethod_Match - Action: hasSize - Predicate: N/A - Scenario: logged

Project: guava
 Class: FuturesTest
 Method: testCatching_ExceptionAfterCancellation
 Body: {
    class Fallback implements Function<Throwable, Object> {
      ListenableFuture<Object> output;

      @Override
      public Object apply(Throwable input) {
        output.cancel(false);
        throw new MyRuntimeException();
      }
    }
    Fallback fallback = new Fallback();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = catching(input, Throwable.class, fallback, directExecutor());
    fallback.output = output;

    input.setException(new MyException());
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_ErrorAfterCancellation
 Body: {
    class Transformer implements AsyncFunction<Object, Object> {
      ListenableFuture<Object> output;

      @Override
      public ListenableFuture<Object> apply(Object input) {
        output.cancel(false);
        throw new MyError();
      }
    }
    Transformer transformer = new Transformer();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = transformAsync(input, transformer, directExecutor());
    transformer.output = output;

    input.set("foo");
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testMakeChecked_mapsInterruption
 Body: {
    SettableFuture<String> future = SettableFuture.create();

    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);

    currentThread().interrupt();

    try {
      checked.get();
      fail();
    } catch (InterruptedException expected) {
    }

    currentThread().interrupt();

    try {
      checked.get(5, SECONDS);
      fail();
    } catch (InterruptedException expected) {
    }

    currentThread().interrupt();

    try {
      checked.checkedGet();
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
    }

    currentThread().interrupt();

    try {
      checked.checkedGet(5, SECONDS);
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testNonCancellationPropagating_delegateCancelled
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);

    assertFalse(wrapper.isDone());
    assertTrue(input.cancel(false));
    assertTrue(wrapper.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_ExceptionAfterCancellation
 Body: {
    class Transformer implements AsyncFunction<Object, Object> {
      ListenableFuture<Object> output;

      @Override
      public ListenableFuture<Object> apply(Object input) {
        output.cancel(false);
        throw new MyRuntimeException();
      }
    }
    Transformer transformer = new Transformer();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = transformAsync(input, transformer, directExecutor());
    transformer.output = output;

    input.set("foo");
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testMakeChecked_mapsExecutionExceptions
 Body: {
    SettableFuture<String> future = SettableFuture.create();

    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);

    future.setException(new IOException("checked"));

    assertTrue(checked.isDone());
    assertFalse(checked.isCancelled());

    try {
      checked.get();
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(IOException.class);
    }

    try {
      checked.get(5, SECONDS);
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(IOException.class);
    }

    try {
      checked.checkedGet();
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(IOException.class);
    }

    try {
      checked.checkedGet(5, SECONDS);
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(IOException.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testNonCancellationPropagating_doesNotPropagate
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);

    assertTrue(wrapper.cancel(true));
    assertTrue(wrapper.isCancelled());
    assertTrue(wrapper.isDone());
    assertFalse(input.isCancelled());
    assertFalse(input.isDone());
  }
 Pattern Name: FocalMethod_Match - Action: isCancelled - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testAllAsList_resultCancelledInterrupted_withSecondaryListFuture
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    ListenableFuture<List<String>> compound = allAsList(future1, future2);
    // There was a bug where the event listener for the combined future would
    // result in the sub-futures being cancelled without being interrupted.
    ListenableFuture<List<String>> otherCompound = allAsList(future1, future2);

    assertTrue(compound.cancel(true));
    assertTrue(future1.isCancelled());
    assertTrue(future1.wasInterrupted());
    assertTrue(future2.isCancelled());
    assertTrue(future2.wasInterrupted());
    assertTrue(otherCompound.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: compound

Project: guava
 Class: FuturesTest
 Method: testTransform_ExceptionAfterCancellation
 Body: {
    class Transformer implements Function<Object, Object> {
      ListenableFuture<Object> output;

      @Override
      public Object apply(Object input) {
        output.cancel(false);
        throw new MyRuntimeException();
      }
    }
    Transformer transformer = new Transformer();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = transform(input, transformer, directExecutor());
    transformer.output = output;

    input.set("foo");
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testTransform_genericsHierarchy
 Body: {
    ListenableFuture<FooChild> future = immediateFuture(null);
    final BarChild barChild = new BarChild();
    Function<Foo, BarChild> function =
        new Function<Foo, BarChild>() {
          @Override
          public BarChild apply(Foo unused) {
            return barChild;
          }
        };
    Bar bar = getDone(transform(future, function, directExecutor()));
    assertSame(barChild, bar);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testCompletionOrderMixedBagOTypes
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    SettableFuture<Integer> future3 = SettableFuture.create();

    ImmutableList<? extends ListenableFuture<?>> inputs =
        ImmutableList.<ListenableFuture<?>>of(future1, future2, future3);
    ImmutableList<ListenableFuture<Object>> futures = inCompletionOrder(inputs);
    future2.set("1L");
    future1.set(2L);
    future3.set(3);

    ImmutableList<?> expected = ImmutableList.of("1L", 2L, 3);
    for (int i = 0; i < expected.size(); i++) {
      assertEquals(expected.get(i), getDone(futures.get(i)));
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: inputs

Project: guava
 Class: FuturesTest
 Method: testImmediateFuture
 Body: {
    ListenableFuture<String> future = immediateFuture(DATA1);

    assertSame(DATA1, getDone(future));
    assertSame(DATA1, getDoneFromTimeoutOverload(future));
    assertThat(future.toString()).contains("[status=SUCCESS, result=[" + DATA1 + "]]");
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testAllAsList_resultCancelled_withSecondaryListFuture
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    ListenableFuture<List<String>> compound = allAsList(future1, future2);
    // This next call is "unused," but it is an important part of the test. Don't remove it!
    ListenableFuture<List<String>> unused = allAsList(future1, future2);

    assertTrue(compound.cancel(false));
    assertTrue(future1.isCancelled());
    assertFalse(future1.wasInterrupted());
    assertTrue(future2.isCancelled());
    assertFalse(future2.wasInterrupted());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: compound

Project: guava
 Class: FuturesTest
 Method: testCompletionOrderFutureCancelled
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<Long> future2 = SettableFuture.create();
    SettableFuture<Long> future3 = SettableFuture.create();
    SettableFuture<Long> future4 = SettableFuture.create();
    SettableFuture<Long> future5 = SettableFuture.create();

    ImmutableList<ListenableFuture<Long>> futures =
        inCompletionOrder(
            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));
    future2.set(1L);
    future5.set(2L);
    future1.set(3L);
    future3.cancel(true);
    future4.set(5L);

    long expectedResult = 1L;
    for (ListenableFuture<Long> future : futures) {
      if (expectedResult != 4) {
        assertEquals((Long) expectedResult, getDone(future));
      } else {
        try {
          getDone(future);
          fail();
        } catch (CancellationException expected) {
        }
      }
      expectedResult++;
    }
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testCompletionOrderExceptionThrown
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<Long> future2 = SettableFuture.create();
    SettableFuture<Long> future3 = SettableFuture.create();
    SettableFuture<Long> future4 = SettableFuture.create();
    SettableFuture<Long> future5 = SettableFuture.create();

    ImmutableList<ListenableFuture<Long>> futures =
        inCompletionOrder(
            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));
    future2.set(1L);
    future5.setException(new IllegalStateException("2L"));
    future1.set(3L);
    future3.set(4L);
    future4.set(5L);

    long expectedResult = 1L;
    for (ListenableFuture<Long> future : futures) {
      if (expectedResult != 2) {
        assertEquals((Long) expectedResult, getDone(future));
      } else {
        try {
          getDone(future);
          fail();
        } catch (ExecutionException expected) {
          assertThat(expected.getCause()).hasMessage("2L");
        }
      }
      expectedResult++;
    }
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testMakeChecked_mapsCancellation
 Body: {
    SettableFuture<String> future = SettableFuture.create();

    CheckedFuture<String, TestException> checked = makeChecked(future, mapper);

    assertTrue(future.cancel(true)); // argument is ignored

    try {
      checked.get();
      fail();
    } catch (CancellationException expected) {
    }

    try {
      checked.get(5, SECONDS);
      fail();
    } catch (CancellationException expected) {
    }

    try {
      checked.checkedGet();
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(CancellationException.class);
    }

    try {
      checked.checkedGet(5, SECONDS);
      fail();
    } catch (TestException expected) {
      assertThat(expected.getCause()).isInstanceOf(CancellationException.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testCompletionOrder
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<Long> future2 = SettableFuture.create();
    SettableFuture<Long> future3 = SettableFuture.create();
    SettableFuture<Long> future4 = SettableFuture.create();
    SettableFuture<Long> future5 = SettableFuture.create();

    ImmutableList<ListenableFuture<Long>> futures =
        inCompletionOrder(
            ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3, future4, future5));
    future2.set(1L);
    future5.set(2L);
    future1.set(3L);
    future3.set(4L);
    future4.set(5L);

    long expectedResult = 1L;
    for (ListenableFuture<Long> future : futures) {
      assertEquals((Long) expectedResult, getDone(future));
      expectedResult++;
    }
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_wildcard
 Body: {
    ListenableFuture<?> futureA = immediateFuture("a");
    ListenableFuture<?> futureB = immediateFuture("b");
    ListenableFuture<?>[] futures = new ListenableFuture<?>[0];
    Callable<String> combiner =
        new Callable<String>() {
          @Override
          public String call() throws Exception {
            return "hi";
          }
        };

    // We'd like for all the following to compile.
    ListenableFuture<String> unused;

    // Compiles:
    unused = whenAllComplete(futureA, futureB).call(combiner, directExecutor());

    // Does not compile:
    // unused = whenAllComplete(futures).call(combiner);

    // Workaround for the above:
    unused = whenAllComplete(asList(futures)).call(combiner, directExecutor());
  }
 Pattern Name: FocalMethod_Match - Action: call - Predicate: N/A - Scenario: combiner

Project: guava
 Class: FuturesTest
 Method: testAllAsList_logging_error
 Body: {
    try {
      getDone(allAsList(immediateFailedFuture(new MyError())));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyError.class);
      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
      assertThat(logged).hasSize(1); // errors are always logged
      assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasSize - Predicate: N/A - Scenario: logged

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_ErrorAfterCancellation
 Body: {
    class Fallback implements AsyncFunction<Throwable, Object> {
      ListenableFuture<Object> output;

      @Override
      public ListenableFuture<Object> apply(Throwable input) {
        output.cancel(false);
        throw new MyError();
      }
    }
    Fallback fallback = new Fallback();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output =
        catchingAsync(input, Throwable.class, fallback, directExecutor());
    fallback.output = output;

    input.setException(new MyException());
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testImmediateFailedFuture_cancellationException
 Body: {
    CancellationException exception = new CancellationException();
    ListenableFuture<String> future = immediateFailedFuture(exception);
    assertFalse(future.isCancelled());
    assertThat(future.toString()).endsWith("[status=FAILURE, cause=[" + exception + "]]");

    try {
      getDone(future);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }

    try {
      getDoneFromTimeoutOverload(future);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }
  }
 Pattern Name: FocalMethod_Match - Action: isCancelled - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_futureToString
 Body: {
    final SettableFuture<Object> toReturn = SettableFuture.create();
    AsyncFunction<Object, Object> function =
        new AsyncFunction<Object, Object>() {
          @Override
          public ListenableFuture<Object> apply(Object input) throws Exception {
            return toReturn;
          }

          @Override
          public String toString() {
            return "Called my toString";
          }
        };

    ListenableFuture<?> output =
        Futures.catchingAsync(
            immediateFailedFuture(new RuntimeException()),
            Throwable.class,
            function,
            directExecutor());
    assertThat(output.toString()).contains(toReturn.toString());
  }
 Pattern Name: FocalMethod_Match - Action: catchingAsync - Predicate: N/A - Scenario: function

Project: guava
 Class: FuturesTest
 Method: testTransform_ErrorAfterCancellation
 Body: {
    class Transformer implements Function<Object, Object> {
      ListenableFuture<Object> output;

      @Override
      public Object apply(Object input) {
        output.cancel(false);
        throw new MyError();
      }
    }
    Transformer transformer = new Transformer();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = transform(input, transformer, directExecutor());
    transformer.output = output;

    input.set("foo");
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_interruptPropagatesToInput
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    AsyncFunction<Foo, Bar> function =
        new AsyncFunction<Foo, Bar>() {
          @Override
          public ListenableFuture<Bar> apply(Foo unused) {
            throw new AssertionFailedError("Unexpeted call to apply.");
          }
        };
    assertTrue(transformAsync(input, function, directExecutor()).cancel(true));
    assertTrue(input.isCancelled());
    assertTrue(input.wasInterrupted());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_cancelPropagatesToInput
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    AsyncFunction<Foo, Bar> function =
        new AsyncFunction<Foo, Bar>() {
          @Override
          public ListenableFuture<Bar> apply(Foo unused) {
            throw new AssertionFailedError("Unexpeted call to apply.");
          }
        };
    assertTrue(transformAsync(input, function, directExecutor()).cancel(false));
    assertTrue(input.isCancelled());
    assertFalse(input.wasInterrupted());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testAllAsList_logging_multipleExceptions_alreadyDone
 Body: {
    try {
      getDone(
          allAsList(
              immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));
      fail();
    } catch (ExecutionException expected) {
      assertThat(expected.getCause()).isInstanceOf(MyException.class);
      List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
      assertThat(logged).hasSize(1); // the second failure is logged
      assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasSize - Predicate: N/A - Scenario: logged

Project: guava
 Class: FuturesTest
 Method: testImmediateFailedFuture
 Body: {
    Exception exception = new Exception();
    ListenableFuture<String> future = immediateFailedFuture(exception);
    assertThat(future.toString()).endsWith("[status=FAILURE, cause=[" + exception + "]]");

    try {
      getDone(future);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }

    try {
      getDoneFromTimeoutOverload(future);
      fail();
    } catch (ExecutionException expected) {
      assertSame(exception, expected.getCause());
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testTransform_Executor
 Body: {
    Object value = new Object();
    ExecutorSpy spy = new ExecutorSpy(directExecutor());

    assertFalse(spy.wasExecuted);

    ListenableFuture<Object> future = transform(immediateFuture(value), identity(), spy);

    assertSame(value, getDone(future));
    assertTrue(spy.wasExecuted);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: future

Project: guava
 Class: FuturesTest
 Method: testCatching_ErrorAfterCancellation
 Body: {
    class Fallback implements Function<Throwable, Object> {
      ListenableFuture<Object> output;

      @Override
      public Object apply(Throwable input) {
        output.cancel(false);
        throw new MyError();
      }
    }
    Fallback fallback = new Fallback();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output = catching(input, Throwable.class, fallback, directExecutor());
    fallback.output = output;

    input.setException(new MyException());
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: input

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_ExceptionAfterCancellation
 Body: {
    class Fallback implements AsyncFunction<Throwable, Object> {
      ListenableFuture<Object> output;

      @Override
      public ListenableFuture<Object> apply(Throwable input) {
        output.cancel(false);
        throw new MyRuntimeException();
      }
    }
    Fallback fallback = new Fallback();
    SettableFuture<Object> input = SettableFuture.create();

    ListenableFuture<Object> output =
        catchingAsync(input, Throwable.class, fallback, directExecutor());
    fallback.output = output;

    input.setException(new MyException());
    assertTrue(output.isCancelled());
  }
 Pattern Name: FocalMethod_Match - Action: setException - Predicate: N/A - Scenario: input

Project: guava
 Class: HashBasedTableTest
 Method: testCreateCopy
 Body: {
    Table<String, Integer, Character> original =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Table<String, Integer, Character> copy = HashBasedTable.create(original);
    assertEquals(original, copy);
    assertEquals((Character) 'a', copy.get("foo", 1));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: copy

Project: guava
 Class: HashBasedTableTest
 Method: testSerialization
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    SerializableTester.reserializeAndAssert(table);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: table

Project: guava
 Class: HashBasedTableTest
 Method: testIterationOrder
 Body: {
    Table<String, String, String> table = HashBasedTable.create();
    for (int i = 0; i < 5; i++) {
      table.put("r" + i, "c" + i, "v" + i);
    }
    assertThat(table.rowKeySet()).containsExactly("r0", "r1", "r2", "r3", "r4").inOrder();
    assertThat(table.columnKeySet()).containsExactly("c0", "c1", "c2", "c3", "c4").inOrder();
    assertThat(table.values()).containsExactly("v0", "v1", "v2", "v3", "v4").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: table

Project: guava
 Class: SetAddTester
 Method: testAdd_supportedNullPresent
 Body: {
    E[] array = createArrayWithNullElement();
    collection = getSubjectGenerator().create(array);
    assertFalse("add(nullPresent) should return false", getSet().add(null));
    expectContents(array);
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: EnumsTest
 Method: testGetField
 Body: {
    Field foo = Enums.getField(AnEnum.FOO);
    assertEquals("FOO", foo.getName());
    assertTrue(foo.isAnnotationPresent(ExampleAnnotation.class));

    Field bar = Enums.getField(AnEnum.BAR);
    assertEquals("BAR", bar.getName());
    assertFalse(bar.isAnnotationPresent(ExampleAnnotation.class));
  }
 Pattern Name: FocalMethod_Match - Action: getName - Predicate: N/A - Scenario: foo

Project: guava
 Class: BooleansTest
 Method: testAsListSet
 Body: {
    List<Boolean> list = Booleans.asList(ARRAY_FALSE);
    assertFalse(list.set(0, true));
    assertTrue(list.set(0, false));
    try {
      list.set(0, null);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      list.set(1, true);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: list

Project: guava
 Class: ListIndexOfTester
 Method: testIndexOf_duplicate
 Body: {
    E[] array = createSamplesArray();
    array[getNumElements() / 2] = e0();
    collection = getSubjectGenerator().create(array);
    assertEquals(
        "indexOf(duplicate) should return index of first occurrence", 0, getList().indexOf(e0()));
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: FeatureUtilTest
 Method: testBuildTesterRequirements_classClassConflict
 Body: {
    try {
      FeatureUtil.buildTesterRequirements(
          ConflictingRequirementsExampleDerivedInterfaceTester.class);
      fail("Expected ConflictingRequirementsException");
    } catch (ConflictingRequirementsException e) {
      assertThat(e.getConflicts()).contains(ExampleBaseFeature.BASE_FEATURE_1);
      assertEquals(ConflictingRequirementsExampleDerivedInterfaceTester.class, e.getSource());
    }
  }
 Pattern Name: FocalMethod_Match - Action: buildTesterRequirements - Predicate: N/A - Scenario: e

Project: guava
 Class: FeatureUtilTest
 Method: testAddImpliedFeatures_addsImpliedFeatures
 Body: {
    Set<Feature<?>> features;

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.DERIVED_FEATURE_1);
    assertThat(FeatureUtil.addImpliedFeatures(features))
        .contains(ExampleDerivedFeature.DERIVED_FEATURE_1);

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.DERIVED_FEATURE_2);
    assertThat(FeatureUtil.addImpliedFeatures(features))
        .containsExactly(
            ExampleDerivedFeature.DERIVED_FEATURE_2, ExampleBaseFeature.BASE_FEATURE_1);

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.COMPOUND_DERIVED_FEATURE);
    assertThat(FeatureUtil.addImpliedFeatures(features))
        .containsExactly(
            ExampleDerivedFeature.COMPOUND_DERIVED_FEATURE,
            ExampleDerivedFeature.DERIVED_FEATURE_1,
            ExampleDerivedFeature.DERIVED_FEATURE_2,
            ExampleBaseFeature.BASE_FEATURE_1,
            ExampleBaseFeature.BASE_FEATURE_2);
  }
 Pattern Name: FocalMethod_Match - Action: addImpliedFeatures - Predicate: N/A - Scenario: features

Project: guava
 Class: FeatureUtilTest
 Method: testImpliedFeatures_returnsImpliedFeatures
 Body: {
    Set<Feature<?>> features;

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.DERIVED_FEATURE_1);
    assertTrue(FeatureUtil.impliedFeatures(features).isEmpty());

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.DERIVED_FEATURE_2);
    assertThat(FeatureUtil.impliedFeatures(features)).contains(ExampleBaseFeature.BASE_FEATURE_1);

    features = Sets.<Feature<?>>newHashSet(ExampleDerivedFeature.COMPOUND_DERIVED_FEATURE);
    assertThat(FeatureUtil.impliedFeatures(features))
        .containsExactly(
            ExampleDerivedFeature.DERIVED_FEATURE_1,
            ExampleDerivedFeature.DERIVED_FEATURE_2,
            ExampleBaseFeature.BASE_FEATURE_1,
            ExampleBaseFeature.BASE_FEATURE_2);
  }
 Pattern Name: FocalMethod_Match - Action: impliedFeatures - Predicate: N/A - Scenario: features

Project: guava
 Class: FinalizableReferenceQueueTest
 Method: testDecoupledLoader
 Body: {
    FinalizableReferenceQueue.DecoupledLoader decoupledLoader =
        new FinalizableReferenceQueue.DecoupledLoader() {
          @Override
          URLClassLoader newLoader(URL base) {
            return new DecoupledClassLoader(new URL[] {base});
          }
        };

    Class<?> finalizerCopy = decoupledLoader.loadFinalizer();

    assertNotNull(finalizerCopy);
    assertNotSame(Finalizer.class, finalizerCopy);

    assertNotNull(FinalizableReferenceQueue.getStartFinalizer(finalizerCopy));
  }
 Pattern Name: FocalMethod_Match - Action: getStartFinalizer - Predicate: N/A - Scenario: finalizerCopy

Project: guava
 Class: CacheBuilderTest
 Method: testMaximumWeight_setTwice
 Body: {
    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder().maximumWeight(16);
    try {
      // even to the same value is not allowed
      builder.maximumWeight(16);
      fail();
    } catch (IllegalStateException expected) {
    }
    try {
      builder.maximumSize(16);
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: maximumWeight - Predicate: N/A - Scenario: builder

Project: guava
 Class: CacheBuilderTest
 Method: testRemovalListener_setTwice
 Body: {
    RemovalListener<Object, Object> testListener = nullRemovalListener();
    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder().removalListener(testListener);
    try {
      // even to the same instance is not allowed
      builder = builder.removalListener(testListener);
      fail();
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: removalListener - Predicate: N/A - Scenario: builder

Project: guava
 Class: CacheBuilderTest
 Method: testLargeDurations
 Body: {
    java.time.Duration threeHundredYears = java.time.Duration.ofDays(365 * 300);
    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();
    try {
      builder.expireAfterWrite(threeHundredYears);
      fail();
    } catch (ArithmeticException expected) {
    }
    try {
      builder.expireAfterAccess(threeHundredYears);
      fail();
    } catch (ArithmeticException expected) {
    }
    try {
      builder.refreshAfterWrite(threeHundredYears);
      fail();
    } catch (ArithmeticException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: expireAfterWrite - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilder_withImmutableEntryAndNullContents
 Body: {
    Builder<String, Integer> builder = new Builder<>();
    try {
      builder.put(Maps.immutableEntry("one", (Integer) null));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.put(Maps.immutableEntry((String) null, 1));
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutNullValue
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put(null, 1);
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    try {
      builder.put("foo", null);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll("foo", Arrays.asList(1, null, 3));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll("foo", 1, null, 3);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(toPut);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableListMultimapTest
 Method: testSerialization
 Body: {
    Multimap<String, Integer> multimap = createMultimap();
    SerializableTester.reserializeAndAssert(multimap);
    assertEquals(multimap.size(), SerializableTester.reserialize(multimap).size());
    SerializableTester.reserializeAndAssert(multimap.get("foo"));
    LenientSerializableTester.reserializeAndAssertLenient(multimap.keySet());
    LenientSerializableTester.reserializeAndAssertLenient(multimap.keys());
    SerializableTester.reserializeAndAssert(multimap.asMap());
    Collection<Integer> valuesCopy = SerializableTester.reserialize(multimap.values());
    assertEquals(HashMultiset.create(multimap.values()), HashMultiset.create(valuesCopy));
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: valuesCopy

Project: guava
 Class: ImmutableListMultimapTest
 Method: testCopyOfEmpty
 Body: {
    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();
    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);
    assertEquals(multimap, input);
    assertEquals(input, multimap);
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: input

Project: guava
 Class: ImmutableListMultimapTest
 Method: testEmptyMultimapReads
 Body: {
    Multimap<String, Integer> multimap = ImmutableListMultimap.of();
    assertFalse(multimap.containsKey("foo"));
    assertFalse(multimap.containsValue(1));
    assertFalse(multimap.containsEntry("foo", 1));
    assertTrue(multimap.entries().isEmpty());
    assertTrue(multimap.equals(ArrayListMultimap.create()));
    assertEquals(Collections.emptyList(), multimap.get("foo"));
    assertEquals(0, multimap.hashCode());
    assertTrue(multimap.isEmpty());
    assertEquals(HashMultiset.create(), multimap.keys());
    assertEquals(Collections.emptySet(), multimap.keySet());
    assertEquals(0, multimap.size());
    assertTrue(multimap.values().isEmpty());
    assertEquals("{}", multimap.toString());
  }
 Pattern Name: FocalMethod_Match - Action: containsKey - Predicate: N/A - Scenario: multimap

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutNullKey
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", null);
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    try {
      builder.put(null, 1);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(null, Arrays.asList(1, 2, 3));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(null, 1, 2, 3);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(toPut);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableListMultimapTest
 Method: testMultimapReads
 Body: {
    Multimap<String, Integer> multimap = createMultimap();
    assertTrue(multimap.containsKey("foo"));
    assertFalse(multimap.containsKey("cat"));
    assertTrue(multimap.containsValue(1));
    assertFalse(multimap.containsValue(5));
    assertTrue(multimap.containsEntry("foo", 1));
    assertFalse(multimap.containsEntry("cat", 1));
    assertFalse(multimap.containsEntry("foo", 5));
    assertFalse(multimap.entries().isEmpty());
    assertEquals(3, multimap.size());
    assertFalse(multimap.isEmpty());
    assertEquals("{foo=[1, 3], bar=[2]}", multimap.toString());
  }
 Pattern Name: FocalMethod_Match - Action: containsKey - Predicate: N/A - Scenario: multimap

Project: guava
 Class: CaseFormatTest
 Method: testConverter_nullConversions
 Body: {
    for (CaseFormat outer : CaseFormat.values()) {
      for (CaseFormat inner : CaseFormat.values()) {
        assertNull(outer.converterTo(inner).convert(null));
        assertNull(outer.converterTo(inner).reverse().convert(null));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: converterTo - Predicate: N/A - Scenario: outer

Project: guava
 Class: CaseFormatTest
 Method: testConverter_serialization
 Body: {
    for (CaseFormat outer : CaseFormat.values()) {
      for (CaseFormat inner : CaseFormat.values()) {
        SerializableTester.reserializeAndAssert(outer.converterTo(inner));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: converterTo - Predicate: N/A - Scenario: outer

Project: guava
 Class: Collections2Test
 Method: testPermutationSetFourElements
 Body: {
    Iterator<List<Integer>> permutations =
        Collections2.permutations(newArrayList(1, 2, 3, 4)).iterator();
    assertNextPermutation(newArrayList(1, 2, 3, 4), permutations);
    assertNextPermutation(newArrayList(1, 2, 4, 3), permutations);
    assertNextPermutation(newArrayList(1, 4, 2, 3), permutations);
    assertNextPermutation(newArrayList(4, 1, 2, 3), permutations);

    assertNextPermutation(newArrayList(4, 1, 3, 2), permutations);
    assertNextPermutation(newArrayList(1, 4, 3, 2), permutations);
    assertNextPermutation(newArrayList(1, 3, 4, 2), permutations);
    assertNextPermutation(newArrayList(1, 3, 2, 4), permutations);

    assertNextPermutation(newArrayList(3, 1, 2, 4), permutations);
    assertNextPermutation(newArrayList(3, 1, 4, 2), permutations);
    assertNextPermutation(newArrayList(3, 4, 1, 2), permutations);
    assertNextPermutation(newArrayList(4, 3, 1, 2), permutations);

    assertNextPermutation(newArrayList(4, 3, 2, 1), permutations);
    assertNextPermutation(newArrayList(3, 4, 2, 1), permutations);
    assertNextPermutation(newArrayList(3, 2, 4, 1), permutations);
    assertNextPermutation(newArrayList(3, 2, 1, 4), permutations);

    assertNextPermutation(newArrayList(2, 3, 1, 4), permutations);
    assertNextPermutation(newArrayList(2, 3, 4, 1), permutations);
    assertNextPermutation(newArrayList(2, 4, 3, 1), permutations);
    assertNextPermutation(newArrayList(4, 2, 3, 1), permutations);

    assertNextPermutation(newArrayList(4, 2, 1, 3), permutations);
    assertNextPermutation(newArrayList(2, 4, 1, 3), permutations);
    assertNextPermutation(newArrayList(2, 1, 4, 3), permutations);
    assertNextPermutation(newArrayList(2, 1, 3, 4), permutations);
    assertNoMorePermutations(permutations);
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: permutations

Project: guava
 Class: Collections2Test
 Method: testOrderedPermutationSetContains
 Body: {
    List<Integer> list = newArrayList(3, 2, 1);
    Collection<List<Integer>> permutationSet = Collections2.orderedPermutations(list);

    assertTrue(permutationSet.contains(newArrayList(1, 2, 3)));
    assertTrue(permutationSet.contains(newArrayList(2, 3, 1)));
    assertFalse(permutationSet.contains(newArrayList(1, 2)));
    assertFalse(permutationSet.contains(newArrayList(1, 1, 2, 3)));
    assertFalse(permutationSet.contains(newArrayList(1, 2, 3, 4)));
    assertFalse(permutationSet.contains(null));
  }
 Pattern Name: FocalMethod_Match - Action: orderedPermutations - Predicate: N/A - Scenario: list

Project: guava
 Class: Collections2Test
 Method: testPermutationSetContains
 Body: {
    List<Integer> list = newArrayList(3, 2, 1);
    Collection<List<Integer>> permutationSet = Collections2.permutations(list);

    assertTrue(permutationSet.contains(newArrayList(1, 2, 3)));
    assertTrue(permutationSet.contains(newArrayList(2, 3, 1)));
    assertFalse(permutationSet.contains(newArrayList(1, 2)));
    assertFalse(permutationSet.contains(newArrayList(1, 1, 2, 3)));
    assertFalse(permutationSet.contains(newArrayList(1, 2, 3, 4)));
    assertFalse(permutationSet.contains(null));
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: list

Project: guava
 Class: Collections2Test
 Method: testPermutationSetTwoElements
 Body: {
    Iterator<List<Integer>> permutations = Collections2.permutations(newArrayList(1, 2)).iterator();
    assertNextPermutation(newArrayList(1, 2), permutations);
    assertNextPermutation(newArrayList(2, 1), permutations);
    assertNoMorePermutations(permutations);
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: permutations

Project: guava
 Class: Collections2Test
 Method: testPermutationSetThreeRepeatedElements
 Body: {
    Iterator<List<Integer>> permutations =
        Collections2.permutations(newArrayList(1, 1, 2)).iterator();
    assertNextPermutation(newArrayList(1, 1, 2), permutations);
    assertNextPermutation(newArrayList(1, 2, 1), permutations);
    assertNextPermutation(newArrayList(2, 1, 1), permutations);
    assertNextPermutation(newArrayList(2, 1, 1), permutations);
    assertNextPermutation(newArrayList(1, 2, 1), permutations);
    assertNextPermutation(newArrayList(1, 1, 2), permutations);
    assertNoMorePermutations(permutations);
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: permutations

Project: guava
 Class: Collections2Test
 Method: testPermutationSetThreeElementsOutOfOrder
 Body: {
    Iterator<List<Integer>> permutations =
        Collections2.permutations(newArrayList(3, 2, 1)).iterator();
    assertNextPermutation(newArrayList(3, 2, 1), permutations);
    assertNextPermutation(newArrayList(3, 1, 2), permutations);
    assertNextPermutation(newArrayList(1, 3, 2), permutations);

    assertNextPermutation(newArrayList(1, 2, 3), permutations);
    assertNextPermutation(newArrayList(2, 1, 3), permutations);
    assertNextPermutation(newArrayList(2, 3, 1), permutations);
    assertNoMorePermutations(permutations);
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: permutations

Project: guava
 Class: Collections2Test
 Method: testPermutationSetThreeElements
 Body: {
    Iterator<List<Integer>> permutations =
        Collections2.permutations(newArrayList(1, 2, 3)).iterator();
    assertNextPermutation(newArrayList(1, 2, 3), permutations);
    assertNextPermutation(newArrayList(1, 3, 2), permutations);
    assertNextPermutation(newArrayList(3, 1, 2), permutations);

    assertNextPermutation(newArrayList(3, 2, 1), permutations);
    assertNextPermutation(newArrayList(2, 3, 1), permutations);
    assertNextPermutation(newArrayList(2, 1, 3), permutations);
    assertNoMorePermutations(permutations);
  }
 Pattern Name: FocalMethod_Match - Action: permutations - Predicate: N/A - Scenario: permutations

Project: guava
 Class: ContiguousSetTest
 Method: testContains
 Body: {
    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());
    assertFalse(set.contains(0));
    assertTrue(set.contains(1));
    assertTrue(set.contains(2));
    assertTrue(set.contains(3));
    assertFalse(set.contains(4));
    set = ContiguousSet.create(Range.open(0, 4), integers());
    assertFalse(set.contains(0));
    assertTrue(set.contains(1));
    assertTrue(set.contains(2));
    assertTrue(set.contains(3));
    assertFalse(set.contains(4));
    assertFalse(set.contains((Object) "blah"));
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: set

Project: guava
 Class: ContiguousSetTest
 Method: testIntersection
 Body: {
    ContiguousSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());
    assertEquals(
        ImmutableSet.of(1, 2, 3),
        ContiguousSet.create(Range.open(-1, 4), integers()).intersection(set));
    assertEquals(
        ImmutableSet.of(1, 2, 3),
        set.intersection(ContiguousSet.create(Range.open(-1, 4), integers())));
    assertEquals(
        ImmutableSet.of(3), set.intersection(ContiguousSet.create(Range.closed(3, 5), integers())));
  }
 Pattern Name: FocalMethod_Match - Action: intersection - Predicate: N/A - Scenario: set

Project: guava
 Class: ContiguousSetTest
 Method: testSerialization
 Body: {
    ContiguousSet<Integer> empty = ContiguousSet.create(Range.closedOpen(1, 1), integers());
    assertTrue(empty instanceof EmptyContiguousSet);
    reserializeAndAssert(empty);

    ContiguousSet<Integer> regular = ContiguousSet.create(Range.closed(1, 3), integers());
    assertTrue(regular instanceof RegularContiguousSet);
    reserializeAndAssert(regular);

    /*
     * Make sure that we're using RegularContiguousSet.SerializedForm and not
     * ImmutableSet.SerializedForm, which would be enormous.
     */
    ContiguousSet<Integer> enormous = ContiguousSet.create(Range.<Integer>all(), integers());
    assertTrue(enormous instanceof RegularContiguousSet);
    // We can't use reserializeAndAssert because it calls hashCode, which is enormously slow.
    ContiguousSet<Integer> enormousReserialized = reserialize(enormous);
    assertEquals(enormous, enormousReserialized);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: enormous

Project: guava
 Class: ContiguousSetTest
 Method: testIntersection_empty
 Body: {
    ContiguousSet<Integer> set = ContiguousSet.closed(1, 3);
    ContiguousSet<Integer> emptySet = ContiguousSet.closedOpen(2, 2);
    assertEquals(ImmutableSet.of(), set.intersection(emptySet));
    assertEquals(ImmutableSet.of(), emptySet.intersection(set));
    assertEquals(
        ImmutableSet.of(),
        ContiguousSet.create(Range.closed(-5, -1), integers())
            .intersection(ContiguousSet.create(Range.open(3, 64), integers())));
  }
 Pattern Name: FocalMethod_Match - Action: intersection - Predicate: N/A - Scenario: emptySet

Project: guava
 Class: ContiguousSetTest
 Method: testContainsAll
 Body: {
    ImmutableSortedSet<Integer> set = ContiguousSet.create(Range.closed(1, 3), integers());
    for (Set<Integer> subset : Sets.powerSet(ImmutableSet.of(1, 2, 3))) {
      assertTrue(set.containsAll(subset));
    }
    for (Set<Integer> subset : Sets.powerSet(ImmutableSet.of(1, 2, 3))) {
      assertFalse(set.containsAll(Sets.union(subset, ImmutableSet.of(9))));
    }
    assertFalse(set.containsAll((Collection<?>) ImmutableSet.of("blah")));
  }
 Pattern Name: FocalMethod_Match - Action: containsAll - Predicate: N/A - Scenario: subset

Project: guava
 Class: CacheStatsTest
 Method: testEmpty
 Body: {
    CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);
    assertEquals(0, stats.requestCount());
    assertEquals(0, stats.hitCount());
    assertEquals(1.0, stats.hitRate());
    assertEquals(0, stats.missCount());
    assertEquals(0.0, stats.missRate());
    assertEquals(0, stats.loadSuccessCount());
    assertEquals(0, stats.loadExceptionCount());
    assertEquals(0.0, stats.loadExceptionRate());
    assertEquals(0, stats.loadCount());
    assertEquals(0, stats.totalLoadTime());
    assertEquals(0.0, stats.averageLoadPenalty());
    assertEquals(0, stats.evictionCount());
  }
 Pattern Name: FocalMethod_Match - Action: requestCount - Predicate: N/A - Scenario: stats

Project: guava
 Class: CacheStatsTest
 Method: testSingle
 Body: {
    CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);
    assertEquals(24, stats.requestCount());
    assertEquals(11, stats.hitCount());
    assertEquals(11.0 / 24, stats.hitRate());
    assertEquals(13, stats.missCount());
    assertEquals(13.0 / 24, stats.missRate());
    assertEquals(17, stats.loadSuccessCount());
    assertEquals(19, stats.loadExceptionCount());
    assertEquals(19.0 / 36, stats.loadExceptionRate());
    assertEquals(17 + 19, stats.loadCount());
    assertEquals(23, stats.totalLoadTime());
    assertEquals(23.0 / (17 + 19), stats.averageLoadPenalty());
    assertEquals(27, stats.evictionCount());
  }
 Pattern Name: FocalMethod_Match - Action: requestCount - Predicate: N/A - Scenario: stats

Project: guava
 Class: CacheStatsTest
 Method: testMinus
 Body: {
    CacheStats one = new CacheStats(11, 13, 17, 19, 23, 27);
    CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);

    CacheStats diff = two.minus(one);
    assertEquals(76, diff.requestCount());
    assertEquals(42, diff.hitCount());
    assertEquals(42.0 / 76, diff.hitRate());
    assertEquals(34, diff.missCount());
    assertEquals(34.0 / 76, diff.missRate());
    assertEquals(26, diff.loadSuccessCount());
    assertEquals(22, diff.loadExceptionCount());
    assertEquals(22.0 / 48, diff.loadExceptionRate());
    assertEquals(26 + 22, diff.loadCount());
    assertEquals(14, diff.totalLoadTime());
    assertEquals(14.0 / (26 + 22), diff.averageLoadPenalty());
    assertEquals(4, diff.evictionCount());

    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));
  }
 Pattern Name: FocalMethod_Match - Action: requestCount - Predicate: N/A - Scenario: diff

Project: guava
 Class: TypeResolverTest
 Method: testWhere_parameterizedTypeMapping
 Body: {
    Type t = new TypeCapture<T>() {}.capture();
    assertEquals(
        String.class,
        new TypeResolver()
            .where(
                new TypeCapture<List<T>>() {}.capture(),
                new TypeCapture<List<String>>() {}.capture())
            .resolveType(t));
    assertEquals(
        Types.subtypeOf(String.class),
        new TypeResolver()
            .where(
                new TypeCapture<List<T>>() {}.capture(),
                new TypeCapture<List<? extends String>>() {}.capture())
            .resolveType(t));
    assertEquals(
        Types.supertypeOf(String.class),
        new TypeResolver()
            .where(
                new TypeCapture<List<T>>() {}.capture(),
                new TypeCapture<List<? super String>>() {}.capture())
            .resolveType(t));
  }
 Pattern Name: FocalMethod_Match - Action: capture - Predicate: N/A - Scenario: t

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndex_tooHigh
 Body: {
    try {
      Preconditions.checkPositionIndex(2, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("index (2) must not be greater than size (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_tooManyArgs_failure
 Body: {
    try {
      Preconditions.checkArgument(false, "A %s C %s E", "b", "d", "f");
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("A b C d E [f]");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndex_negative
 Body: {
    try {
      Preconditions.checkPositionIndex(-1, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("index (-1) must not be negative");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndexes_endTooHigh
 Body: {
    try {
      Preconditions.checkPositionIndexes(0, 2, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("end index (2) must not be greater than size (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_nullArgs_failure
 Body: {
    try {
      Preconditions.checkArgument(false, "A %s C %s E", null, null);
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("A null C null E");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_singleNullArray_failure
 Body: {
    try {
      Preconditions.checkArgument(false, "A %s C", (Object[]) null);
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("A (Object[])null C");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckElementIndex_withDesc_tooHigh
 Body: {
    try {
      Preconditions.checkElementIndex(1, 1, "foo");
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("foo (1) must be less than size (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckElementIndex_withDesc_negative
 Body: {
    try {
      Preconditions.checkElementIndex(-1, 1, "foo");
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("foo (-1) must not be negative");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndex_startNegative
 Body: {
    try {
      Preconditions.checkPositionIndexes(-1, 1, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("start index (-1) must not be negative");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndexes_reversed
 Body: {
    try {
      Preconditions.checkPositionIndexes(1, 0, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("end index (0) must not be less than start index (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_singleNullArg_failure
 Body: {
    try {
      Preconditions.checkArgument(false, "A %s C", (Object) null);
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("A null C");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndex_withDesc_negative
 Body: {
    try {
      Preconditions.checkPositionIndex(-1, 1, "foo");
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("foo (-1) must not be negative");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_nullMessageWithArgs_failure
 Body: {
    try {
      Preconditions.checkArgument(false, null, "b", "d");
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("null [b, d]");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckState_nullMessage_failure
 Body: {
    try {
      Preconditions.checkState(false, null);
      fail("no exception thrown");
    } catch (IllegalStateException expected) {
      assertThat(expected).hasMessage("null");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckElementIndex_tooHigh
 Body: {
    try {
      Preconditions.checkElementIndex(1, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("index (1) must be less than size (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckElementIndex_negative
 Body: {
    try {
      Preconditions.checkElementIndex(-1, 1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("index (-1) must not be negative");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckPositionIndex_withDesc_tooHigh
 Body: {
    try {
      Preconditions.checkPositionIndex(2, 1, "foo");
      fail();
    } catch (IndexOutOfBoundsException expected) {
      assertThat(expected).hasMessage("foo (2) must not be greater than size (1)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckNotNull_simpleMessage_failure
 Body: {
    try {
      Preconditions.checkNotNull(null, new Message());
      fail("no exception thrown");
    } catch (NullPointerException expected) {
      verifySimpleMessage(expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_notEnoughArgs_failure
 Body: {
    try {
      Preconditions.checkArgument(false, "A %s C %s E", "b");
      fail("no exception thrown");
    } catch (IllegalArgumentException e) {
      assertThat(e).hasMessageThat().isEqualTo("A b C %s E");
    }
  }
 Pattern Name: FocalMethod_Match - Action: checkArgument - Predicate: N/A - Scenario: e

Project: guava
 Class: PreconditionsTest
 Method: testCheckState_simpleMessage_failure
 Body: {
    try {
      Preconditions.checkState(false, new Message());
      fail("no exception thrown");
    } catch (IllegalStateException expected) {
      verifySimpleMessage(expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_simpleMessage_failure
 Body: {
    try {
      Preconditions.checkArgument(false, new Message());
      fail("no exception thrown");
    } catch (IllegalArgumentException expected) {
      verifySimpleMessage(expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: PreconditionsTest
 Method: testCheckArgument_nullMessage_failure
 Body: {
    try {
      Preconditions.checkArgument(false, null);
      fail("no exception thrown");
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasMessage("null");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: ListLastIndexOfTester
 Method: testLastIndexOf_duplicate
 Body: {
    E[] array = createSamplesArray();
    array[getNumElements() / 2] = e0();
    collection = getSubjectGenerator().create(array);
    assertEquals(
        "lastIndexOf(duplicate) should return index of last occurrence",
        getNumElements() / 2,
        getList().lastIndexOf(e0()));
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: ShortsTest
 Method: testByteArrayRoundTrips
 Body: {
    Random r = new Random(5);
    byte[] b = new byte[Shorts.BYTES];

    // total overkill, but, it takes 0.1 sec so why not...
    for (int i = 0; i < 10000; i++) {
      short num = (short) r.nextInt();
      assertEquals(num, Shorts.fromByteArray(Shorts.toByteArray(num)));

      r.nextBytes(b);
      assertTrue(Arrays.equals(b, Shorts.toByteArray(Shorts.fromByteArray(b))));
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextBytes - Predicate: N/A - Scenario: b

Project: guava
 Class: ShortsTest
 Method: testStringConverter_convert
 Body: {
    Converter<String, Short> converter = Shorts.stringConverter();
    assertEquals((Short) (short) 1, converter.convert("1"));
    assertEquals((Short) (short) 0, converter.convert("0"));
    assertEquals((Short) (short) (-1), converter.convert("-1"));
    assertEquals((Short) (short) 255, converter.convert("0xff"));
    assertEquals((Short) (short) 255, converter.convert("0xFF"));
    assertEquals((Short) (short) (-255), converter.convert("-0xFF"));
    assertEquals((Short) (short) 255, converter.convert("#0000FF"));
    assertEquals((Short) (short) 438, converter.convert("0666"));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: converter

Project: guava
 Class: ShortsTest
 Method: testStringConverter_reverse
 Body: {
    Converter<String, Short> converter = Shorts.stringConverter();
    assertEquals("1", converter.reverse().convert((short) 1));
    assertEquals("0", converter.reverse().convert((short) 0));
    assertEquals("-1", converter.reverse().convert((short) -1));
    assertEquals("255", converter.reverse().convert((short) 0xff));
    assertEquals("255", converter.reverse().convert((short) 0xFF));
    assertEquals("-255", converter.reverse().convert((short) -0xFF));
    assertEquals("438", converter.reverse().convert((short) 0666));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: converter

Project: guava
 Class: DoublesTest
 Method: testStringConverter_convert
 Body: {
    Converter<String, Double> converter = Doubles.stringConverter();
    assertEquals((Double) 1.0, converter.convert("1.0"));
    assertEquals((Double) 0.0, converter.convert("0.0"));
    assertEquals((Double) (-1.0), converter.convert("-1.0"));
    assertEquals((Double) 1.0, converter.convert("1"));
    assertEquals((Double) 0.0, converter.convert("0"));
    assertEquals((Double) (-1.0), converter.convert("-1"));
    assertEquals((Double) 1e6, converter.convert("1e6"));
    assertEquals((Double) 1e-6, converter.convert("1e-6"));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: converter

Project: guava
 Class: DoublesTest
 Method: testStringConverter_reverse
 Body: {
    Converter<String, Double> converter = Doubles.stringConverter();
    assertEquals("1.0", converter.reverse().convert(1.0));
    assertEquals("0.0", converter.reverse().convert(0.0));
    assertEquals("-1.0", converter.reverse().convert(-1.0));
    assertEquals("1000000.0", converter.reverse().convert(1e6));
    assertEquals("1.0E-6", converter.reverse().convert(1e-6));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: converter

Project: guava
 Class: IterablesTest
 Method: testRemoveAll_iterable
 Body: {
    final List<String> list = newArrayList("a", "b", "c", "d", "e");
    Iterable<String> iterable =
        new Iterable<String>() {
          @Override
          public Iterator<String> iterator() {
            return list.iterator();
          }
        };
    assertTrue(Iterables.removeAll(iterable, newArrayList("b", "d", "f")));
    assertEquals(newArrayList("a", "c", "e"), list);
    assertFalse(Iterables.removeAll(iterable, newArrayList("x", "y", "z")));
    assertEquals(newArrayList("a", "c", "e"), list);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testPaddedPartition_basic
 Body: {
    List<Integer> list = asList(1, 2, 3, 4, 5);
    Iterable<List<Integer>> partitions = Iterables.paddedPartition(list, 2);
    assertEquals(3, Iterables.size(partitions));
    assertEquals(asList(5, null), Iterables.getLast(partitions));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IterablesTest
 Method: testNullFriendlyTransform
 Body: {
    List<Integer> input = asList(1, 2, null, 3);
    Iterable<String> result =
        Iterables.transform(
            input,
            new Function<Integer, String>() {
              @Override
              public String apply(Integer from) {
                return String.valueOf(from);
              }
            });

    List<String> actual = newArrayList(result);
    List<String> expected = asList("1", "2", "null", "3");
    assertEquals(expected, actual);
  }
 Pattern Name: FocalMethod_Match - Action: transform - Predicate: N/A - Scenario: input

Project: guava
 Class: IterablesTest
 Method: testConcatPeformingFiniteCycle
 Body: {
    Iterable<Integer> iterable = asList(1, 2, 3);
    int n = 4;
    Iterable<Integer> repeated = Iterables.concat(Collections.nCopies(n, iterable));
    assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: repeated

Project: guava
 Class: IterablesTest
 Method: testFind_withDefault
 Body: {
    Iterable<String> list = Lists.newArrayList("cool", "pants");
    assertEquals("cool", Iterables.find(list, Predicates.equalTo("cool"), "woot"));
    assertEquals("pants", Iterables.find(list, Predicates.equalTo("pants"), "woot"));
    assertEquals("woot", Iterables.find(list, Predicates.alwaysFalse(), "woot"));
    assertNull(Iterables.find(list, Predicates.alwaysFalse(), null));
    assertEquals("cool", Iterables.find(list, Predicates.alwaysTrue(), "woot"));
    assertCanIterateAgain(list);
  }
 Pattern Name: FocalMethod_Match - Action: find - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testFrequency_list
 Body: {
    List<String> list = newArrayList("a", "b", "a", "c", "b", "a");
    assertEquals(3, Iterables.frequency(list, "a"));
    assertEquals(2, Iterables.frequency(list, "b"));
    assertEquals(1, Iterables.frequency(list, "c"));
    assertEquals(0, Iterables.frequency(list, "d"));
    assertEquals(0, Iterables.frequency(list, 4.2));
    assertEquals(0, Iterables.frequency(list, null));
  }
 Pattern Name: FocalMethod_Match - Action: frequency - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testMergeSorted_pyramid
 Body: {
    List<Iterable<Integer>> iterables = Lists.newLinkedList();
    List<Integer> allIntegers = Lists.newArrayList();

    // Creates iterators like: {{}, {0}, {0, 1}, {0, 1, 2}, ...}
    for (int i = 0; i < 10; i++) {
      List<Integer> list = Lists.newLinkedList();
      for (int j = 0; j < i; j++) {
        list.add(j);
        allIntegers.add(j);
      }
      iterables.add(Ordering.natural().sortedCopy(list));
    }

    verifyMergeSorted(iterables, allIntegers);
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: iterables

Project: guava
 Class: IterablesTest
 Method: testIndexOf_withDuplicates
 Body: {
    List<String> list = Lists.newArrayList("mary", "bob", "bob", "bob", "sam");
    assertEquals(0, Iterables.indexOf(list, Predicates.equalTo("mary")));
    assertEquals(1, Iterables.indexOf(list, Predicates.equalTo("bob")));
    assertEquals(4, Iterables.indexOf(list, Predicates.equalTo("sam")));
    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("jack")));
  }
 Pattern Name: FocalMethod_Match - Action: indexOf - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testSkip_removal
 Body: {
    Collection<String> set = Sets.newHashSet("a", "b");
    Iterator<String> iterator = skip(set, 2).iterator();
    try {
      iterator.next();
    } catch (NoSuchElementException suppressed) {
      // We want remove() to fail even after a failed call to next().
    }
    try {
      iterator.remove();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IterablesTest
 Method: testIndexOf_twoElements
 Body: {
    List<String> list = Lists.newArrayList("mary", "bob");
    assertEquals(0, Iterables.indexOf(list, Predicates.equalTo("mary")));
    assertEquals(1, Iterables.indexOf(list, Predicates.equalTo("bob")));
    assertEquals(-1, Iterables.indexOf(list, Predicates.equalTo("jack")));
  }
 Pattern Name: FocalMethod_Match - Action: indexOf - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testRetainAll_collection
 Body: {
    List<String> list = newArrayList("a", "b", "c", "d", "e");
    assertTrue(Iterables.retainAll(list, newArrayList("b", "d", "f")));
    assertEquals(newArrayList("b", "d"), list);
    assertFalse(Iterables.retainAll(list, newArrayList("b", "e", "d")));
    assertEquals(newArrayList("b", "d"), list);
  }
 Pattern Name: FocalMethod_Match - Action: retainAll - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testTransform_iterator
 Body: {
    List<String> input = asList("1", "2", "3");
    Iterable<Integer> result =
        Iterables.transform(
            input,
            new Function<String, Integer>() {
              @Override
              public Integer apply(String from) {
                return Integer.valueOf(from);
              }
            });

    List<Integer> actual = newArrayList(result);
    List<Integer> expected = asList(1, 2, 3);
    assertEquals(expected, actual);
    assertCanIterateAgain(result);
    assertEquals("[1, 2, 3]", result.toString());
  }
 Pattern Name: FocalMethod_Match - Action: transform - Predicate: N/A - Scenario: input

Project: guava
 Class: IterablesTest
 Method: testFrequency_set
 Body: {
    Set<String> set = Sets.newHashSet("a", "b", "c");
    assertEquals(1, Iterables.frequency(set, "a"));
    assertEquals(1, Iterables.frequency(set, "b"));
    assertEquals(1, Iterables.frequency(set, "c"));
    assertEquals(0, Iterables.frequency(set, "d"));
    assertEquals(0, Iterables.frequency(set, 4.2));
    assertEquals(0, Iterables.frequency(set, null));
  }
 Pattern Name: FocalMethod_Match - Action: frequency - Predicate: N/A - Scenario: set

Project: guava
 Class: IterablesTest
 Method: testIsEmpty
 Body: {
    Iterable<String> emptyList = Collections.emptyList();
    assertTrue(Iterables.isEmpty(emptyList));

    Iterable<String> singletonList = Collections.singletonList("foo");
    assertFalse(Iterables.isEmpty(singletonList));
  }
 Pattern Name: FocalMethod_Match - Action: singletonList - Predicate: N/A - Scenario: singletonList

Project: guava
 Class: IterablesTest
 Method: testMergeSorted_skipping_pyramid
 Body: {
    List<Iterable<Integer>> iterables = Lists.newLinkedList();
    List<Integer> allIntegers = Lists.newArrayList();

    for (int i = 0; i < 20; i++) {
      List<Integer> list = Lists.newLinkedList();
      for (int j = 0; j < i; j++) {
        list.add(j * i);
        allIntegers.add(j * i);
      }
      iterables.add(Ordering.natural().sortedCopy(list));
    }

    verifyMergeSorted(iterables, allIntegers);
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: iterables

Project: guava
 Class: IterablesTest
 Method: testTryFind
 Body: {
    Iterable<String> list = newArrayList("cool", "pants");
    assertThat(Iterables.tryFind(list, Predicates.equalTo("cool"))).hasValue("cool");
    assertThat(Iterables.tryFind(list, Predicates.equalTo("pants"))).hasValue("pants");
    assertThat(Iterables.tryFind(list, Predicates.alwaysTrue())).hasValue("cool");
    assertThat(Iterables.tryFind(list, Predicates.alwaysFalse())).isAbsent();
    assertCanIterateAgain(list);
  }
 Pattern Name: FocalMethod_Match - Action: tryFind - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testToString
 Body: {
    List<String> list = Collections.emptyList();
    assertEquals("[]", Iterables.toString(list));

    list = newArrayList("yam", "bam", "jam", "ham");
    assertEquals("[yam, bam, jam, ham]", Iterables.toString(list));
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testCycle
 Body: {
    Iterable<String> cycle = Iterables.cycle("a", "b");

    int howManyChecked = 0;
    for (String string : cycle) {
      String expected = (howManyChecked % 2 == 0) ? "a" : "b";
      assertEquals(expected, string);
      if (howManyChecked++ == 5) {
        break;
      }
    }

    // We left the last iterator pointing to "b". But a new iterator should
    // always point to "a".
    for (String string : cycle) {
      assertEquals("a", string);
      break;
    }

    assertEquals("[a, b] (cycled)", cycle.toString());
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: string

Project: guava
 Class: IterablesTest
 Method: testRemoveAll_collection
 Body: {
    List<String> list = newArrayList("a", "b", "c", "d", "e");
    assertTrue(Iterables.removeAll(list, newArrayList("b", "d", "f")));
    assertEquals(newArrayList("a", "c", "e"), list);
    assertFalse(Iterables.removeAll(list, newArrayList("x", "y", "z")));
    assertEquals(newArrayList("a", "c", "e"), list);
  }
 Pattern Name: FocalMethod_Match - Action: removeAll - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testPartition_singleton1
 Body: {
    Iterable<Integer> source = Collections.singleton(1);
    Iterable<List<Integer>> partitions = Iterables.partition(source, 1);
    assertEquals(1, Iterables.size(partitions));
    assertEquals(Collections.singletonList(1), partitions.iterator().next());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IterablesTest
 Method: testRetainAll_iterable
 Body: {
    final List<String> list = newArrayList("a", "b", "c", "d", "e");
    Iterable<String> iterable =
        new Iterable<String>() {
          @Override
          public Iterator<String> iterator() {
            return list.iterator();
          }
        };
    assertTrue(Iterables.retainAll(iterable, newArrayList("b", "d", "f")));
    assertEquals(newArrayList("b", "d"), list);
    assertFalse(Iterables.retainAll(iterable, newArrayList("b", "e", "d")));
    assertEquals(newArrayList("b", "d"), list);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: list

Project: guava
 Class: IterablesTest
 Method: testFrequency_multiset
 Body: {
    Multiset<String> multiset = ImmutableMultiset.of("a", "b", "a", "c", "b", "a");
    assertEquals(3, Iterables.frequency(multiset, "a"));
    assertEquals(2, Iterables.frequency(multiset, "b"));
    assertEquals(1, Iterables.frequency(multiset, "c"));
    assertEquals(0, Iterables.frequency(multiset, "d"));
    assertEquals(0, Iterables.frequency(multiset, 4.2));
    assertEquals(0, Iterables.frequency(multiset, null));
  }
 Pattern Name: FocalMethod_Match - Action: frequency - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableRangeSetTest
 Method: testEmpty
 Body: {
    ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of();

    assertThat(rangeSet.asRanges()).isEmpty();
    assertEquals(ImmutableRangeSet.<Integer>all(), rangeSet.complement());
    assertFalse(rangeSet.contains(0));
    assertFalse(rangeSet.intersects(Range.singleton(0)));
    assertFalse(rangeSet.encloses(Range.singleton(0)));
    assertTrue(rangeSet.enclosesAll(rangeSet));
    assertTrue(rangeSet.isEmpty());
  }
 Pattern Name: FocalMethod_Match - Action: asRanges - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: ImmutableRangeSetTest
 Method: testSingleBoundedAboveRange
 Body: {
    ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of(Range.atMost(3));

    assertThat(rangeSet.asRanges()).contains(Range.atMost(3));

    assertTrue(rangeSet.intersects(Range.closed(3, 4)));
    assertTrue(rangeSet.intersects(Range.closedOpen(1, 5)));
    assertFalse(rangeSet.intersects(Range.closedOpen(4, 5)));
    assertTrue(rangeSet.intersects(Range.lessThan(1)));
    assertTrue(rangeSet.intersects(Range.greaterThan(1)));
    assertFalse(rangeSet.intersects(Range.greaterThan(3)));

    assertTrue(rangeSet.encloses(Range.closed(2, 3)));
    assertTrue(rangeSet.encloses(Range.lessThan(1)));
    assertFalse(rangeSet.encloses(Range.closedOpen(1, 5)));

    assertTrue(rangeSet.contains(3));
    assertTrue(rangeSet.contains(0));
    assertFalse(rangeSet.contains(4));
    assertFalse(rangeSet.contains(5));

    assertEquals(ImmutableRangeSet.of(Range.greaterThan(3)), rangeSet.complement());
  }
 Pattern Name: FocalMethod_Match - Action: asRanges - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: ImmutableRangeSetTest
 Method: testRemoveAllUnsupported
 Body: {
    RangeSet<Integer> rangeSet =
        ImmutableRangeSet.<Integer>builder()
            .add(Range.closed(5, 8))
            .add(Range.closedOpen(1, 3))
            .build();

    try {
      rangeSet.removeAll(ImmutableRangeSet.<Integer>of());
      fail();
    } catch (UnsupportedOperationException expected) {
      // success
    }

    try {
      rangeSet.removeAll(ImmutableRangeSet.of(Range.closed(6, 8)));
      fail();
    } catch (UnsupportedOperationException expected) {
      // success
    }
  }
 Pattern Name: FocalMethod_Match - Action: removeAll - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: ImmutableRangeSetTest
 Method: testSingleBoundedBelowRange
 Body: {
    ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of(Range.greaterThan(2));

    assertThat(rangeSet.asRanges()).contains(Range.greaterThan(2));

    assertTrue(rangeSet.intersects(Range.closed(3, 4)));
    assertTrue(rangeSet.intersects(Range.closedOpen(1, 5)));
    assertFalse(rangeSet.intersects(Range.lessThan(1)));
    assertTrue(rangeSet.intersects(Range.greaterThan(1)));
    assertTrue(rangeSet.intersects(Range.greaterThan(3)));

    assertTrue(rangeSet.encloses(Range.closed(3, 4)));
    assertTrue(rangeSet.encloses(Range.greaterThan(3)));
    assertFalse(rangeSet.encloses(Range.closedOpen(1, 5)));

    assertTrue(rangeSet.contains(3));
    assertTrue(rangeSet.contains(5));
    assertFalse(rangeSet.contains(0));
    assertFalse(rangeSet.contains(2));

    assertEquals(ImmutableRangeSet.of(Range.atMost(2)), rangeSet.complement());
  }
 Pattern Name: FocalMethod_Match - Action: asRanges - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: ImmutableRangeSetTest
 Method: testAll
 Body: {
    ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.all();

    assertThat(rangeSet.asRanges()).contains(Range.<Integer>all());
    assertTrue(rangeSet.contains(0));
    assertTrue(rangeSet.intersects(Range.singleton(0)));
    assertTrue(rangeSet.intersects(Range.<Integer>all()));
    assertTrue(rangeSet.encloses(Range.<Integer>all()));
    assertTrue(rangeSet.enclosesAll(rangeSet));
    assertEquals(ImmutableRangeSet.<Integer>of(), rangeSet.complement());
  }
 Pattern Name: FocalMethod_Match - Action: asRanges - Predicate: N/A - Scenario: rangeSet

Project: guava
 Class: RateLimiterTest
 Method: testWeNeverGetABurstMoreThanOneSec
 Body: {
    RateLimiter limiter = RateLimiter.create(1.0, stopwatch);
    int[] rates = {1000, 1, 10, 1000000, 10, 1};
    for (int rate : rates) {
      int oneSecWorthOfWork = rate;
      stopwatch.sleepMillis(rate * 1000);
      limiter.setRate(rate);
      long burst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());
      // we allow one second worth of work to go in a burst (i.e. take less than a second)
      assertTrue(burst <= 1000);
      long afterBurst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());
      // but work beyond that must take at least one second
      assertTrue(afterBurst >= 1000);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: rates

Project: guava
 Class: EvictingQueueTest
 Method: testEvictingAfterThree
 Body: {
    EvictingQueue<String> queue = EvictingQueue.create(3);
    assertEquals(0, queue.size());
    assertEquals(3, queue.remainingCapacity());

    assertTrue(queue.add("one"));
    assertTrue(queue.add("two"));
    assertTrue(queue.add("three"));
    assertEquals("one", queue.element());
    assertEquals("one", queue.peek());
    assertEquals(3, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertTrue(queue.add("four"));
    assertEquals("two", queue.element());
    assertEquals("two", queue.peek());
    assertEquals(3, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertEquals("two", queue.remove());
    assertEquals(2, queue.size());
    assertEquals(1, queue.remainingCapacity());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: queue

Project: guava
 Class: EvictingQueueTest
 Method: testEvictingAfterOne
 Body: {
    EvictingQueue<String> queue = EvictingQueue.create(1);
    assertEquals(0, queue.size());
    assertEquals(1, queue.remainingCapacity());

    assertTrue(queue.add("hi"));
    assertEquals("hi", queue.element());
    assertEquals("hi", queue.peek());
    assertEquals(1, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertTrue(queue.add("there"));
    assertEquals("there", queue.element());
    assertEquals("there", queue.peek());
    assertEquals(1, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertEquals("there", queue.remove());
    assertEquals(0, queue.size());
    assertEquals(1, queue.remainingCapacity());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: queue

Project: guava
 Class: EvictingQueueTest
 Method: testAddAll
 Body: {
    EvictingQueue<String> queue = EvictingQueue.create(3);
    assertEquals(0, queue.size());
    assertEquals(3, queue.remainingCapacity());

    assertTrue(queue.addAll(ImmutableList.of("one", "two", "three")));
    assertEquals("one", queue.element());
    assertEquals("one", queue.peek());
    assertEquals(3, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertTrue(queue.addAll(ImmutableList.of("four")));
    assertEquals("two", queue.element());
    assertEquals("two", queue.peek());
    assertEquals(3, queue.size());
    assertEquals(0, queue.remainingCapacity());

    assertEquals("two", queue.remove());
    assertEquals(2, queue.size());
    assertEquals(1, queue.remainingCapacity());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: queue

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_noSuperclass
 Body: {
    TypeToken<Object>.TypeSet types = new TypeToken<Object>() {}.getTypes();
    assertThat(types).contains(TypeToken.of(Object.class));
    assertThat(types.rawTypes()).contains(Object.class);
    assertThat(types.interfaces()).isEmpty();
    assertThat(types.interfaces().rawTypes()).isEmpty();
    assertThat(types.classes()).contains(TypeToken.of(Object.class));
    assertThat(types.classes().rawTypes()).contains(Object.class);
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: types

Project: guava
 Class: TypeTokenTest
 Method: testAssignableTokenToClass
 Body: {
    TypeToken<List> tokL = new TypeToken<List>() {};
    assertTrue(tokL.isSupertypeOf(new TypeToken<List>() {}));
    assertTrue(tokL.isSupertypeOf(new TypeToken<List<String>>() {}));
    assertTrue(tokL.isSupertypeOf(new TypeToken<List<?>>() {}));

    TypeToken<Second> tokS = new TypeToken<Second>() {};
    assertTrue(tokS.isSupertypeOf(new TypeToken<Second>() {}));
    assertTrue(tokS.isSupertypeOf(new TypeToken<Third>() {}));
    assertTrue(tokS.isSupertypeOf(new TypeToken<Third<String, Integer>>() {}));

    TypeToken<List[]> tokA = new TypeToken<List[]>() {};
    assertTrue(tokA.isSupertypeOf(new TypeToken<List[]>() {}));
    assertTrue(tokA.isSupertypeOf(new TypeToken<List<String>[]>() {}));
    assertTrue(tokA.isSupertypeOf(new TypeToken<List<?>[]>() {}));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokL

Project: guava
 Class: TypeTokenTest
 Method: testAssignableClassToClass
 Body: {
    @SuppressWarnings("rawtypes") // To test TypeToken<List>
    TypeToken<List> tokL = new TypeToken<List>() {};
    assertTrue(tokL.isSupertypeOf(List.class));
    assertTrue(tokL.isSupertypeOf(ArrayList.class));
    assertFalse(tokL.isSupertypeOf(List[].class));

    TypeToken<Number> tokN = new TypeToken<Number>() {};
    assertTrue(tokN.isSupertypeOf(Number.class));
    assertTrue(tokN.isSupertypeOf(Integer.class));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokL

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_field_upperBound
 Body: {
    TypeToken<Holder<?>> type = new TypeToken<Holder<?>>() {};
    TypeToken<?> matrixType =
        type.resolveType(Holder.class.getDeclaredField("matrix").getGenericType());
    assertEquals(List[].class, matrixType.getRawType());
    assertThat(matrixType.getType()).isNotEqualTo(new TypeToken<List<?>[]>() {}.getType());
  }
 Pattern Name: FocalMethod_Match - Action: resolveType - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testGetSubtype_toWildcard
 Body: {
    class TwoTypeArgs<K, V> {}
    class StringForFirstTypeArg<V> extends TwoTypeArgs<String, V> {}
    TypeToken<TwoTypeArgs<?, ?>> supertype = new TypeToken<TwoTypeArgs<?, ?>>() {};
    TypeToken<StringForFirstTypeArg<String>> subtype =
        new TypeToken<StringForFirstTypeArg<String>>() {};
    assertTrue(subtype.isSubtypeOf(supertype));
    assertEquals(
        new TypeToken<StringForFirstTypeArg<?>>() {}, supertype.getSubtype(subtype.getRawType()));
  }
 Pattern Name: FocalMethod_Match - Action: isSubtypeOf - Predicate: N/A - Scenario: supertype

Project: guava
 Class: TypeTokenTest
 Method: testPrimitiveWrappingAndUnwrapping
 Body: {
    for (Class<?> type : Primitives.allPrimitiveTypes()) {
      assertIsPrimitive(TypeToken.of(type));
    }
    for (Class<?> type : Primitives.allWrapperTypes()) {
      assertIsWrapper(TypeToken.of(type));
    }
    assertNotPrimitiveNorWrapper(TypeToken.of(String.class));
    assertNotPrimitiveNorWrapper(TypeToken.of(Object[].class));
    assertNotPrimitiveNorWrapper(TypeToken.of(Types.subtypeOf(Object.class)));
    assertNotPrimitiveNorWrapper(new TypeToken<List<String>>() {});
    assertNotPrimitiveNorWrapper(TypeToken.of(new TypeCapture<T>() {}.capture()));
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_typeVariableDeclaresTypeBound_wildcardHasNoExplicitUpperBound
 Body: {
    TypeToken<Counter<?>> type = new TypeToken<Counter<?>>() {};
    TypeToken<?> fieldType =
        type.resolveType(Counter.class.getDeclaredField("counts").getGenericType());
    Type[] typeArgs = ((ParameterizedType) fieldType.getType()).getActualTypeArguments();
    assertThat(typeArgs).asList().hasSize(1);
    TypeVariable<?> captured = (TypeVariable<?>) typeArgs[0];
    assertThat(captured.getBounds()).asList().containsExactly(Number.class);
    assertThat(new TypeToken<List<? extends Number>>() {}.isSupertypeOf(fieldType)).isTrue();
    assertThat(new TypeToken<List<? extends Iterable<?>>>() {}.isSupertypeOf(fieldType)).isFalse();
  }
 Pattern Name: FocalMethod_Match - Action: resolveType - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testGetSubtype_manyGenericArgs
 Body: {
    class FourTypeArgs<T1, T2, T3, T4> {}
    class ThreeTypeArgs<T1, T2, T3> extends FourTypeArgs<T1, T2, T3, String> {}
    TypeToken<FourTypeArgs<T, Integer, ?, ?>> supertype =
        new TypeToken<FourTypeArgs<T, Integer, ?, ?>>() {};
    TypeToken<ThreeTypeArgs<T, Integer, String>> subtype =
        new TypeToken<ThreeTypeArgs<T, Integer, String>>() {};
    assertTrue(subtype.isSubtypeOf(supertype));
    assertEquals(
        new TypeToken<ThreeTypeArgs<T, Integer, ?>>() {},
        supertype.getSubtype(subtype.getRawType()));
  }
 Pattern Name: FocalMethod_Match - Action: isSubtypeOf - Predicate: N/A - Scenario: supertype

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_wildcardWithExplicitBound
 Body: {
    TypeToken<Holder<? extends Number>> type = new TypeToken<Holder<? extends Number>>() {};
    ImmutableList<Parameter> parameters =
        type.method(Holder.class.getDeclaredMethod("setList", List.class)).getParameters();
    assertThat(parameters).hasSize(1);
    TypeToken<?> parameterType = parameters.get(0).getType();
    Type[] typeArgs = ((ParameterizedType) parameterType.getType()).getActualTypeArguments();
    assertThat(typeArgs).asList().hasSize(1);
    TypeVariable<?> captured = (TypeVariable<?>) typeArgs[0];
    assertThat(captured.getBounds()).asList().containsExactly(Number.class);
    assertThat(new TypeToken<List<? extends Number>>() {}.isSupertypeOf(parameterType)).isTrue();
  }
 Pattern Name: FocalMethod_Match - Action: method - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_typeVariableDeclaresTypeBound_wildcardAddsNewUpperBound
 Body: {
    TypeToken<Counter<? extends Iterable<?>>> type =
        new TypeToken<Counter<? extends Iterable<?>>>() {};
    TypeToken<?> fieldType =
        type.resolveType(Counter.class.getDeclaredField("counts").getGenericType());
    Type[] typeArgs = ((ParameterizedType) fieldType.getType()).getActualTypeArguments();
    assertThat(typeArgs).asList().hasSize(1);
    TypeVariable<?> captured = (TypeVariable<?>) typeArgs[0];
    assertThat(captured.getBounds()).asList().contains(Number.class);
    assertThat(captured.getBounds())
        .asList()
        .containsNoneOf(Object.class, new TypeToken<Iterable<Number>>() {}.getType());
    assertThat(new TypeToken<List<? extends Number>>() {}.isSupertypeOf(fieldType)).isTrue();
    assertThat(new TypeToken<List<? extends Iterable<?>>>() {}.isSupertypeOf(fieldType)).isTrue();
    assertThat(new TypeToken<List<? extends Iterable<Number>>>() {}.isSupertypeOf(fieldType))
        .isFalse();
  }
 Pattern Name: FocalMethod_Match - Action: resolveType - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testAssignableWildcardTypeParameterToClassTypeParameter
 Body: {
    TypeToken<?> wildcardType = new TypeToken<Iterable<? extends Object[]>>() {};
    assertFalse(new TypeToken<Iterable<Object[]>>() {}.isSupertypeOf(wildcardType));
    assertFalse(new TypeToken<Iterable<Object>>() {}.isSupertypeOf(wildcardType));
    assertTrue(wildcardType.isSupertypeOf(wildcardType));
    assertFalse(new TypeToken<Iterable<int[]>>() {}.isSupertypeOf(wildcardType));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: wildcardType

Project: guava
 Class: TypeTokenTest
 Method: testResolveType_fromTypeVariable
 Body: {
    TypeToken<?> f = TypeToken.of(new TypeCapture<F>() {}.capture());
    assertEquals(String.class, f.resolveType(Function.class.getTypeParameters()[0]).getType());
    assertEquals(Integer.class, f.resolveType(Function.class.getTypeParameters()[1]).getType());
    assertEquals(Long.class, f.resolveType(Iterable.class.getTypeParameters()[0]).getType());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: f

Project: guava
 Class: TypeTokenTest
 Method: testAssignableTokenToType
 Body: {
    TypeToken<List<String>> tokenL = new TypeToken<List<String>>() {};
    assertTrue(tokenL.isSupertypeOf(new TypeToken<List<String>>() {}));
    assertTrue(tokenL.isSupertypeOf(new TypeToken<ArrayList<String>>() {}));
    assertTrue(tokenL.isSupertypeOf(new TypeToken<StringList>() {}));

    TypeToken<First<String>> tokenF = new TypeToken<First<String>>() {};
    assertTrue(tokenF.isSupertypeOf(new TypeToken<Second<String>>() {}));
    assertTrue(tokenF.isSupertypeOf(new TypeToken<Third<String, Integer>>() {}));
    assertFalse(tokenF.isSupertypeOf(new TypeToken<Third<Integer, String>>() {}));
    assertTrue(tokenF.isSupertypeOf(new TypeToken<Fourth<Integer, String>>() {}));
    assertFalse(tokenF.isSupertypeOf(new TypeToken<Fourth<String, Integer>>() {}));
    assertTrue(tokenF.isSupertypeOf(new TypeToken<ConcreteIS>() {}));
    assertFalse(tokenF.isSupertypeOf(new TypeToken<ConcreteSI>() {}));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokenF

Project: guava
 Class: TypeTokenTest
 Method: testGetSubtype_toWildcardWithBounds
 Body: {
    class TwoTypeArgs<K, V> {}
    class StringForFirstTypeArg<V> extends TwoTypeArgs<String, V> {}
    TypeToken<TwoTypeArgs<?, ? extends Number>> supertype =
        new TypeToken<TwoTypeArgs<?, ? extends Number>>() {};
    TypeToken<StringForFirstTypeArg<Integer>> subtype =
        new TypeToken<StringForFirstTypeArg<Integer>>() {};
    assertTrue(subtype.isSubtypeOf(supertype));

    // TODO(benyu): This should check equality to an expected value, see discussion in cl/98674873
    TypeToken<?> unused = supertype.getSubtype(subtype.getRawType());
  }
 Pattern Name: FocalMethod_Match - Action: isSubtypeOf - Predicate: N/A - Scenario: supertype

Project: guava
 Class: TypeTokenTest
 Method: testAssignableWildcardBoundedByIntArrayToArrayClass
 Body: {
    Type wildcardType = Types.subtypeOf(int[].class);
    assertTrue(TypeToken.of(int[].class).isSupertypeOf(wildcardType));
    assertTrue(TypeToken.of(Object.class).isSupertypeOf(wildcardType));
    assertFalse(TypeToken.of(wildcardType).isSupertypeOf(wildcardType));
    assertFalse(TypeToken.of(Object[].class).isSupertypeOf(wildcardType));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: wildcardType

Project: guava
 Class: TypeTokenTest
 Method: testNonStaticLocalClass
 Body: {
    class Local<T> {}
    TypeToken<Local<String>> type = new TypeToken<Local<String>>() {};
    assertEquals(Types.newParameterizedType(Local.class, String.class), type.getType());
    assertEquals(new Local<String>() {}.getClass().getGenericSuperclass(), type.getType());
  }
 Pattern Name: FocalMethod_Match - Action: getType - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testAssignableNonParameterizedClassToWildcard
 Body: {
    TypeToken<?> supertypeOfString = TypeToken.of(Types.supertypeOf(String.class));
    assertFalse(supertypeOfString.isSupertypeOf(supertypeOfString));
    assertFalse(supertypeOfString.isSupertypeOf(Object.class));
    assertFalse(supertypeOfString.isSupertypeOf(CharSequence.class));
    assertTrue(supertypeOfString.isSupertypeOf(String.class));
    assertTrue(supertypeOfString.isSupertypeOf(Types.subtypeOf(String.class)));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: supertypeOfString

Project: guava
 Class: TypeTokenTest
 Method: testAssignableArrayToClass
 Body: {
    @SuppressWarnings("rawtypes") // Trying to test raw class
    TypeToken<List[]> tokL = new TypeToken<List[]>() {};
    assertTrue(tokL.isSupertypeOf(List[].class));
    assertFalse(tokL.isSupertypeOf(List.class));

    @SuppressWarnings("rawtypes") // Trying to test raw class
    TypeToken<Second[]> tokS = new TypeToken<Second[]>() {};
    assertTrue(tokS.isSupertypeOf(Second[].class));
    assertTrue(tokS.isSupertypeOf(Third[].class));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokL

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_methodParameter_upperBound
 Body: {
    TypeToken<Holder<?>> type = new TypeToken<Holder<?>>() {};
    ImmutableList<Parameter> parameters =
        type.method(Holder.class.getDeclaredMethod("setList", List.class)).getParameters();
    assertThat(parameters).hasSize(1);
    TypeToken<?> parameterType = parameters.get(0).getType();
    assertEquals(List.class, parameterType.getRawType());
    assertFalse(
        parameterType.getType().toString(),
        parameterType.isSupertypeOf(new TypeToken<List<Integer>>() {}));
  }
 Pattern Name: FocalMethod_Match - Action: method - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_wildcardWithImplicitBound
 Body: {
    TypeToken<Holder<?>> type = new TypeToken<Holder<?>>() {};
    ImmutableList<Parameter> parameters =
        type.method(Holder.class.getDeclaredMethod("setList", List.class)).getParameters();
    assertThat(parameters).hasSize(1);
    TypeToken<?> parameterType = parameters.get(0).getType();
    Type[] typeArgs = ((ParameterizedType) parameterType.getType()).getActualTypeArguments();
    assertThat(typeArgs).asList().hasSize(1);
    TypeVariable<?> captured = (TypeVariable<?>) typeArgs[0];
    assertThat(captured.getBounds()).asList().containsExactly(Object.class);
    assertThat(new TypeToken<List<?>>() {}.isSupertypeOf(parameterType)).isTrue();
  }
 Pattern Name: FocalMethod_Match - Action: method - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testGetSubtype_recursiveTypeBoundInSubtypeTranslatedAsIs
 Body: {
    class BaseWithTypeVar<T> {}
    class Outer<O> {
      class Sub<X> extends BaseWithTypeVar<List<X>> {}

      class Sub2<Y extends Sub2<Y>> extends BaseWithTypeVar<List<Y>> {}
    }
    ParameterizedType subtype =
        (ParameterizedType)
            new TypeToken<BaseWithTypeVar<List<?>>>() {}.getSubtype(Outer.Sub.class).getType();
    assertEquals(Outer.Sub.class, subtype.getRawType());
    assertThat(subtype.getActualTypeArguments()[0]).isInstanceOf(WildcardType.class);
    ParameterizedType owner = (ParameterizedType) subtype.getOwnerType();
    assertEquals(Outer.class, owner.getRawType());
    // This returns a strange ? extends Sub2<Y> type, which isn't ideal.
    TypeToken<?> unused = new TypeToken<BaseWithTypeVar<List<?>>>() {}.getSubtype(Outer.Sub2.class);
  }
 Pattern Name: FocalMethod_Match - Action: getRawType - Predicate: N/A - Scenario: owner

Project: guava
 Class: TypeTokenTest
 Method: testToGenericType
 Body: {
    assertEquals(TypeToken.of(String.class), TypeToken.toGenericType(String.class));
    assertEquals(new TypeToken<int[]>() {}, TypeToken.toGenericType(int[].class));
    @SuppressWarnings("rawtypes") // Iterable.class
    TypeToken<? extends Iterable> genericType = TypeToken.toGenericType(Iterable.class);
    assertEquals(Iterable.class, genericType.getRawType());
    assertEquals(
        Types.newParameterizedType(Iterable.class, Iterable.class.getTypeParameters()[0]),
        genericType.getType());
  }
 Pattern Name: FocalMethod_Match - Action: getRawType - Predicate: N/A - Scenario: genericType

Project: guava
 Class: TypeTokenTest
 Method: testAssignableClassToType
 Body: {
    TypeToken<List<String>> tokenL = new TypeToken<List<String>>() {};
    assertTrue(tokenL.isSupertypeOf(StringList.class));
    assertFalse(tokenL.isSupertypeOf(List.class));

    TypeToken<First<String>> tokenF = new TypeToken<First<String>>() {};
    assertTrue(tokenF.isSupertypeOf(ConcreteIS.class));
    assertFalse(tokenF.isSupertypeOf(ConcreteSI.class));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokenF

Project: guava
 Class: TypeTokenTest
 Method: testAssignableParameterizedTypeToClass
 Body: {
    @SuppressWarnings("rawtypes") // Trying to test raw class
    TypeToken<List> tokL = new TypeToken<List>() {};
    assertTrue(tokL.isSupertypeOf(StringList.class));
    assertTrue(tokL.isSupertypeOf(StringList.class.getGenericInterfaces()[0]));

    @SuppressWarnings("rawtypes") // Trying to test raw class
    TypeToken<Second> tokS = new TypeToken<Second>() {};
    assertTrue(tokS.isSupertypeOf(Second.class));
    assertTrue(tokS.isSupertypeOf(Third.class.getGenericSuperclass()));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokL

Project: guava
 Class: TypeTokenTest
 Method: testAssignableParameterizedTypeToType
 Body: {
    TypeToken<List<String>> tokenL = new TypeToken<List<String>>() {};
    assertTrue(tokenL.isSupertypeOf(StringList.class.getGenericInterfaces()[0]));
    assertFalse(tokenL.isSupertypeOf(IntegerList.class.getGenericInterfaces()[0]));

    TypeToken<First<String>> tokenF = new TypeToken<First<String>>() {};
    assertTrue(tokenF.isSupertypeOf(ConcreteIS.class.getGenericSuperclass()));
    assertFalse(tokenF.isSupertypeOf(ConcreteSI.class.getGenericSuperclass()));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: tokenF

Project: guava
 Class: TypeTokenTest
 Method: testAssignableWildcardBoundedByArrayToArrayClass
 Body: {
    Type wildcardType = Types.subtypeOf(Object[].class);
    assertTrue(TypeToken.of(Object[].class).isSupertypeOf(wildcardType));
    assertTrue(TypeToken.of(Object.class).isSupertypeOf(wildcardType));
    assertFalse(TypeToken.of(wildcardType).isSupertypeOf(wildcardType));
    assertFalse(TypeToken.of(int[].class).isSupertypeOf(wildcardType));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: wildcardType

Project: guava
 Class: TypeTokenTest
 Method: testMethod_parameterTypes
 Body: {
    Method setMethod = List.class.getMethod("set", int.class, Object.class);
    Invokable<T, ?> invokable = new TypeToken<T>(getClass()) {}.method(setMethod);
    ImmutableList<Parameter> params = invokable.getParameters();
    assertEquals(2, params.size());
    assertEquals(TypeToken.of(int.class), params.get(0).getType());
    assertEquals(TypeToken.of(String.class), params.get(1).getType());
  }
 Pattern Name: FocalMethod_Match - Action: getParameters - Predicate: N/A - Scenario: invokable

Project: guava
 Class: TypeTokenTest
 Method: testWildcardCaptured_typeVariableDeclaresTypeBound_wildcardHasExplicitUpperBound
 Body: {
    TypeToken<Counter<? extends Number>> type = new TypeToken<Counter<? extends Number>>() {};
    TypeToken<?> fieldType =
        type.resolveType(Counter.class.getDeclaredField("counts").getGenericType());
    Type[] typeArgs = ((ParameterizedType) fieldType.getType()).getActualTypeArguments();
    assertThat(typeArgs).asList().hasSize(1);
    TypeVariable<?> captured = (TypeVariable<?>) typeArgs[0];
    assertThat(captured.getBounds()).asList().containsExactly(Number.class);
    assertThat(new TypeToken<List<? extends Number>>() {}.isSupertypeOf(fieldType)).isTrue();
    assertThat(new TypeToken<List<? extends Iterable<?>>>() {}.isSupertypeOf(fieldType)).isFalse();
  }
 Pattern Name: FocalMethod_Match - Action: resolveType - Predicate: N/A - Scenario: type

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_fromPrimitive
 Body: {
    TypeToken<Integer>.TypeSet types = TypeToken.of(int.class).getTypes();
    assertThat(types).contains(TypeToken.of(int.class));
    assertThat(types.rawTypes()).contains(int.class);
    assertThat(types.interfaces()).isEmpty();
    assertThat(types.interfaces().rawTypes()).isEmpty();
    assertThat(types.classes()).contains(TypeToken.of(int.class));
    assertThat(types.classes().rawTypes()).contains(int.class);
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: types

Project: guava
 Class: TypeTokenTest
 Method: testGetGenericSuperclass_withSuperclass
 Body: {
    TypeToken<? super ArrayList<String>> superToken =
        new TypeToken<ArrayList<String>>() {}.getGenericSuperclass();
    assertEquals(ArrayList.class.getSuperclass(), superToken.getRawType());
    assertEquals(
        String.class, ((ParameterizedType) superToken.getType()).getActualTypeArguments()[0]);
    assertEquals(TypeToken.of(Base.class), TypeToken.of(Sub.class).getGenericSuperclass());
    assertEquals(TypeToken.of(Object.class), TypeToken.of(Sub[].class).getGenericSuperclass());
  }
 Pattern Name: FocalMethod_Match - Action: getRawType - Predicate: N/A - Scenario: superToken

Project: guava
 Class: TypeTokenTest
 Method: testAssignableWildcardTypeParameterBoundedByIntArrayToArrayClassTypeParameter
 Body: {
    TypeToken<?> wildcardType = new TypeToken<Iterable<? extends int[]>>() {};
    assertFalse(new TypeToken<Iterable<int[]>>() {}.isSupertypeOf(wildcardType));
    assertFalse(new TypeToken<Iterable<Object>>() {}.isSupertypeOf(wildcardType));
    assertTrue(wildcardType.isSupertypeOf(wildcardType));
    assertFalse(new TypeToken<Iterable<Object[]>>() {}.isSupertypeOf(wildcardType));
  }
 Pattern Name: FocalMethod_Match - Action: isSupertypeOf - Predicate: N/A - Scenario: wildcardType

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_fromInterface
 Body: {
    TypeToken<Interface1>.TypeSet types = new TypeToken<Interface1>() {}.getTypes();
    assertThat(types).contains(TypeToken.of(Interface1.class));
    assertThat(types.rawTypes()).contains(Interface1.class);
    assertThat(types.interfaces()).contains(TypeToken.of(Interface1.class));
    assertThat(types.interfaces().rawTypes()).contains(Interface1.class);
    assertThat(types.classes()).isEmpty();
    assertThat(types.classes().rawTypes()).isEmpty();
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: types

Project: guava
 Class: CreationTests
 Method: testCopyOfImmutableSortedSetDifferentComparator
 Body: {
      Comparator<String> comparator = Ordering.natural().reverse();
      Map<String, Integer> original = ImmutableSortedMap.of("one", 1, "two", 2, "three", 3);
      ImmutableSortedMap<String, Integer> copy = ImmutableSortedMap.copyOf(original, comparator);
      assertMapEquals(copy, "two", 2, "three", 3, "one", 1);
      assertSame(copy, ImmutableSortedMap.copyOf(copy, comparator));
      assertSame(comparator, copy.comparator());
    }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: comparator

Project: guava
 Class: CreationTests
 Method: testBuilder_withImmutableEntryAndNullContents
 Body: {
      Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();
      try {
        builder.put(Maps.immutableEntry("one", (Integer) null));
        fail();
      } catch (NullPointerException expected) {
      }
      try {
        builder.put(Maps.immutableEntry((String) null, 1));
        fail();
      } catch (NullPointerException expected) {
      }
    }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: builder

Project: guava
 Class: CreationTests
 Method: testBuilderComparator
 Body: {
      Comparator<String> comparator = Ordering.natural().reverse();
      ImmutableSortedMap<String, Integer> map =
          new ImmutableSortedMap.Builder<String, Integer>(comparator)
              .put("one", 1)
              .put("two", 2)
              .put("three", 3)
              .put("four", 4)
              .put("five", 5)
              .build();
      assertMapEquals(map, "two", 2, "three", 3, "one", 1, "four", 4, "five", 5);
      assertSame(comparator, map.comparator());
    }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: comparator

Project: guava
 Class: CreationTests
 Method: testCopyOfEmptyMap
 Body: {
      ImmutableSortedMap<String, Integer> copy =
          ImmutableSortedMap.copyOf(Collections.<String, Integer>emptyMap());
      assertEquals(Collections.<String, Integer>emptyMap(), copy);
      assertSame(copy, ImmutableSortedMap.copyOf(copy));
      assertSame(Ordering.natural(), copy.comparator());
    }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: copy

Project: guava
 Class: CreationTests
 Method: testCopyOfSingletonMap
 Body: {
      ImmutableSortedMap<String, Integer> copy =
          ImmutableSortedMap.copyOf(Collections.singletonMap("one", 1));
      assertMapEquals(copy, "one", 1);
      assertSame(copy, ImmutableSortedMap.copyOf(copy));
      assertSame(Ordering.natural(), copy.comparator());
    }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: copy

Project: guava
 Class: TypeTokenSubtypeTest
 Method: testRecursiveWildcardSubtypeBug
 Body: {
    try {
      new RecursiveTypeBoundBugExample<>().testAllDeclarations();
      fail();
    } catch (Exception e) {
      assertThat(e).hasCauseThat().isInstanceOf(AssertionError.class);
    }
  }
 Pattern Name: FocalMethod_Match - Action: testAllDeclarations - Predicate: N/A - Scenario: e

Project: guava
 Class: AbstractMapEntryTest
 Method: testEquals
 Body: {
    Entry<String, Integer> foo1 = entry("foo", 1);
    assertEquals(foo1, foo1);
    assertEquals(control("foo", 1), foo1);
    assertEquals(control("bar", 2), entry("bar", 2));
    assertFalse(control("foo", 1).equals(entry("foo", 2)));
    assertFalse(foo1.equals(control("bar", 1)));
    assertFalse(foo1.equals(new Object()));
    assertFalse(foo1.equals(null));
  }
 Pattern Name: FocalMethod_Match - Action: equals - Predicate: N/A - Scenario: foo1

Project: guava
 Class: MultimapPutIterableTester
 Method: testPutAllNullValueNullLast_unsupported
 Body: {
    int size = getNumElements();

    try {
      multimap().putAll(k3(), Lists.newArrayList(v3(), null));
      fail();
    } catch (NullPointerException expected) {
    }

    Collection<V> values = multimap().get(k3());
    if (values.size() == 0) {
      expectUnchanged();
      // Be extra thorough in case internal state was corrupted by the expected null.
      assertEquals(Lists.newArrayList(), Lists.newArrayList(values));
      assertEquals(size, multimap().size());
    } else {
      assertEquals(Lists.newArrayList(v3()), Lists.newArrayList(values));
      assertEquals(size + 1, multimap().size());
    }
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: values

Project: guava
 Class: MultimapContainsEntryTester
 Method: testContainsEntryAgreesWithGet
 Body: {
    for (K k : sampleKeys()) {
      for (V v : sampleValues()) {
        assertEquals(multimap().get(k).contains(v), multimap().containsEntry(k, v));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: v

Project: guava
 Class: GcFinalizationTest
 Method: testAwaitDone_Future_Interrupted_Interrupted
 Body: {
    Interruptenator interruptenator = new Interruptenator(Thread.currentThread());
    try {
      final SettableFuture<Void> future = SettableFuture.create();
      try {
        GcFinalization.awaitDone(future);
        fail("should throw");
      } catch (RuntimeException expected) {
        assertWrapsInterruptedException(expected);
      }
    } finally {
      interruptenator.shutdown();
      Thread.interrupted();
    }
  }
 Pattern Name: FocalMethod_Match - Action: awaitDone - Predicate: N/A - Scenario: future

Project: guava
 Class: SynchronizedMapTest
 Method: testValues
 Body: {
    Map<String, Integer> map = create();
    Collection<Integer> values = map.values();
    assertTrue(values instanceof SynchronizedCollection);
    assertSame(mutex, ((SynchronizedCollection<?>) values).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: values

Project: guava
 Class: SynchronizedMapTest
 Method: testEntrySet
 Body: {
    Map<String, Integer> map = create();
    Set<Entry<String, Integer>> entrySet = map.entrySet();
    assertTrue(entrySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) entrySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: SynchronizedMapTest
 Method: testKeySet
 Body: {
    Map<String, Integer> map = create();
    Set<String> keySet = map.keySet();
    assertTrue(keySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) keySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: map

Project: guava
 Class: CreationTests
 Method: testBuilderAddArrayHandlesNulls
 Body: {
      String[] elements = {"a", null, "b"};
      ImmutableList.Builder<String> builder = ImmutableList.builder();
      try {
        builder.add(elements);
        fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
      ImmutableList<String> result = builder.build();

      /*
       * Maybe it rejects all elements, or maybe it adds "a" before failing.
       * Either way is fine with us.
       */
      if (result.isEmpty()) {
        return;
      }
      assertTrue(ImmutableList.of("a").equals(result));
      assertEquals(1, result.size());
    }
 Pattern Name: FocalMethod_Match - Action: isEmpty - Predicate: N/A - Scenario: result

Project: guava
 Class: SynchronizedBiMapTest
 Method: testValues
 Body: {
    Map<String, Integer> map = create();
    Collection<Integer> values = map.values();
    assertTrue(values instanceof SynchronizedCollection);
    assertSame(mutex, ((SynchronizedCollection<?>) values).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: values

Project: guava
 Class: SynchronizedBiMapTest
 Method: testValues
 Body: {
    BiMap<String, Integer> map = create();
    Set<Integer> values = map.values();
    assertTrue(values instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) values).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: values

Project: guava
 Class: SynchronizedBiMapTest
 Method: testEntrySet
 Body: {
    Map<String, Integer> map = create();
    Set<Entry<String, Integer>> entrySet = map.entrySet();
    assertTrue(entrySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) entrySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: SynchronizedBiMapTest
 Method: testKeySet
 Body: {
    Map<String, Integer> map = create();
    Set<String> keySet = map.keySet();
    assertTrue(keySet instanceof SynchronizedSet);
    assertSame(mutex, ((SynchronizedSet<?>) keySet).mutex);
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: map

Project: guava
 Class: UnsignedIntegerTest
 Method: testToStringRadix
 Body: {
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      for (int l : TEST_INTS) {
        UnsignedInteger value = UnsignedInteger.fromIntBits(l);
        assertEquals(value.bigIntegerValue().toString(radix), value.toString(radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: UnsignedIntegerTest
 Method: testToStringRadixQuick
 Body: {
    int[] radices = {2, 3, 5, 7, 10, 12, 16, 21, 31, 36};
    for (int radix : radices) {
      for (int l : TEST_INTS) {
        UnsignedInteger value = UnsignedInteger.fromIntBits(l);
        assertEquals(value.bigIntegerValue().toString(radix), value.toString(radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: SetCreationTester
 Method: testCreateWithDuplicates_nonNullDuplicatesRejected
 Body: {
    E[] array = createSamplesArray();
    array[1] = e0();
    try {
      collection = getSubjectGenerator().create(array);
      fail("Should reject duplicate non-null elements at creation");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: SetCreationTester
 Method: testCreateWithDuplicates_nullDuplicatesRejected
 Body: {
    E[] array = createArrayWithNullElement();
    array[0] = null;
    try {
      collection = getSubjectGenerator().create(array);
      fail("Should reject duplicate null elements at creation");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: ListMultimapReplaceValuesTester
 Method: testReplaceValuesPreservesOrder
 Body: {
    @SuppressWarnings("unchecked")
    List<V> values = Arrays.asList(v3(), v1(), v4());

    for (K k : sampleKeys()) {
      resetContainer();
      multimap().replaceValues(k, values);
      assertGet(k, values);
    }
  }
 Pattern Name: FocalMethod_Match - Action: replaceValues - Predicate: N/A - Scenario: values

Project: guava
 Class: CacheLoadingTest
 Method: testLoadingExceptionWithCause
 Body: {
    final Exception cause = new Exception();
    final UncheckedExecutionException uee = new UncheckedExecutionException(cause);
    final ExecutionException ee = new ExecutionException(cause);

    LoadingCache<Object, Object> cacheUnchecked =
        CacheBuilder.newBuilder().build(exceptionLoader(uee));
    LoadingCache<Object, Object> cacheChecked =
        CacheBuilder.newBuilder().build(exceptionLoader(ee));

    try {
      cacheUnchecked.get(new Object());
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertSame(uee, caughtEe.getCause());
    }

    try {
      cacheUnchecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertSame(uee, caughtUee.getCause());
    }

    cacheUnchecked.refresh(new Object());
    checkLoggedCause(uee);

    try {
      cacheUnchecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException e) {
      fail();
    } catch (UncheckedExecutionException caughtEe) {
      assertSame(uee, caughtEe.getCause());
    }

    try {
      cacheChecked.get(new Object());
      fail();
    } catch (ExecutionException caughtEe) {
      assertSame(ee, caughtEe.getCause());
    }

    try {
      cacheChecked.getUnchecked(new Object());
      fail();
    } catch (UncheckedExecutionException caughtUee) {
      assertSame(ee, caughtUee.getCause());
    }

    cacheChecked.refresh(new Object());
    checkLoggedCause(ee);

    try {
      cacheChecked.getAll(asList(new Object()));
      fail();
    } catch (ExecutionException caughtEe) {
      assertSame(ee, caughtEe.getCause());
    }
  }
 Pattern Name: FocalMethod_Match - Action: getCause - Predicate: N/A - Scenario: caughtUee

Project: guava
 Class: MultimapPutTester
 Method: testPutEmpty
 Body: {
    int size = getNumElements();

    assertGet(k3(), ImmutableList.<V>of());

    assertTrue(multimap().put(k3(), v3()));

    assertGet(k3(), v3());
    assertEquals(size + 1, multimap().size());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: size

Project: guava
 Class: MultimapPutTester
 Method: testPutPresent
 Body: {
    int size = getNumElements();

    assertGet(k0(), v0());

    assertTrue(multimap().put(k0(), v3()));

    assertGet(k0(), v0(), v3());
    assertEquals(size + 1, multimap().size());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: size

Project: guava
 Class: CloserTest
 Method: testExceptionThrown_fromTryBlock
 Body: {
    Closer closer = new Closer(suppressor);

    TestCloseable c1 = closer.register(TestCloseable.normal());
    TestCloseable c2 = closer.register(TestCloseable.normal());

    IOException exception = new IOException();

    try {
      try {
        throw exception;
      } catch (Throwable e) {
        throw closer.rethrow(e);
      } finally {
        closer.close();
      }
    } catch (Throwable expected) {
      assertSame(exception, expected);
    }

    assertTrue(c1.isClosed());
    assertTrue(c2.isClosed());

    assertTrue(suppressor.suppressions.isEmpty());
  }
 Pattern Name: FocalMethod_Match - Action: normal - Predicate: N/A - Scenario: e

Project: guava
 Class: CloserTest
 Method: testExceptionThrown_whenCreatingCloseables
 Body: {
    Closer closer = new Closer(suppressor);

    TestCloseable c1 = null;
    TestCloseable c2 = null;
    TestCloseable c3 = null;
    try {
      try {
        c1 = closer.register(TestCloseable.normal());
        c2 = closer.register(TestCloseable.normal());
        c3 = closer.register(TestCloseable.throwsOnCreate());
      } catch (Throwable e) {
        throw closer.rethrow(e);
      } finally {
        closer.close();
      }
    } catch (Throwable expected) {
      assertThat(expected).isInstanceOf(IOException.class);
    }

    assertTrue(c1.isClosed());
    assertTrue(c2.isClosed());
    assertNull(c3);

    assertTrue(suppressor.suppressions.isEmpty());
  }
 Pattern Name: FocalMethod_Match - Action: normal - Predicate: N/A - Scenario: e

Project: guava
 Class: FilesFileTraverserTest
 Method: testFileTraverser_multipleDirectoryLayers_traversalReturnsAll
 Body: {
    File fileA = newFile("file-a");
    File dir1 = newDir("dir-1");
    File fileB = newFile("dir-1/file-b");
    File dir2 = newFile("dir-1/dir-2");

    assertThat(Files.fileTraverser().breadthFirst(rootDir))
        .containsExactly(rootDir, fileA, fileB, dir1, dir2);
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: dir2

Project: guava
 Class: FilesFileTraverserTest
 Method: testFileTraverser_multipleFilesAndDirectories
 Body: {
    File fileA = newFile("file-a");
    File fileB = newFile("file-b");
    File dir1 = newDir("dir-1");
    File dir2 = newDir("dir-2");

    assertThat(Files.fileTraverser().breadthFirst(rootDir))
        .containsExactly(rootDir, fileA, fileB, dir1, dir2);
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: dir2

Project: guava
 Class: VerifyTest
 Method: testVerify_simpleMessage_failure
 Body: {
    try {
      verify(false, "message");
      fail();
    } catch (VerifyException expected) {
      assertThat(expected).hasMessage("message");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: MultimapClearTester
 Method: testClearPropagatesToGet
 Body: {
    for (K key : sampleKeys()) {
      resetContainer();
      Collection<V> collection = multimap().get(key);
      multimap().clear();
      assertEmpty(collection);
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: MultimapClearTester
 Method: testClearPropagatesToAsMapGet
 Body: {
    for (K key : sampleKeys()) {
      resetContainer();
      Collection<V> collection = multimap().asMap().get(key);
      if (collection != null) {
        multimap().clear();
        assertEmpty(collection);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: ConfigurableUndirectedGraphTest
 Method: addEdge_selfLoop
 Body: {
    try {
      putEdge(N1, N1);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: CreationTests
 Method: testBuilder_withImmutableEntryAndNullContents
 Body: {
      Builder<String, Integer> builder = new Builder<>();
      try {
        builder.put(Maps.immutableEntry("one", (Integer) null));
        fail();
      } catch (NullPointerException expected) {
      }
      try {
        builder.put(Maps.immutableEntry((String) null, 1));
        fail();
      } catch (NullPointerException expected) {
      }
    }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: builder

Project: guava
 Class: MultimapSizeTester
 Method: testSize
 Body: {
    int expectedSize = getNumElements();
    Multimap<K, V> multimap = multimap();
    assertEquals(expectedSize, multimap.size());

    int size = 0;
    for (Entry<K, V> entry : multimap.entries()) {
      assertTrue(multimap.containsEntry(entry.getKey(), entry.getValue()));
      size++;
    }
    assertEquals(expectedSize, size);

    int size2 = 0;
    for (Entry<K, Collection<V>> entry2 : multimap.asMap().entrySet()) {
      size2 += entry2.getValue().size();
    }
    assertEquals(expectedSize, size2);
  }
 Pattern Name: FocalMethod_Match - Action: getKey - Predicate: N/A - Scenario: entry

Project: guava
 Class: UnsignedBytesTest
 Method: testParseUnsignedByteWithRadix
 Body: {
    // We can easily afford to test this exhaustively.
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      for (int i = 0; i <= 0xff; i++) {
        assertEquals((byte) i, UnsignedBytes.parseUnsignedByte(Integer.toString(i, radix), radix));
      }
      assertParseFails(Integer.toString(1000, radix), radix);
      assertParseFails(Integer.toString(-1, radix), radix);
      assertParseFails(Integer.toString(-128, radix), radix);
      assertParseFails(Integer.toString(256, radix), radix);
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: UnsignedBytesTest
 Method: testToStringWithRadix
 Body: {
    // We can easily afford to test this exhaustively.
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      for (int i = 0; i <= 0xff; i++) {
        assertEquals(Integer.toString(i, radix), UnsignedBytes.toString((byte) i, radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: UnsignedBytesTest
 Method: testToString
 Body: {
    // We can easily afford to test this exhaustively.
    for (int i = 0; i <= 0xff; i++) {
      assertEquals(Integer.toString(i), UnsignedBytes.toString((byte) i));
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: i

Project: guava
 Class: UnsignedBytesTest
 Method: testLexicographicalComparatorChoice
 Body: {
    Comparator<byte[]> defaultComparator = UnsignedBytes.lexicographicalComparator();
    assertNotNull(defaultComparator);
    assertSame(defaultComparator, UnsignedBytes.lexicographicalComparator());
    if (unsafeComparatorAvailable()) {
      assertSame(defaultComparator.getClass(), Class.forName(unsafeComparatorClassName()));
    } else {
      assertSame(defaultComparator, UnsignedBytes.lexicographicalComparatorJavaImpl());
    }
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: defaultComparator

Project: guava
 Class: UnsignedBytesTest
 Method: testLexicographicalComparatorLongInputs
 Body: {
    Random rnd = new Random();
    for (Comparator<byte[]> comparator :
        Arrays.asList(
            UnsignedBytes.lexicographicalComparator(),
            UnsignedBytes.lexicographicalComparatorJavaImpl())) {
      for (int trials = 10; trials-- > 0; ) {
        byte[] left = new byte[1 + rnd.nextInt(32)];
        rnd.nextBytes(left);
        byte[] right = left.clone();
        assertTrue(comparator.compare(left, right) == 0);
        int i = rnd.nextInt(left.length);
        left[i] ^= (byte) (1 + rnd.nextInt(255));
        assertTrue(comparator.compare(left, right) != 0);
        assertEquals(
            comparator.compare(left, right) > 0, UnsignedBytes.compare(left[i], right[i]) > 0);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: compare - Predicate: N/A - Scenario: comparator

Project: guava
 Class: UnsignedBytesTest
 Method: testParseUnsignedByte
 Body: {
    // We can easily afford to test this exhaustively.
    for (int i = 0; i <= 0xff; i++) {
      assertEquals((byte) i, UnsignedBytes.parseUnsignedByte(Integer.toString(i)));
    }
    assertParseFails("1000");
    assertParseFails("-1");
    assertParseFails("-128");
    assertParseFails("256");
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: i

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: ListMultimapPutTester
 Method: testPutAddsValueAtEnd
 Body: {
    for (K key : sampleKeys()) {
      for (V value : sampleValues()) {
        resetContainer();

        List<V> values = multimap().get(key);
        List<V> expectedValues = Helpers.copyToList(values);

        assertTrue(multimap().put(key, value));
        expectedValues.add(value);

        assertGet(key, expectedValues);
        assertEquals(value, values.get(values.size() - 1));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: ListCreationTester
 Method: testCreateWithDuplicates
 Body: {
    E[] array = createSamplesArray();
    array[1] = e0();
    collection = getSubjectGenerator().create(array);

    expectContents(array);
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: array

Project: guava
 Class: HashingTest
 Method: testConsistentHash_probabilities
 Body: {
    AtomicLongMap<Integer> map = AtomicLongMap.create();
    Random r = new Random(9);
    for (int i = 0; i < ITERS; i++) {
      countRemaps(r.nextLong(), map);
    }
    for (int shard = 2; shard <= MAX_SHARDS; shard++) {
      // Rough: don't exceed 1.2x the expected number of remaps by more than 20
      assertTrue(map.get(shard) <= 1.2 * ITERS / shard + 20);
    }
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: r

Project: guava
 Class: HashingTest
 Method: testHashIntVsForLoop
 Body: {
    int input = 42;
    HashCode expected = Hashing.md5().hashInt(input);

    Hasher hasher = Hashing.md5().newHasher();
    for (int i = 0; i < 32; i += 8) {
      hasher.putByte((byte) (input >> i));
    }
    HashCode actual = hasher.hash();

    assertEquals(expected, actual);
  }
 Pattern Name: FocalMethod_Match - Action: hashInt - Predicate: N/A - Scenario: input

Project: guava
 Class: DoubleUtilsTest
 Method: testBigToDouble
 Body: {
    for (BigInteger b : ALL_BIGINTEGER_CANDIDATES) {
      if (b.doubleValue() != DoubleUtils.bigToDouble(b)) {
        failFormat(
            "Converting %s to double: expected doubleValue %s but got bigToDouble %s",
            b, b.doubleValue(), DoubleUtils.bigToDouble(b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: doubleValue - Predicate: N/A - Scenario: b

Project: guava
 Class: HostSpecifierTest
 Method: testGoodDomains
 Body: {
    for (String spec : GOOD_DOMAINS) {
      assertGood(spec);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: spec

Project: guava
 Class: HostSpecifierTest
 Method: testBadIpAddresses
 Body: {
    for (String spec : BAD_IPS) {
      assertBad(spec);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: spec

Project: guava
 Class: HostSpecifierTest
 Method: testBadDomains
 Body: {
    for (String spec : BAD_DOMAINS) {
      assertBad(spec);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: spec

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_comparator_maximumSize
 Body: {
    MinMaxPriorityQueue<Integer> queue =
        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).maximumSize(42).create();
    assertEquals(11, queue.capacity());
    assertEquals(42, queue.maximumSize);
    assertSame(SOME_COMPARATOR, queue.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: capacity - Predicate: N/A - Scenario: queue

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_allOptions
 Body: {
    MinMaxPriorityQueue<Integer> queue =
        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR)
            .expectedSize(8)
            .maximumSize(42)
            .create(NUMBERS);
    assertEquals(6, queue.size());
    assertEquals(8, queue.capacity());
    assertEquals(42, queue.maximumSize);
    assertSame(SOME_COMPARATOR, queue.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: queue

Project: guava
 Class: TypesTest
 Method: testToString
 Body: {
    assertEquals(int[].class.getName(), Types.toString(int[].class));
    assertEquals(int[][].class.getName(), Types.toString(int[][].class));
    assertEquals(String[].class.getName(), Types.toString(String[].class));
    Type elementType = List.class.getTypeParameters()[0];
    assertEquals(elementType.toString(), Types.toString(elementType));
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: elementType

Project: guava
 Class: AbstractFutureTest
 Method: testSetFuture_stackOverflow
 Body: {
    SettableFuture<String> orig = SettableFuture.create();
    SettableFuture<String> prev = orig;
    for (int i = 0; i < 100000; i++) {
      SettableFuture<String> curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
    }
    // prev represents the 'innermost' future
    prev.set("done");
    assertTrue(orig.isDone());
  }
 Pattern Name: FocalMethod_Match - Action: setFuture - Predicate: N/A - Scenario: curr

Project: guava
 Class: AbstractFutureTest
 Method: testCancel_done
 Body: {
    AbstractFuture<String> future =
        new AbstractFuture<String>() {
          {
            set("foo");
          }
        };
    assertFalse(future.cancel(true));
    assertFalse(future.isCancelled());
    assertTrue(future.isDone());
  }
 Pattern Name: FocalMethod_Match - Action: cancel - Predicate: N/A - Scenario: future

Project: guava
 Class: AbstractFutureTest
 Method: testCancel_stackOverflow
 Body: {
    SettableFuture<String> orig = SettableFuture.create();
    SettableFuture<String> prev = orig;
    for (int i = 0; i < 100000; i++) {
      SettableFuture<String> curr = SettableFuture.create();
      prev.setFuture(curr);
      prev = curr;
    }
    // orig is the 'outermost future', this should propagate fully down the stack of futures.
    orig.cancel(true);
    assertTrue(orig.isCancelled());
    assertTrue(prev.isCancelled());
    assertTrue(prev.wasInterrupted());
  }
 Pattern Name: FocalMethod_Match - Action: setFuture - Predicate: N/A - Scenario: curr

Project: guava
 Class: ImmutableMultisetTest
 Method: testBuilderAddAllImmutableMultiset
 Body: {
    Multiset<String> a = ImmutableMultiset.of("a", "b", "b");
    Multiset<String> b = ImmutableMultiset.of("c", "b");
    ImmutableMultiset<String> multiset =
        new ImmutableMultiset.Builder<String>().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "b", "b", "c")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testSerialization_entrySet
 Body: {
    Multiset<String> c = ImmutableMultiset.of("a", "b", "c");
    SerializableTester.reserializeAndAssert(c.entrySet());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: c

Project: guava
 Class: ImmutableMultisetTest
 Method: testSerialization_asList
 Body: {
    ImmutableMultiset<String> multiset = ImmutableMultiset.of("a", "a", "b", "b", "b");
    SerializableTester.reserializeAndAssert(multiset.asList());
  }
 Pattern Name: FocalMethod_Match - Action: asList - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testBuilderAddAllHashMultiset
 Body: {
    Multiset<String> a = HashMultiset.create(asList("a", "b", "b"));
    Multiset<String> b = HashMultiset.create(asList("c", "b"));
    ImmutableMultiset<String> multiset =
        new ImmutableMultiset.Builder<String>().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "b", "b", "c")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testResistsHashFloodingOnCount
 Body: {
    CallsCounter smallCounter = new CallsCounter();
    List<CountsHashCodeAndEquals> haveSameHashesSmall = createAdversarialInput(10, smallCounter);
    int smallSize = haveSameHashesSmall.size();
    ImmutableMultiset<?> smallMap =
        ConstructionPathway.COPY_OF_COLLECTION.create(haveSameHashesSmall);
    long worstCaseQuerySmall = worstCaseQueryOperations(smallMap, smallCounter);

    CallsCounter largeCounter = new CallsCounter();
    List<CountsHashCodeAndEquals> haveSameHashesLarge = createAdversarialInput(15, largeCounter);
    int largeSize = haveSameHashesLarge.size();
    ImmutableMultiset<?> largeMap =
        ConstructionPathway.COPY_OF_COLLECTION.create(haveSameHashesLarge);
    long worstCaseQueryLarge = worstCaseQueryOperations(largeMap, largeCounter);

    double ratio = (double) worstCaseQueryLarge / worstCaseQuerySmall;
    assertThat(ratio)
        .named(
            "Ratio of worst case query operations for an ImmutableMultiset of size %s versus %s",
            largeSize, smallSize)
        .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
    // allow up to 2x wobble in the constant factors
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: largeMap

Project: guava
 Class: ImmutableMultisetTest
 Method: testBuilderAddAllTreeMultiset
 Body: {
    Multiset<String> a = TreeMultiset.create(asList("a", "b", "b"));
    Multiset<String> b = TreeMultiset.create(asList("c", "b"));
    ImmutableMultiset<String> multiset =
        new ImmutableMultiset.Builder<String>().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "b", "b", "c")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testAsList
 Body: {
    ImmutableMultiset<String> multiset = ImmutableMultiset.of("a", "a", "b", "b", "b");
    ImmutableList<String> list = multiset.asList();
    assertEquals(ImmutableList.of("a", "a", "b", "b", "b"), list);
    assertEquals(2, list.indexOf("b"));
    assertEquals(4, list.lastIndexOf("b"));
  }
 Pattern Name: FocalMethod_Match - Action: asList - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testCopyOf_plainIterable
 Body: {
    CountingIterable iterable = new CountingIterable();
    Multiset<String> multiset = ImmutableMultiset.copyOf(iterable);
    assertEquals(HashMultiset.create(asList("a", "b", "a")), multiset);
    assertEquals(1, iterable.count);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableMultisetTest
 Method: testBuilderAddAll
 Body: {
    List<String> a = asList("a", "b");
    List<String> b = asList("c", "d");
    ImmutableMultiset<String> multiset =
        new ImmutableMultiset.Builder<String>().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "c", "d")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: UrlEscapersTest
 Method: testUrlFormParameterEscaper
 Body: {
    UnicodeEscaper e = (UnicodeEscaper) urlFormParameterEscaper();
    // Verify that these are the same escaper (as documented)
    assertSame(e, urlFormParameterEscaper());
    assertBasicUrlEscaper(e);

    /*
     * Specified as safe by RFC 2396 but not by java.net.URLEncoder. These tests will start failing
     * when the escaper is made compliant with RFC 2396, but that's a good thing (just change them
     * to assertUnescaped).
     */
    assertEscaping(e, "%21", '!');
    assertEscaping(e, "%28", '(');
    assertEscaping(e, "%29", ')');
    assertEscaping(e, "%7E", '~');
    assertEscaping(e, "%27", '\'');

    // Plus for spaces
    assertEscaping(e, "+", ' ');
    assertEscaping(e, "%2B", '+');

    assertEquals("safe+with+spaces", e.escape("safe with spaces"));
    assertEquals("foo%40bar.com", e.escape("foo@bar.com"));
  }
 Pattern Name: FocalMethod_Match - Action: escape - Predicate: N/A - Scenario: e

Project: guava
 Class: UrlEscapersTest
 Method: testUrlFragmentEscaper
 Body: {
    UnicodeEscaper e = (UnicodeEscaper) urlFragmentEscaper();
    assertUnescaped(e, '+');
    assertUnescaped(e, '/');
    assertUnescaped(e, '?');

    assertPathEscaper(e);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: e

Project: guava
 Class: ObjectArraysTest
 Method: testNewArray_fromArray_OfArray
 Body: {
    String[][] array = ObjectArrays.newArray(new String[0][0], 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: array

Project: guava
 Class: ObjectArraysTest
 Method: testNewArray_fromClass_OfArray
 Body: {
    String[][] array = ObjectArrays.newArray(String[].class, 1);
    assertEquals(String[][].class, array.getClass());
    assertThat(array).hasLength(1);
    assertNull(array[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: array

Project: guava
 Class: ObjectArraysTest
 Method: testNewArray_fromClass_Nonempty
 Body: {
    String[] array = ObjectArrays.newArray(String.class, 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: array

Project: guava
 Class: ObjectArraysTest
 Method: testNewArray_fromArray_Nonempty
 Body: {
    String[] array = ObjectArrays.newArray(new String[0], 2);
    assertEquals(String[].class, array.getClass());
    assertThat(array).hasLength(2);
    assertNull(array[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getClass - Predicate: N/A - Scenario: array

Project: guava
 Class: MultimapsTest
 Method: testFilteredKeysListMultimapGetBadValue
 Body: {
    ListMultimap<String, Integer> multimap = ArrayListMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("baz", 3);
    multimap.put("bar", 4);

    ListMultimap<String, Integer> filtered =
        Multimaps.filterKeys(multimap, Predicates.in(ImmutableSet.of("foo", "bar")));
    List<Integer> bazList = filtered.get("baz");
    assertThat(bazList).isEmpty();
    try {
      bazList.add(5);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.add(0, 6);
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.addAll(ImmutableList.of(7, 8));
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
    try {
      bazList.addAll(0, ImmutableList.of(9, 10));
      fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: isEmpty - Predicate: N/A - Scenario: bazList

Project: guava
 Class: MultimapsTest
 Method: testNewMultimapValueCollectionMatchesList
 Body: {
    Supplier<LinkedList<Integer>> factory = new ListSupplier();
    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);
    assertTrue(multimap.get(Color.BLUE) instanceof List);
  }
 Pattern Name: FocalMethod_Match - Action: newMultimap - Predicate: N/A - Scenario: map

Project: guava
 Class: MultimapsTest
 Method: testSerializingUnmodifiableSynchronizedArrayListMultimap
 Body: {
    Multimap<String, Integer> unmodifiable =
        prepareUnmodifiableTests(
            Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create()),
            true,
            null,
            null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: unmodifiable

Project: guava
 Class: MultimapsTest
 Method: testUnmodifiableMultimapEntries
 Body: {
    Multimap<String, Integer> mod = HashMultimap.create();
    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);
    mod.put("foo", 1);
    Entry<String, Integer> entry = unmod.entries().iterator().next();
    try {
      entry.setValue(2);
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    entry = (Entry<String, Integer>) unmod.entries().toArray()[0];
    try {
      entry.setValue(2);
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    Entry<String, Integer>[] array = (Entry<String, Integer>[]) new Entry<?, ?>[2];
    assertSame(array, unmod.entries().toArray(array));
    try {
      array[0].setValue(2);
      fail("UnsupportedOperationException expected");
    } catch (UnsupportedOperationException expected) {
    }
    assertFalse(unmod.entries().contains(nefariousMapEntry("pwnd", 2)));
    assertFalse(unmod.keys().contains("pwnd"));
  }
 Pattern Name: FocalMethod_Match - Action: setValue - Predicate: N/A - Scenario: entry

Project: guava
 Class: MultimapsTest
 Method: testSerializingUnmodifiableHashMultimap
 Body: {
    Multimap<String, Integer> unmodifiable =
        prepareUnmodifiableTests(HashMultimap.<String, Integer>create(), false, null, null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: unmodifiable

Project: guava
 Class: MultimapsTest
 Method: testSynchronizedMultimapSampleCodeCompilation
 Body: {
    K key = null;

    Multimap<K, V> multimap = Multimaps.synchronizedMultimap(HashMultimap.<K, V>create());
    Collection<V> values = multimap.get(key); // Needn't be in synchronized block
    synchronized (multimap) { // Synchronizing on multimap, not values!
      Iterator<V> i = values.iterator(); // Must be in synchronized block
      while (i.hasNext()) {
        foo(i.next());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: MultimapsTest
 Method: testSerializingUnmodifiableSynchronizedHashMultimap
 Body: {
    Multimap<String, Integer> unmodifiable =
        prepareUnmodifiableTests(
            Multimaps.synchronizedSetMultimap(HashMultimap.<String, Integer>create()),
            false,
            null,
            null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: unmodifiable

Project: guava
 Class: MultimapsTest
 Method: testSerializingUnmodifiableArrayListMultimap
 Body: {
    Multimap<String, Integer> unmodifiable =
        prepareUnmodifiableTests(ArrayListMultimap.<String, Integer>create(), true, null, null);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: unmodifiable

Project: guava
 Class: MultimapsTest
 Method: testSerializingUnmodifiableTreeMultimap
 Body: {
    Multimap<String, Integer> unmodifiable =
        prepareUnmodifiableTests(TreeMultimap.<String, Integer>create(), false, "null", 42);
    SerializableTester.reserializeAndAssert(unmodifiable);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: unmodifiable

Project: guava
 Class: MultimapsTest
 Method: testNewMultimapValueCollectionMatchesNavigableSet
 Body: {
    Supplier<TreeSet<Integer>> factory = new SortedSetSupplier();
    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);
    assertTrue(multimap.get(Color.BLUE) instanceof NavigableSet);
  }
 Pattern Name: FocalMethod_Match - Action: newMultimap - Predicate: N/A - Scenario: map

Project: guava
 Class: LongsTest
 Method: testStringConverter_reverse
 Body: {
    Converter<String, Long> converter = Longs.stringConverter();
    assertEquals("1", converter.reverse().convert(1L));
    assertEquals("0", converter.reverse().convert(0L));
    assertEquals("-1", converter.reverse().convert(-1L));
    assertEquals("255", converter.reverse().convert(0xffL));
    assertEquals("255", converter.reverse().convert(0xFFL));
    assertEquals("-255", converter.reverse().convert(-0xFFL));
    assertEquals("438", converter.reverse().convert(0666L));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: converter

Project: guava
 Class: LongsTest
 Method: testStringConverter_convert
 Body: {
    Converter<String, Long> converter = Longs.stringConverter();
    assertEquals((Long) 1L, converter.convert("1"));
    assertEquals((Long) 0L, converter.convert("0"));
    assertEquals((Long) (-1L), converter.convert("-1"));
    assertEquals((Long) 255L, converter.convert("0xff"));
    assertEquals((Long) 255L, converter.convert("0xFF"));
    assertEquals((Long) (-255L), converter.convert("-0xFF"));
    assertEquals((Long) 255L, converter.convert("#0000FF"));
    assertEquals((Long) 438L, converter.convert("0666"));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: converter

Project: guava
 Class: LongsTest
 Method: testTryParse_radix
 Body: {
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      radixEncodeParseAndAssertEquals((long) 0, radix);
      radixEncodeParseAndAssertEquals((long) 8000, radix);
      radixEncodeParseAndAssertEquals((long) -8000, radix);
      radixEncodeParseAndAssertEquals(MAX_VALUE, radix);
      radixEncodeParseAndAssertEquals(MIN_VALUE, radix);
      assertNull("Radix: " + radix, Longs.tryParse("999999999999999999999999", radix));
      assertNull(
          "Radix: " + radix,
          Longs.tryParse(BigInteger.valueOf(MAX_VALUE).add(BigInteger.ONE).toString(), radix));
      assertNull(
          "Radix: " + radix,
          Longs.tryParse(BigInteger.valueOf(MIN_VALUE).subtract(BigInteger.ONE).toString(), radix));
    }
    assertNull("Hex string and dec parm", Longs.tryParse("FFFF", 10));
    assertEquals("Mixed hex case", 65535, Longs.tryParse("ffFF", 16).longValue());
  }
 Pattern Name: FocalMethod_Match - Action: tryParse - Predicate: N/A - Scenario: radix

Project: guava
 Class: LongsTest
 Method: testByteArrayRoundTrips
 Body: {
    Random r = new Random(5);
    byte[] b = new byte[Longs.BYTES];

    for (int i = 0; i < 1000; i++) {
      long num = r.nextLong();
      assertEquals(num, Longs.fromByteArray(Longs.toByteArray(num)));

      r.nextBytes(b);
      long value = Longs.fromByteArray(b);
      assertTrue("" + value, Arrays.equals(b, Longs.toByteArray(value)));
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextBytes - Predicate: N/A - Scenario: b

Project: guava
 Class: CharMatcherTest
 Method: testWhitespaceBreakingWhitespaceSubset
 Body: {
    for (int c = 0; c <= Character.MAX_VALUE; c++) {
      if (breakingWhitespace().matches((char) c)) {
        assertTrue(Integer.toHexString(c), whitespace().matches((char) c));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: matches - Predicate: N/A - Scenario: c

Project: guava
 Class: SetMultimapAsMapTester
 Method: testAsMapValuesImplementSet
 Body: {
    for (Collection<V> valueCollection : multimap().asMap().values()) {
      assertTrue(valueCollection instanceof Set);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: valueCollection

Project: guava
 Class: SetMultimapAsMapTester
 Method: testAsMapGetImplementsSet
 Body: {
    for (K key : multimap().keySet()) {
      assertTrue(multimap().asMap().get(key) instanceof Set);
    }
  }
 Pattern Name: FocalMethod_Match - Action: keySet - Predicate: N/A - Scenario: key

Project: guava
 Class: LongMathTest
 Method: testFactorial
 Body: {
    for (int n = 0; n <= 50; n++) {
      BigInteger expectedBig = BigIntegerMath.factorial(n);
      long expectedLong = fitsInLong(expectedBig) ? expectedBig.longValue() : Long.MAX_VALUE;
      assertEquals(expectedLong, LongMath.factorial(n));
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expectedLong

Project: guava
 Class: LongMathTest
 Method: testIsPrimeSmall
 Body: {
    // Check the first 1000 integers
    for (int i = 2; i < 1000; i++) {
      assertEquals(BigInteger.valueOf(i).isProbablePrime(100), LongMath.isPrime(i));
    }
  }
 Pattern Name: FocalMethod_Match - Action: valueOf - Predicate: N/A - Scenario: i

Project: guava
 Class: LongMathTest
 Method: testSaturatedSubtract
 Body: {
    for (long a : ALL_LONG_CANDIDATES) {
      for (long b : ALL_LONG_CANDIDATES) {
        assertOperationEquals(
            a,
            b,
            "s-",
            saturatedCast(valueOf(a).subtract(valueOf(b))),
            LongMath.saturatedSubtract(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: subtract - Predicate: N/A - Scenario: b

Project: guava
 Class: LongMathTest
 Method: testGCDExhaustive
 Body: {
    for (long a : POSITIVE_LONG_CANDIDATES) {
      for (long b : POSITIVE_LONG_CANDIDATES) {
        assertEquals(valueOf(a).gcd(valueOf(b)), valueOf(LongMath.gcd(a, b)));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: gcd - Predicate: N/A - Scenario: b

Project: guava
 Class: LongMathTest
 Method: testSaturatedAdd
 Body: {
    for (long a : ALL_LONG_CANDIDATES) {
      for (long b : ALL_LONG_CANDIDATES) {
        assertOperationEquals(
            a, b, "s+", saturatedCast(valueOf(a).add(valueOf(b))), LongMath.saturatedAdd(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: b

Project: guava
 Class: LongMathTest
 Method: testBinomial
 Body: {
    for (int n = 0; n <= 70; n++) {
      for (int k = 0; k <= n; k++) {
        BigInteger expectedBig = BigIntegerMath.binomial(n, k);
        long expectedLong = fitsInLong(expectedBig) ? expectedBig.longValue() : Long.MAX_VALUE;
        assertEquals(expectedLong, LongMath.binomial(n, k));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expectedLong

Project: guava
 Class: LongMathTest
 Method: testSaturatedMultiply
 Body: {
    for (long a : ALL_LONG_CANDIDATES) {
      for (long b : ALL_LONG_CANDIDATES) {
        assertOperationEquals(
            a,
            b,
            "s*",
            saturatedCast(valueOf(a).multiply(valueOf(b))),
            LongMath.saturatedMultiply(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: multiply - Predicate: N/A - Scenario: b

Project: guava
 Class: LongMathTest
 Method: testSaturatedPow
 Body: {
    for (long a : ALL_LONG_CANDIDATES) {
      for (int b : EXPONENTS) {
        assertOperationEquals(
            a, b, "s^", saturatedCast(valueOf(a).pow(b)), LongMath.saturatedPow(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: pow - Predicate: N/A - Scenario: b

Project: guava
 Class: OrderingTest
 Method: testComplicatedOrderingExample
 Body: {
    Integer nullInt = (Integer) null;
    Ordering<Iterable<Integer>> example =
        Ordering.<Integer>natural().nullsFirst().reverse().lexicographical().reverse().nullsLast();
    List<Integer> list1 = Lists.newArrayList();
    List<Integer> list2 = Lists.newArrayList(1);
    List<Integer> list3 = Lists.newArrayList(1, 1);
    List<Integer> list4 = Lists.newArrayList(1, 2);
    List<Integer> list5 = Lists.newArrayList(1, null, 2);
    List<Integer> list6 = Lists.newArrayList(2);
    List<Integer> list7 = Lists.newArrayList(nullInt);
    List<Integer> list8 = Lists.newArrayList(nullInt, nullInt);
    List<List<Integer>> list =
        Lists.newArrayList(list1, list2, list3, list4, list5, list6, list7, list8, null);
    List<List<Integer>> sorted = example.sortedCopy(list);

    // [[null, null], [null], [1, null, 2], [1, 1], [1, 2], [1], [2], [], null]
    assertThat(sorted)
        .containsExactly(
            Lists.newArrayList(nullInt, nullInt),
            Lists.newArrayList(nullInt),
            Lists.newArrayList(1, null, 2),
            Lists.newArrayList(1, 1),
            Lists.newArrayList(1, 2),
            Lists.newArrayList(1),
            Lists.newArrayList(2),
            Lists.newArrayList(),
            null)
        .inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: newArrayList - Predicate: N/A - Scenario: list2

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_nMinusOne
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list, list.size() - 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_nMinusOne_withNullElement
 Body: {
    Iterator<Integer> itr = Iterators.forArray(3, null, 5, -1);
    List<Integer> result = Ordering.natural().nullsLast().leastOf(itr, 3);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_nPlusOne
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list, list.size() + 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_empty_1
 Body: {
    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_n_withNullElement
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);
    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size());
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testParameterMinAndMax
 Body: {
    assertEquals(5, (int) numberOrdering.max(3, 5));
    assertEquals(5, (int) numberOrdering.max(5, 3));
    assertEquals(3, (int) numberOrdering.min(3, 5));
    assertEquals(3, (int) numberOrdering.min(5, 3));

    // when the values are the same, the first argument should be returned
    Integer a = new Integer(4);
    Integer b = new Integer(4);
    assertSame(a, numberOrdering.max(a, b));
    assertSame(a, numberOrdering.min(a, b));
  }
 Pattern Name: FocalMethod_Match - Action: max - Predicate: N/A - Scenario: b

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_1
 Body: {
    List<Integer> result = numberOrdering.leastOf(Iterators.forArray(3, 4, 5, -1), 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testArbitrary_withCollisions
 Body: {
    List<Integer> list = Lists.newArrayList();
    for (int i = 0; i < 50; i++) {
      list.add(i);
    }

    Ordering<Object> arbitrary =
        new ArbitraryOrdering() {
          @Override
          int identityHashCode(Object object) {
            return ((Integer) object) % 5; // fake tons of collisions!
          }
        };

    // Don't let the elements be in such a predictable order
    list = shuffledCopy(list, new Random(1));

    Collections.sort(list, arbitrary);

    // Now we don't care what order it's put the list in, only that
    // comparing any pair of elements gives the answer we expect.
    Helpers.testComparator(arbitrary, list);
  }
 Pattern Name: FocalMethod_Match - Action: sort - Predicate: N/A - Scenario: arbitrary

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_empty_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Arrays.<Integer>asList(), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testVarargsMinAndMax
 Body: {
    // try the min and max values in all positions, since some values are proper
    // parameters and others are from the varargs array
    assertEquals(9, (int) numberOrdering.max(9, 3, 0, 5, 8));
    assertEquals(9, (int) numberOrdering.max(5, 9, 0, 3, 8));
    assertEquals(9, (int) numberOrdering.max(5, 3, 9, 0, 8));
    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 9, 8));
    assertEquals(9, (int) numberOrdering.max(5, 3, 0, 8, 9));
    assertEquals(0, (int) numberOrdering.min(0, 3, 5, 9, 8));
    assertEquals(0, (int) numberOrdering.min(5, 0, 3, 9, 8));
    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 8));
    assertEquals(0, (int) numberOrdering.min(5, 3, 9, 0, 8));
    assertEquals(0, (int) numberOrdering.min(5, 3, 0, 9, 0));

    // when the values are the same, the first argument should be returned
    Integer a = new Integer(4);
    Integer b = new Integer(4);
    assertSame(a, numberOrdering.max(a, b, b));
    assertSame(a, numberOrdering.min(a, b, b));
  }
 Pattern Name: FocalMethod_Match - Action: max - Predicate: N/A - Scenario: b

Project: guava
 Class: OrderingTest
 Method: testNatural
 Body: {
    Ordering<Integer> comparator = Ordering.natural();
    Helpers.testComparator(comparator, Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE);
    try {
      comparator.compare(1, null);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      comparator.compare(null, 2);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      comparator.compare(null, null);
      fail();
    } catch (NullPointerException expected) {
    }
    assertSame(comparator, reserialize(comparator));
    assertEquals("Ordering.natural()", comparator.toString());
  }
 Pattern Name: FocalMethod_Match - Action: testComparator - Predicate: N/A - Scenario: comparator

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_singleton_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_ties
 Body: {
    Integer foo = new Integer(Integer.MAX_VALUE - 10);
    Integer bar = new Integer(Integer.MAX_VALUE - 10);

    assertNotSame(foo, bar);
    assertEquals(foo, bar);

    List<Integer> list = Arrays.asList(3, foo, bar, -1);
    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());
    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_nPlusOne
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() + 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_n
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size());
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testArbitrary_withoutCollisions
 Body: {
    List<Object> list = Lists.newArrayList();
    for (int i = 0; i < 50; i++) {
      list.add(new Object());
    }

    Ordering<Object> arbitrary = Ordering.arbitrary();
    Collections.sort(list, arbitrary);

    // Now we don't care what order it's put the list in, only that
    // comparing any pair of elements gives the answer we expect.
    Helpers.testComparator(arbitrary, list);

    assertEquals("Ordering.arbitrary()", arbitrary.toString());
  }
 Pattern Name: FocalMethod_Match - Action: arbitrary - Predicate: N/A - Scenario: arbitrary

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_n_withNullElement
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, null, -1);
    List<Integer> result = Ordering.natural().nullsLast().leastOf(list.iterator(), list.size());
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(Arrays.asList(-1, 3, 4, 5, null), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_nMinusOne
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list.iterator(), list.size() - 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_ties
 Body: {
    Integer foo = new Integer(Integer.MAX_VALUE - 10);
    Integer bar = new Integer(Integer.MAX_VALUE - 10);

    assertNotSame(foo, bar);
    assertEquals(foo, bar);

    List<Integer> list = Arrays.asList(3, foo, bar, -1);
    List<Integer> result = numberOrdering.leastOf(list, list.size());
    assertEquals(ImmutableList.of(-1, 3, foo, bar), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_singleton_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Iterators.singletonIterator(3), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_empty_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Iterators.<Integer>emptyIterator(), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_n
 Body: {
    List<Integer> list = Arrays.asList(3, 4, 5, -1);
    List<Integer> result = numberOrdering.leastOf(list, list.size());
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 4, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testAllEqual
 Body: {
    Ordering<Object> comparator = Ordering.allEqual();
    assertSame(comparator, comparator.reverse());

    assertEquals(0, comparator.compare(null, null));
    assertEquals(0, comparator.compare(new Object(), new Object()));
    assertEquals(0, comparator.compare("apples", "oranges"));
    assertSame(comparator, reserialize(comparator));
    assertEquals("Ordering.allEqual()", comparator.toString());

    List<String> strings = ImmutableList.of("b", "a", "d", "c");
    assertEquals(strings, comparator.sortedCopy(strings));
    assertEquals(strings, comparator.immutableSortedCopy(strings));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: comparator

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_nMinusOne_withNullElement
 Body: {
    List<Integer> list = Arrays.asList(3, null, 5, -1);
    List<Integer> result = Ordering.natural().nullsLast().leastOf(list, list.size() - 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1, 3, 5), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_empty_1
 Body: {
    List<Integer> result = numberOrdering.leastOf(Iterators.<Integer>emptyIterator(), 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterable_simple_1
 Body: {
    List<Integer> result = numberOrdering.leastOf(Arrays.asList(3, 4, 5, -1), 1);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.of(-1), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: OrderingTest
 Method: testLeastOfIterator_simple_0
 Body: {
    List<Integer> result = numberOrdering.leastOf(Iterators.forArray(3, 4, 5, -1), 0);
    assertTrue(result instanceof RandomAccess);
    assertListImmutable(result);
    assertEquals(ImmutableList.<Integer>of(), result);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: result

Project: guava
 Class: AbstractSequentialIteratorTest
 Method: testBroken
 Body: {
    Iterator<Object> broken = newBroken();
    assertTrue(broken.hasNext());
    // We can't retrieve even the known first element:
    try {
      broken.next();
      fail();
    } catch (MyException expected) {
    }
    try {
      broken.next();
      fail();
    } catch (MyException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: broken

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testCreateFromIterable
 Body: {
    Iterable<Integer> iterable = asList(1, 2, 2, 3, 4);
    ConcurrentHashMultiset<Integer> multiset = ConcurrentHashMultiset.create(iterable);
    assertEquals(2, multiset.count(2));
    reserializeAndAssert(multiset);
  }
 Pattern Name: FocalMethod_Match - Action: count - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testIteratorRemove_actualMap
 Body: {
    // Override to avoid using mocks.
    multiset = ConcurrentHashMultiset.create();

    multiset.add(KEY);
    multiset.add(KEY + "_2");
    multiset.add(KEY);

    int mutations = 0;
    for (Iterator<String> it = multiset.iterator(); it.hasNext(); ) {
      it.next();
      it.remove();
      mutations++;
    }
    assertTrue(multiset.isEmpty());
    assertEquals(3, mutations);
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testSerializationWithMapMaker3
 Body: {
    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();
    multiset = ConcurrentHashMultiset.create(map);
    multiset.addAll(ImmutableList.of("a", "a", "b", "c", "d", "b"));
    reserializeAndAssert(multiset);
  }
 Pattern Name: FocalMethod_Match - Action: addAll - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testSerializationWithMapMaker1
 Body: {
    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();
    multiset = ConcurrentHashMultiset.create(map);
    reserializeAndAssert(multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testSerializationWithMapMaker2
 Body: {
    ConcurrentMap<String, AtomicInteger> map = new MapMaker().makeMap();
    multiset = ConcurrentHashMultiset.create(map);
    multiset.addAll(ImmutableList.of("a", "a", "b", "c", "d", "b"));
    reserializeAndAssert(multiset);
  }
 Pattern Name: FocalMethod_Match - Action: addAll - Predicate: N/A - Scenario: multiset

Project: guava
 Class: EnumMultisetTest
 Method: testCollectionCreate
 Body: {
    Multiset<Color> ms = EnumMultiset.create(asList(Color.RED, Color.YELLOW, Color.RED));
    assertEquals(0, ms.count(Color.BLUE));
    assertEquals(1, ms.count(Color.YELLOW));
    assertEquals(2, ms.count(Color.RED));
  }
 Pattern Name: FocalMethod_Match - Action: count - Predicate: N/A - Scenario: ms

Project: guava
 Class: ImmutableTypeToInstanceMapTest
 Method: testGenericArrayType
 Body: {
    @SuppressWarnings("unchecked") // Trying to test generic array
    ImmutableList<Integer>[] array = new ImmutableList[] {ImmutableList.of(1)};
    TypeToken<ImmutableList<Integer>[]> type = new TypeToken<ImmutableList<Integer>[]>() {};
    ImmutableTypeToInstanceMap<Iterable<?>[]> map =
        ImmutableTypeToInstanceMap.<Iterable<?>[]>builder().put(type, array).build();
    assertEquals(1, map.size());
    // Redundant cast works around a javac bug.
    assertThat((Iterable<?>[]) map.getInstance(type)).asList().containsExactly(array[0]);
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: type

Project: guava
 Class: ImmutableTypeToInstanceMapTest
 Method: testParameterizedType
 Body: {
    TypeToken<ImmutableList<Integer>> type = new TypeToken<ImmutableList<Integer>>() {};
    ImmutableTypeToInstanceMap<Iterable<?>> map =
        ImmutableTypeToInstanceMap.<Iterable<?>>builder().put(type, ImmutableList.of(1)).build();
    assertEquals(1, map.size());
    assertEquals(ImmutableList.of(1), map.getInstance(type));
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: type

Project: guava
 Class: ImmutableTypeToInstanceMapTest
 Method: testPrimitiveAndWrapper
 Body: {
    ImmutableTypeToInstanceMap<Number> map =
        ImmutableTypeToInstanceMap.<Number>builder()
            .put(Integer.class, 0)
            .put(int.class, 1)
            .build();
    assertEquals(2, map.size());

    assertEquals(0, (int) map.getInstance(Integer.class));
    assertEquals(0, (int) map.getInstance(TypeToken.of(Integer.class)));
    assertEquals(1, (int) map.getInstance(int.class));
    assertEquals(1, (int) map.getInstance(TypeToken.of(int.class)));
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: map

Project: guava
 Class: ImmutableTypeToInstanceMapTest
 Method: testWildcardType
 Body: {
    TypeToken<ImmutableList<?>> type = new TypeToken<ImmutableList<?>>() {};
    ImmutableTypeToInstanceMap<Iterable<?>> map =
        ImmutableTypeToInstanceMap.<Iterable<?>>builder().put(type, ImmutableList.of(1)).build();
    assertEquals(1, map.size());
    assertEquals(ImmutableList.of(1), map.getInstance(type));
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: type

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPostOrder_multigraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), "dbca");
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), "db");
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), "dbac");
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), "d");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPostOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forTree_depthFirstPostOrderIterable_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf("dg"));

    assertEqualCharNodes(Iterables.limit(result, 2), "ab");
    assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd', 'd', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), "ab");
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b', 'd', 'd', 'd', 'g');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPreOrder_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), "abcd");
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), "bcda");
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), "cdab");
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), "dabc");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPreOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPreOrder_multigraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder('a'), "abdc");
    assertEqualCharNodes(traverser.depthFirstPreOrder('b'), "bd");
    assertEqualCharNodes(traverser.depthFirstPreOrder('c'), "cabd");
    assertEqualCharNodes(traverser.depthFirstPreOrder('d'), "d");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPreOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPreOrderIterable_multigraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("ac")), "abdc");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("cb")), "cabd");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("db")), "db");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("d")), "d");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPreOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPreOrderIterable_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("a")), "abcd");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("bd")), "bcda");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("dc")), "dabc");
    assertEqualCharNodes(traverser.depthFirstPreOrder(charactersOf("bc")), "bcda");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPreOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forTree_depthFirstPreOrderIterable_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf("dg"));

    assertEqualCharNodes(Iterables.limit(result, 2), "da");
    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), "da");
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forTree_breadthFirstIterable_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst(charactersOf("dg"));

    assertEqualCharNodes(Iterables.limit(result, 3), "dga");
    assertThat(graph.requestedNodes).containsExactly('a', 'd', 'd', 'g', 'g');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 3), "dga");
    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPostOrder_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder('a'), "dcba");
    assertEqualCharNodes(traverser.depthFirstPostOrder('b'), "adcb");
    assertEqualCharNodes(traverser.depthFirstPostOrder('c'), "badc");
    assertEqualCharNodes(traverser.depthFirstPostOrder('d'), "cbad");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPostOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_breadthFirstIterable_multiGraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("ac")), "acbd");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("cb")), "cbad");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("db")), "db");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("d")), "d");
  }
 Pattern Name: FocalMethod_Match - Action: breadthFirst - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_breadthFirst_multiGraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), "abcd");
    assertEqualCharNodes(traverser.breadthFirst('b'), "bd");
    assertEqualCharNodes(traverser.breadthFirst('c'), "cadb");
    assertEqualCharNodes(traverser.breadthFirst('d'), "d");
  }
 Pattern Name: FocalMethod_Match - Action: breadthFirst - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_breadthFirst_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst('a'), "abcd");
    assertEqualCharNodes(traverser.breadthFirst('b'), "bcda");
    assertEqualCharNodes(traverser.breadthFirst('c'), "cdab");
    assertEqualCharNodes(traverser.breadthFirst('d'), "dabc");
  }
 Pattern Name: FocalMethod_Match - Action: breadthFirst - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPostOrderIterable_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("a")), "dcba");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("bd")), "adcb");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("dc")), "cbad");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("bc")), "adcb");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPostOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forTree_breadthFirst_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('h');

    assertEqualCharNodes(Iterables.limit(result, 2), "hd");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), "hd");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forTree_depthFirstPostOrder_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder('h');

    assertEqualCharNodes(Iterables.limit(result, 2), "ab");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a', 'b');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), "ab");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a', 'b', 'b');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forTree_depthFirstPreOrder_iterableIsLazy
 Body: {
    RequestSavingGraph graph = new RequestSavingGraph(TREE);
    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('h');

    assertEqualCharNodes(Iterables.limit(result, 2), "hd");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a');

    // Iterate again to see if calculation is done again
    assertEqualCharNodes(Iterables.limit(result, 2), "hd");
    assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');
  }
 Pattern Name: FocalMethod_Match - Action: limit - Predicate: N/A - Scenario: result

Project: guava
 Class: TraverserTest
 Method: forGraph_breadthFirstIterable_twoCycles
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(TWO_CYCLES_GRAPH);
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("a")), "abcd");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("bd")), "bdca");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("dc")), "dcab");
    assertEqualCharNodes(traverser.breadthFirst(charactersOf("bc")), "bcda");
  }
 Pattern Name: FocalMethod_Match - Action: breadthFirst - Predicate: N/A - Scenario: traverser

Project: guava
 Class: TraverserTest
 Method: forGraph_depthFirstPostOrderIterable_multigraph
 Body: {
    Traverser<Character> traverser = Traverser.forGraph(MULTI_GRAPH);
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("ac")), "dbca");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("cb")), "dbac");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("db")), "db");
    assertEqualCharNodes(traverser.depthFirstPostOrder(charactersOf("d")), "d");
  }
 Pattern Name: FocalMethod_Match - Action: depthFirstPostOrder - Predicate: N/A - Scenario: traverser

Project: guava
 Class: ImmutableTableTest
 Method: testOverflowCondition
 Body: {
    // See https://code.google.com/p/guava-libraries/issues/detail?id=1322 for details.
    ImmutableTable.Builder<Integer, Integer, String> builder = ImmutableTable.builder();
    for (int i = 1; i < 0x10000; i++) {
      builder.put(i, 0, "foo");
      builder.put(0, i, "bar");
    }
    assertTrue(builder.build() instanceof SparseImmutableTable);
  }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableTableTest
 Method: testToImmutableTableNullValue
 Body: {
    Collector<Cell<String, String, Integer>, ?, ImmutableTable<String, String, Integer>> collector =
        ImmutableTable.toImmutableTable(Cell::getRowKey, Cell::getColumnKey, t -> null);
    try {
      Stream.of(Tables.immutableCell("one", "uno", 1)).collect(collector);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
    collector =
        ImmutableTable.toImmutableTable(Cell::getRowKey, Cell::getColumnKey, Cell::getValue);
    try {
      Stream.of(
              Tables.immutableCell("one", "uno", 1),
              Tables.immutableCell("one", "uno", (Integer) null))
          .collect(collector);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: collect - Predicate: N/A - Scenario: collector

Project: guava
 Class: ImmutableTableTest
 Method: testToImmutableTableMergingNullValue
 Body: {
    Collector<Cell<String, String, Integer>, ?, ImmutableTable<String, String, Integer>> collector =
        ImmutableTable.toImmutableTable(
            Cell::getRowKey, Cell::getColumnKey, t -> null, Integer::sum);
    try {
      Stream.of(Tables.immutableCell("one", "uno", 1)).collect(collector);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
    collector =
        ImmutableTable.toImmutableTable(
            Cell::getRowKey,
            Cell::getColumnKey,
            Cell::getValue,
            (i, j) -> MoreObjects.firstNonNull(i, 0) + MoreObjects.firstNonNull(j, 0));
    try {
      Stream.of(
              Tables.immutableCell("one", "uno", 1),
              Tables.immutableCell("one", "uno", (Integer) null))
          .collect(collector);
      fail("Expected NullPointerException");
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: collect - Predicate: N/A - Scenario: collector

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: addEdge_existingEdgeBetweenDifferentNodes_selfLoops
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N2, E11);
      fail("Reusing an existing self-loop edge to connect different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    try {
      addEdge(N2, N2, E11);
      fail("Reusing an existing self-loop edge to make a different self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    addEdge(N1, N2, E12);
    try {
      addEdge(N1, N1, E12);
      fail("Reusing an existing edge to add a self-loop edge between different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testSerialization_entrySet
 Body: {
    Multiset<String> c = ImmutableSortedMultiset.of("a", "b", "c");
    SerializableTester.reserializeAndAssert(c.entrySet());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: c

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testAsList
 Body: {
    ImmutableSortedMultiset<String> multiset = ImmutableSortedMultiset.of("a", "a", "b", "b", "b");
    ImmutableList<String> list = multiset.asList();
    assertEquals(ImmutableList.of("a", "a", "b", "b", "b"), list);
    SerializableTester.reserializeAndAssert(list);
    assertEquals(2, list.indexOf("b"));
    assertEquals(4, list.lastIndexOf("b"));
  }
 Pattern Name: FocalMethod_Match - Action: asList - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testBuilderAddAll
 Body: {
    List<String> a = asList("a", "b");
    List<String> b = asList("c", "d");
    ImmutableSortedMultiset<String> multiset =
        ImmutableSortedMultiset.<String>naturalOrder().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "c", "d")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testCopyOf_plainIterable
 Body: {
    CountingIterable iterable = new CountingIterable();
    Multiset<String> multiset = ImmutableSortedMultiset.copyOf(iterable);
    assertEquals(HashMultiset.create(asList("a", "b", "a")), multiset);
    assertEquals(1, iterable.count);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testBuilderAddAllMultiset
 Body: {
    Multiset<String> a = HashMultiset.create(asList("a", "b", "b"));
    Multiset<String> b = HashMultiset.create(asList("c", "b"));
    ImmutableSortedMultiset<String> multiset =
        ImmutableSortedMultiset.<String>naturalOrder().addAll(a).addAll(b).build();
    assertEquals(HashMultiset.create(asList("a", "b", "b", "b", "c")), multiset);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: multiset

Project: guava
 Class: PredicatesTest
 Method: testOr_applyIterable
 Body: {
    Predicate<Integer> vacuouslyFalse = Predicates.or(Collections.<Predicate<Integer>>emptyList());
    Predicate<Integer> troo = Predicates.or(Collections.singletonList(TRUE));
    /*
     * newLinkedList() takes varargs. TRUE and FALSE are both instances of
     * Predicate<Integer>, so the call is safe.
     */
    Predicate<Integer> trueAndFalse = Predicates.or(Arrays.asList(TRUE, FALSE));

    assertEvalsToFalse(vacuouslyFalse);
    assertEvalsToTrue(troo);
    assertEvalsToTrue(trueAndFalse);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: trueAndFalse

Project: guava
 Class: PredicatesTest
 Method: testIsInstanceOf_apply
 Body: {
    Predicate<Object> isInteger = Predicates.instanceOf(Integer.class);

    assertTrue(isInteger.apply(1));
    assertFalse(isInteger.apply(2.0f));
    assertFalse(isInteger.apply(""));
    assertFalse(isInteger.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: isInteger

Project: guava
 Class: PredicatesTest
 Method: testIsNull_serialization
 Body: {
    Predicate<String> pre = Predicates.isNull();
    Predicate<String> post = SerializableTester.reserializeAndAssert(pre);
    assertEquals(pre.apply("foo"), post.apply("foo"));
    assertEquals(pre.apply(null), post.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: post

Project: guava
 Class: PredicatesTest
 Method: testIsInstanceOf_subclass
 Body: {
    Predicate<Object> isNumber = Predicates.instanceOf(Number.class);

    assertTrue(isNumber.apply(1));
    assertTrue(isNumber.apply(2.0f));
    assertFalse(isNumber.apply(""));
    assertFalse(isNumber.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: isNumber

Project: guava
 Class: PredicatesTest
 Method: testHashCodeForBooleanOperations
 Body: {
    Predicate<Integer> p1 = Predicates.isNull();
    Predicate<Integer> p2 = isOdd();

    // Make sure that hash codes are not computed per-instance.
    assertEqualHashCode(Predicates.not(p1), Predicates.not(p1));

    assertEqualHashCode(Predicates.and(p1, p2), Predicates.and(p1, p2));

    assertEqualHashCode(Predicates.or(p1, p2), Predicates.or(p1, p2));

    // While not a contractual requirement, we'd like the hash codes for ands
    // & ors of the same predicates to not collide.
    assertTrue(Predicates.and(p1, p2).hashCode() != Predicates.or(p1, p2).hashCode());
  }
 Pattern Name: FocalMethod_Match - Action: not - Predicate: N/A - Scenario: p1

Project: guava
 Class: PredicatesTest
 Method: testIsInstanceOf_interface
 Body: {
    Predicate<Object> isComparable = Predicates.instanceOf(Comparable.class);

    assertTrue(isComparable.apply(1));
    assertTrue(isComparable.apply(2.0f));
    assertTrue(isComparable.apply(""));
    assertFalse(isComparable.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: isComparable

Project: guava
 Class: PredicatesTest
 Method: testComposeSerialization
 Body: {
    Function<String, String> trim = TrimStringFunction.INSTANCE;
    Predicate<String> equalsFoo = Predicates.equalTo("Foo");
    Predicate<String> trimEqualsFoo = Predicates.compose(equalsFoo, trim);
    SerializableTester.reserializeAndAssert(trimEqualsFoo);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: trimEqualsFoo

Project: guava
 Class: PredicatesTest
 Method: testIsEqualTo_apply
 Body: {
    Predicate<Integer> isOne = Predicates.equalTo(1);

    assertTrue(isOne.apply(1));
    assertFalse(isOne.apply(2));
    assertFalse(isOne.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: isOne

Project: guava
 Class: PredicatesTest
 Method: testIn_apply
 Body: {
    Collection<Integer> nums = Arrays.asList(1, 5);
    Predicate<Integer> isOneOrFive = Predicates.in(nums);

    assertTrue(isOneOrFive.apply(1));
    assertTrue(isOneOrFive.apply(5));
    assertFalse(isOneOrFive.apply(3));
    assertFalse(isOneOrFive.apply(null));
  }
 Pattern Name: FocalMethod_Match - Action: apply - Predicate: N/A - Scenario: isOneOrFive

Project: guava
 Class: FuturesGetUncheckedTest
 Method: testGetUnchecked_RuntimeException
 Body: {
    try {
      getUnchecked(RUNTIME_EXCEPTION_FUTURE);
      fail();
    } catch (RuntimeException expected) {
      assertEquals(RUNTIME_EXCEPTION, expected);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: expected

Project: guava
 Class: IteratorsTest
 Method: testRetainAll
 Body: {
    List<String> list = newArrayList("a", "b", "c", "d", "e");
    assertTrue(Iterators.retainAll(list.iterator(), newArrayList("b", "d", "f")));
    assertEquals(newArrayList("b", "d"), list);
    assertFalse(Iterators.retainAll(list.iterator(), newArrayList("b", "e", "d")));
    assertEquals(newArrayList("b", "d"), list);
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: list

Project: guava
 Class: IteratorsTest
 Method: testPaddedPartition_singleton1
 Body: {
    Iterator<Integer> source = Iterators.singletonIterator(1);
    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 1);
    assertTrue(partitions.hasNext());
    assertTrue(partitions.hasNext());
    assertEquals(ImmutableList.of(1), partitions.next());
    assertFalse(partitions.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testIndexOf_consumedDataWithDuplicates
 Body: {
    Iterator<String> iterator = Lists.newArrayList("manny", "mo", "mo", "jack").iterator();
    assertEquals(1, Iterators.indexOf(iterator, Predicates.equalTo("mo")));
    assertEquals("mo", iterator.next());
    assertEquals("jack", iterator.next());
    assertFalse(iterator.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IteratorsTest
 Method: testNullFriendlyTransform
 Body: {
    Iterator<Integer> input = asList(1, 2, null, 3).iterator();
    Iterator<String> result =
        Iterators.transform(
            input,
            new Function<Integer, String>() {
              @Override
              public String apply(Integer from) {
                return String.valueOf(from);
              }
            });

    List<String> actual = Lists.newArrayList(result);
    List<String> expected = asList("1", "2", "null", "3");
    assertEquals(expected, actual);
  }
 Pattern Name: FocalMethod_Match - Action: transform - Predicate: N/A - Scenario: input

Project: guava
 Class: IteratorsTest
 Method: testForEnumerationTypical
 Body: {
    Enumeration<Integer> enumer = enumerate(1, 2, 3);
    Iterator<Integer> iter = Iterators.forEnumeration(enumer);

    assertTrue(iter.hasNext());
    assertEquals(1, (int) iter.next());
    assertTrue(iter.hasNext());
    assertEquals(2, (int) iter.next());
    assertTrue(iter.hasNext());
    assertEquals(3, (int) iter.next());
    assertFalse(iter.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: forEnumeration - Predicate: N/A - Scenario: enumer

Project: guava
 Class: IteratorsTest
 Method: testConcatPartiallyAdvancedSecond
 Body: {
    Iterator<String> itr1 =
        Iterators.concat(Iterators.singletonIterator("a"), Iterators.forArray("b", "c"));
    assertEquals("a", itr1.next());
    assertEquals("b", itr1.next());
    Iterator<String> itr2 = Iterators.concat(Iterators.singletonIterator("d"), itr1);
    assertEquals("d", itr2.next());
    assertEquals("c", itr2.next());
  }
 Pattern Name: FocalMethod_Match - Action: next - Predicate: N/A - Scenario: itr2

Project: guava
 Class: IteratorsTest
 Method: testForArrayLength0
 Body: {
    String[] array = {"foo", "bar"};
    assertFalse(Iterators.forArray(array, 0, 0, 0).hasNext());
    assertFalse(Iterators.forArray(array, 1, 0, 0).hasNext());
    assertFalse(Iterators.forArray(array, 2, 0, 0).hasNext());
    try {
      Iterators.forArray(array, -1, 0, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      Iterators.forArray(array, 3, 0, 0);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: forArray - Predicate: N/A - Scenario: array

Project: guava
 Class: IteratorsTest
 Method: testIndexOf_consumedData
 Body: {
    Iterator<String> iterator = Lists.newArrayList("manny", "mo", "jack").iterator();
    assertEquals(1, Iterators.indexOf(iterator, Predicates.equalTo("mo")));
    assertEquals("jack", iterator.next());
    assertFalse(iterator.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IteratorsTest
 Method: testPaddedPartition_singleton2
 Body: {
    Iterator<Integer> source = Iterators.singletonIterator(1);
    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 2);
    assertTrue(partitions.hasNext());
    assertTrue(partitions.hasNext());
    assertEquals(asList(1, null), partitions.next());
    assertFalse(partitions.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testCycleOfTwo
 Body: {
    Iterator<String> cycle = Iterators.cycle("a", "b");
    for (int i = 0; i < 3; i++) {
      assertTrue(cycle.hasNext());
      assertEquals("a", cycle.next());
      assertTrue(cycle.hasNext());
      assertEquals("b", cycle.next());
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: i

Project: guava
 Class: IteratorsTest
 Method: testFrequency
 Body: {
    List<String> list = newArrayList("a", null, "b", null, "a", null);
    assertEquals(2, Iterators.frequency(list.iterator(), "a"));
    assertEquals(1, Iterators.frequency(list.iterator(), "b"));
    assertEquals(0, Iterators.frequency(list.iterator(), "c"));
    assertEquals(0, Iterators.frequency(list.iterator(), 4.2));
    assertEquals(3, Iterators.frequency(list.iterator(), null));
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: list

Project: guava
 Class: IteratorsTest
 Method: testPartition_singleton2
 Body: {
    Iterator<Integer> source = Iterators.singletonIterator(1);
    Iterator<List<Integer>> partitions = Iterators.partition(source, 2);
    assertTrue(partitions.hasNext());
    assertTrue(partitions.hasNext());
    assertEquals(ImmutableList.of(1), partitions.next());
    assertFalse(partitions.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testForEnumerationSingleton
 Body: {
    Enumeration<Integer> enumer = enumerate(1);
    Iterator<Integer> iter = Iterators.forEnumeration(enumer);

    assertTrue(iter.hasNext());
    assertTrue(iter.hasNext());
    assertEquals(1, (int) iter.next());
    try {
      iter.remove();
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    assertFalse(iter.hasNext());
    try {
      iter.next();
      fail();
    } catch (NoSuchElementException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: forEnumeration - Predicate: N/A - Scenario: enumer

Project: guava
 Class: IteratorsTest
 Method: testPartitionRandomAccess
 Body: {
    Iterator<Integer> source = asList(1, 2, 3).iterator();
    Iterator<List<Integer>> partitions = Iterators.partition(source, 2);
    assertTrue(partitions.next() instanceof RandomAccess);
    assertTrue(partitions.next() instanceof RandomAccess);
  }
 Pattern Name: FocalMethod_Match - Action: next - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testEmptyListIterator
 Body: {
    ListIterator<String> iterator = Iterators.emptyListIterator();
    assertFalse(iterator.hasNext());
    assertFalse(iterator.hasPrevious());
    assertEquals(0, iterator.nextIndex());
    assertEquals(-1, iterator.previousIndex());
    try {
      iterator.next();
      fail("no exception thrown");
    } catch (NoSuchElementException expected) {
    }
    try {
      iterator.previous();
      fail("no exception thrown");
    } catch (NoSuchElementException expected) {
    }
    try {
      iterator.remove();
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
    try {
      iterator.set("a");
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
    try {
      iterator.add("a");
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IteratorsTest
 Method: testAsEnumerationTypical
 Body: {
    Iterator<Integer> iter = ImmutableList.of(1, 2, 3).iterator();
    Enumeration<Integer> enumer = Iterators.asEnumeration(iter);

    assertTrue(enumer.hasMoreElements());
    assertEquals(1, (int) enumer.nextElement());
    assertTrue(enumer.hasMoreElements());
    assertEquals(2, (int) enumer.nextElement());
    assertTrue(enumer.hasMoreElements());
    assertEquals(3, (int) enumer.nextElement());
    assertFalse(enumer.hasMoreElements());
  }
 Pattern Name: FocalMethod_Match - Action: hasMoreElements - Predicate: N/A - Scenario: enumer

Project: guava
 Class: IteratorsTest
 Method: testPaddedPartitionRandomAccess
 Body: {
    Iterator<Integer> source = asList(1, 2, 3).iterator();
    Iterator<List<Integer>> partitions = Iterators.paddedPartition(source, 2);
    assertTrue(partitions.next() instanceof RandomAccess);
    assertTrue(partitions.next() instanceof RandomAccess);
  }
 Pattern Name: FocalMethod_Match - Action: next - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testPartition_singleton1
 Body: {
    Iterator<Integer> source = Iterators.singletonIterator(1);
    Iterator<List<Integer>> partitions = Iterators.partition(source, 1);
    assertTrue(partitions.hasNext());
    assertTrue(partitions.hasNext());
    assertEquals(ImmutableList.of(1), partitions.next());
    assertFalse(partitions.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: partitions

Project: guava
 Class: IteratorsTest
 Method: testEmptyIterator
 Body: {
    Iterator<String> iterator = Iterators.emptyIterator();
    assertFalse(iterator.hasNext());
    try {
      iterator.next();
      fail("no exception thrown");
    } catch (NoSuchElementException expected) {
    }
    try {
      iterator.remove();
      fail("no exception thrown");
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IteratorsTest
 Method: testConcatContainingNull
 Body: {
    @SuppressWarnings("unchecked")
    Iterator<Iterator<Integer>> input = asList(iterateOver(1, 2), null, iterateOver(3)).iterator();
    Iterator<Integer> result = Iterators.concat(input);
    assertEquals(1, (int) result.next());
    assertEquals(2, (int) result.next());
    try {
      result.hasNext();
      fail("no exception thrown");
    } catch (NullPointerException e) {
    }
    try {
      result.next();
      fail("no exception thrown");
    } catch (NullPointerException e) {
    }
    // There is no way to get "through" to the 3.  Buh-bye
  }
 Pattern Name: FocalMethod_Match - Action: concat - Predicate: N/A - Scenario: input

Project: guava
 Class: IteratorsTest
 Method: testCycleOfOne
 Body: {
    Iterator<String> cycle = Iterators.cycle("a");
    for (int i = 0; i < 3; i++) {
      assertTrue(cycle.hasNext());
      assertEquals("a", cycle.next());
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: i

Project: guava
 Class: IteratorsTest
 Method: testEmptyModifiableIterator
 Body: {
    Iterator<String> iterator = Iterators.emptyModifiableIterator();
    assertFalse(iterator.hasNext());
    try {
      iterator.next();
      fail("Expected NoSuchElementException");
    } catch (NoSuchElementException expected) {
    }
    try {
      iterator.remove();
      fail("Expected IllegalStateException");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: iterator

Project: guava
 Class: IteratorsTest
 Method: testTransform
 Body: {
    Iterator<String> input = asList("1", "2", "3").iterator();
    Iterator<Integer> result =
        Iterators.transform(
            input,
            new Function<String, Integer>() {
              @Override
              public Integer apply(String from) {
                return Integer.valueOf(from);
              }
            });

    List<Integer> actual = Lists.newArrayList(result);
    List<Integer> expected = asList(1, 2, 3);
    assertEquals(expected, actual);
  }
 Pattern Name: FocalMethod_Match - Action: transform - Predicate: N/A - Scenario: input

Project: guava
 Class: IteratorsTest
 Method: testUnmodifiableIteratorShortCircuit
 Body: {
    Iterator<String> mod = Lists.newArrayList("a", "b", "c").iterator();
    UnmodifiableIterator<String> unmod = Iterators.unmodifiableIterator(mod);
    assertNotSame(mod, unmod);
    assertSame(unmod, Iterators.unmodifiableIterator(unmod));
    assertSame(unmod, Iterators.unmodifiableIterator((Iterator<String>) unmod));
  }
 Pattern Name: FocalMethod_Match - Action: unmodifiableIterator - Predicate: N/A - Scenario: unmod

Project: guava
 Class: IteratorsTest
 Method: testRemoveAll
 Body: {
    List<String> list = newArrayList("a", "b", "c", "d", "e");
    assertTrue(Iterators.removeAll(list.iterator(), newArrayList("b", "d", "f")));
    assertEquals(newArrayList("a", "c", "e"), list);
    assertFalse(Iterators.removeAll(list.iterator(), newArrayList("x", "y", "z")));
    assertEquals(newArrayList("a", "c", "e"), list);
  }
 Pattern Name: FocalMethod_Match - Action: iterator - Predicate: N/A - Scenario: list

Project: guava
 Class: IteratorsTest
 Method: testConcatPartiallyAdvancedFirst
 Body: {
    Iterator<String> itr1 =
        Iterators.concat(Iterators.singletonIterator("a"), Iterators.forArray("b", "c"));
    assertEquals("a", itr1.next());
    assertEquals("b", itr1.next());
    Iterator<String> itr2 = Iterators.concat(itr1, Iterators.singletonIterator("d"));
    assertEquals("c", itr2.next());
    assertEquals("d", itr2.next());
  }
 Pattern Name: FocalMethod_Match - Action: next - Predicate: N/A - Scenario: itr2

Project: guava
 Class: MapsTest
 Method: testCapacityForLargeSizes
 Body: {
    int[] largeExpectedSizes =
        new int[] {
          Integer.MAX_VALUE / 2 - 1,
          Integer.MAX_VALUE / 2,
          Integer.MAX_VALUE / 2 + 1,
          Integer.MAX_VALUE - 1,
          Integer.MAX_VALUE
        };
    for (int expectedSize : largeExpectedSizes) {
      int capacity = Maps.capacity(expectedSize);
      assertTrue(
          "capacity (" + capacity + ") must be >= expectedSize (" + expectedSize + ")",
          capacity >= expectedSize);
    }
  }
 Pattern Name: FocalMethod_Match - Action: capacity - Predicate: N/A - Scenario: capacity

Project: guava
 Class: MapsTest
 Method: testSortedMapDifferenceEmptySingleton
 Body: {
    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_EMPTY, SORTED_SINGLETON);
    assertFalse(diff.areEqual());
    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());
    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnRight());
    assertEquals(SORTED_EMPTY, diff.entriesInCommon());
    assertEquals(SORTED_EMPTY, diff.entriesDiffering());
    assertEquals("not equal: only on right={1=2}", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testSortedMapDifferenceEmptyEmpty
 Body: {
    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_EMPTY, SORTED_EMPTY);
    assertTrue(diff.areEqual());
    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnLeft());
    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());
    assertEquals(SORTED_EMPTY, diff.entriesInCommon());
    assertEquals(SORTED_EMPTY, diff.entriesDiffering());
    assertEquals("equal", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testNewHashMapWithExpectedSize_wontGrow
 Body: {
    // before jdk7u40: creates one-bucket table
    // after  jdk7u40: creates empty table
    assertTrue(bucketsOf(Maps.newHashMapWithExpectedSize(0)) <= 1);

    for (int size = 1; size < 200; size++) {
      assertWontGrow(
          size, Maps.newHashMapWithExpectedSize(size), Maps.newHashMapWithExpectedSize(size));
    }
  }
 Pattern Name: FocalMethod_Match - Action: newHashMapWithExpectedSize - Predicate: N/A - Scenario: size

Project: guava
 Class: MapsTest
 Method: testLinkedHashMapWithInitialMap
 Body: {
    Map<String, String> map =
        new LinkedHashMap<String, String>(
            ImmutableMap.of(
                "Hello", "World",
                "first", "second",
                "polygene", "lubricants",
                "alpha", "betical"));

    LinkedHashMap<String, String> copy = Maps.newLinkedHashMap(map);

    Iterator<Entry<String, String>> iter = copy.entrySet().iterator();
    assertTrue(iter.hasNext());
    Entry<String, String> entry = iter.next();
    assertEquals("Hello", entry.getKey());
    assertEquals("World", entry.getValue());
    assertTrue(iter.hasNext());

    entry = iter.next();
    assertEquals("first", entry.getKey());
    assertEquals("second", entry.getValue());
    assertTrue(iter.hasNext());

    entry = iter.next();
    assertEquals("polygene", entry.getKey());
    assertEquals("lubricants", entry.getValue());
    assertTrue(iter.hasNext());

    entry = iter.next();
    assertEquals("alpha", entry.getKey());
    assertEquals("betical", entry.getValue());
    assertFalse(iter.hasNext());
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: MapsTest
 Method: testSubMap_boundedRange
 Body: {
    ImmutableSortedMap<Integer, Integer> map = ImmutableSortedMap.of(2, 0, 4, 0, 6, 0, 8, 0, 10, 0);
    ImmutableSortedMap<Integer, Integer> empty = ImmutableSortedMap.of();

    assertEquals(map, Maps.subMap(map, Range.closed(0, 12)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0), Maps.subMap(map, Range.closed(0, 4)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0, 6, 0), Maps.subMap(map, Range.closed(2, 6)));
    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0), Maps.subMap(map, Range.closed(3, 7)));
    assertEquals(empty, Maps.subMap(map, Range.closed(20, 30)));

    assertEquals(map, Maps.subMap(map, Range.open(0, 12)));
    assertEquals(ImmutableSortedMap.of(2, 0), Maps.subMap(map, Range.open(0, 4)));
    assertEquals(ImmutableSortedMap.of(4, 0), Maps.subMap(map, Range.open(2, 6)));
    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0), Maps.subMap(map, Range.open(3, 7)));
    assertEquals(empty, Maps.subMap(map, Range.open(20, 30)));

    assertEquals(map, Maps.subMap(map, Range.openClosed(0, 12)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0), Maps.subMap(map, Range.openClosed(0, 4)));
    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0), Maps.subMap(map, Range.openClosed(2, 6)));
    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0), Maps.subMap(map, Range.openClosed(3, 7)));
    assertEquals(empty, Maps.subMap(map, Range.openClosed(20, 30)));

    assertEquals(map, Maps.subMap(map, Range.closedOpen(0, 12)));
    assertEquals(ImmutableSortedMap.of(2, 0), Maps.subMap(map, Range.closedOpen(0, 4)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0), Maps.subMap(map, Range.closedOpen(2, 6)));
    assertEquals(ImmutableSortedMap.of(4, 0, 6, 0), Maps.subMap(map, Range.closedOpen(3, 7)));
    assertEquals(empty, Maps.subMap(map, Range.closedOpen(20, 30)));
  }
 Pattern Name: FocalMethod_Match - Action: subMap - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTest
 Method: testNewLinkedHashMapWithExpectedSize_wontGrow
 Body: {
    assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);

    for (int size = 1; size < 200; size++) {
      assertWontGrow(
          size,
          Maps.newLinkedHashMapWithExpectedSize(size),
          Maps.newLinkedHashMapWithExpectedSize(size));
    }
  }
 Pattern Name: FocalMethod_Match - Action: newLinkedHashMapWithExpectedSize - Predicate: N/A - Scenario: size

Project: guava
 Class: MapsTest
 Method: testUniqueIndexDuplicates
 Body: {
    try {
      Map<Integer, String> unused =
          Maps.uniqueIndex(ImmutableSet.of("one", "uno"), Functions.constant(1));
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected.getMessage()).contains("Multimaps.index");
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: expected

Project: guava
 Class: MapsTest
 Method: testAsConverter_serialization
 Body: {
    ImmutableBiMap<String, Integer> biMap =
        ImmutableBiMap.of(
            "one", 1,
            "two", 2);
    Converter<String, Integer> converter = Maps.asConverter(biMap);
    SerializableTester.reserializeAndAssert(converter);
  }
 Pattern Name: FocalMethod_Match - Action: asConverter - Predicate: N/A - Scenario: biMap

Project: guava
 Class: MapsTest
 Method: testAsMapNavigableSubViewKeySetsDoNotSupportAdd
 Body: {
    NavigableMap<String, Integer> map = Maps.asMap(Sets.<String>newTreeSet(), LENGTH_FUNCTION);
    try {
      map.descendingKeySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.subMap("a", true, "z", false).keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.tailMap("a", true).keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.headMap("r", true).keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.headMap("r", false).tailMap("m", true).keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: descendingKeySet - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTest
 Method: testAsConverter_nullConversions
 Body: {
    ImmutableBiMap<String, Integer> biMap =
        ImmutableBiMap.of(
            "one", 1,
            "two", 2);
    Converter<String, Integer> converter = Maps.asConverter(biMap);
    assertNull(converter.convert(null));
    assertNull(converter.reverse().convert(null));
  }
 Pattern Name: FocalMethod_Match - Action: asConverter - Predicate: N/A - Scenario: biMap

Project: guava
 Class: MapsTest
 Method: testMapDifferenceEmptyEmpty
 Body: {
    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, EMPTY);
    assertTrue(diff.areEqual());
    assertEquals(EMPTY, diff.entriesOnlyOnLeft());
    assertEquals(EMPTY, diff.entriesOnlyOnRight());
    assertEquals(EMPTY, diff.entriesInCommon());
    assertEquals(EMPTY, diff.entriesDiffering());
    assertEquals("equal", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testMapDifferenceSingletonEmpty
 Body: {
    MapDifference<Integer, Integer> diff = Maps.difference(SINGLETON, EMPTY);
    assertFalse(diff.areEqual());
    assertEquals(SINGLETON, diff.entriesOnlyOnLeft());
    assertEquals(EMPTY, diff.entriesOnlyOnRight());
    assertEquals(EMPTY, diff.entriesInCommon());
    assertEquals(EMPTY, diff.entriesDiffering());
    assertEquals("not equal: only on left={1=2}", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testAsMapSortedSubViewKeySetsDoNotSupportAdd
 Body: {
    SortedMap<String, Integer> map = Maps.asMap(new NonNavigableSortedSet(), LENGTH_FUNCTION);
    try {
      map.subMap("a", "z").keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.tailMap("a").keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.headMap("r").keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
    try {
      map.headMap("r").tailMap("m").keySet().add("a");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: subMap - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTest
 Method: testMapDifferenceEmptySingleton
 Body: {
    MapDifference<Integer, Integer> diff = Maps.difference(EMPTY, SINGLETON);
    assertFalse(diff.areEqual());
    assertEquals(EMPTY, diff.entriesOnlyOnLeft());
    assertEquals(SINGLETON, diff.entriesOnlyOnRight());
    assertEquals(EMPTY, diff.entriesInCommon());
    assertEquals(EMPTY, diff.entriesDiffering());
    assertEquals("not equal: only on right={1=2}", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testSortedMapDifferenceSingletonEmpty
 Body: {
    SortedMapDifference<Integer, Integer> diff = Maps.difference(SORTED_SINGLETON, SORTED_EMPTY);
    assertFalse(diff.areEqual());
    assertEquals(SORTED_SINGLETON, diff.entriesOnlyOnLeft());
    assertEquals(SORTED_EMPTY, diff.entriesOnlyOnRight());
    assertEquals(SORTED_EMPTY, diff.entriesInCommon());
    assertEquals(SORTED_EMPTY, diff.entriesDiffering());
    assertEquals("not equal: only on left={1=2}", diff.toString());
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapsTest
 Method: testSubMap_halfBoundedRange
 Body: {
    ImmutableSortedMap<Integer, Integer> map = ImmutableSortedMap.of(2, 0, 4, 0, 6, 0, 8, 0, 10, 0);
    ImmutableSortedMap<Integer, Integer> empty = ImmutableSortedMap.of();

    assertEquals(map, Maps.subMap(map, Range.atLeast(0)));
    assertEquals(
        ImmutableSortedMap.of(4, 0, 6, 0, 8, 0, 10, 0), Maps.subMap(map, Range.atLeast(4)));
    assertEquals(ImmutableSortedMap.of(8, 0, 10, 0), Maps.subMap(map, Range.atLeast(7)));
    assertEquals(empty, Maps.subMap(map, Range.atLeast(20)));

    assertEquals(map, Maps.subMap(map, Range.greaterThan(0)));
    assertEquals(ImmutableSortedMap.of(6, 0, 8, 0, 10, 0), Maps.subMap(map, Range.greaterThan(4)));
    assertEquals(ImmutableSortedMap.of(8, 0, 10, 0), Maps.subMap(map, Range.greaterThan(7)));
    assertEquals(empty, Maps.subMap(map, Range.greaterThan(20)));

    assertEquals(empty, Maps.subMap(map, Range.lessThan(0)));
    assertEquals(ImmutableSortedMap.of(2, 0), Maps.subMap(map, Range.lessThan(4)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0, 6, 0), Maps.subMap(map, Range.lessThan(7)));
    assertEquals(map, Maps.subMap(map, Range.lessThan(20)));

    assertEquals(empty, Maps.subMap(map, Range.atMost(0)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0), Maps.subMap(map, Range.atMost(4)));
    assertEquals(ImmutableSortedMap.of(2, 0, 4, 0, 6, 0), Maps.subMap(map, Range.atMost(7)));
    assertEquals(map, Maps.subMap(map, Range.atMost(20)));
  }
 Pattern Name: FocalMethod_Match - Action: subMap - Predicate: N/A - Scenario: map

Project: guava
 Class: SafeTreeMapTest
 Method: testViewSerialization
 Body: {
    Map<String, Integer> map = ImmutableSortedMap.of("one", 1, "two", 2, "three", 3);
    SerializableTester.reserializeAndAssert(map.entrySet());
    SerializableTester.reserializeAndAssert(map.keySet());
    assertEquals(
        Lists.newArrayList(map.values()),
        Lists.newArrayList(SerializableTester.reserialize(map.values())));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: AtomicLongMapTest
 Method: testPut_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    long value = random.nextInt(MAX_ADDEND);
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.put(key, value));
    assertEquals(value, map.get(key));

    assertEquals(value, map.put(key, 0L));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.put(key, value));
    assertEquals(value, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testReplace_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    long value = random.nextInt(MAX_ADDEND);
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertTrue(map.replace(key, 0L, value));
    assertEquals(value, map.get(key));

    assertTrue(map.replace(key, value, 0L));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertTrue(map.replace(key, 0L, value));
    assertEquals(value, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testDecrementAndGet_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(-1L, map.decrementAndGet(key));
    assertEquals(-1L, map.get(key));

    assertEquals(0L, map.incrementAndGet(key));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(-1L, map.decrementAndGet(key));
    assertEquals(-1L, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testEmpty
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    assertEquals(0L, map.get("a"));
    assertEquals(0, map.size());
    assertTrue(map.isEmpty());
    assertFalse(map.remove("a", 1L));
    assertFalse(map.remove("a", 0L));
    assertFalse(map.replace("a", 1L, 0L));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: AtomicLongMapTest
 Method: testRemoveValue_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertFalse(map.remove(key, 0L));
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.put(key, 0L));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertTrue(map.remove(key, 0L));
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testGetAndAdd_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    long value = random.nextInt(MAX_ADDEND);
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.getAndAdd(key, value));
    assertEquals(value, map.get(key));

    assertEquals(value, map.getAndAdd(key, -1 * value));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.getAndAdd(key, value));
    assertEquals(value, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testRemoveZeros
 Body: {
    AtomicLongMap<Object> map = AtomicLongMap.create();
    Set<Object> nonZeroKeys = Sets.newHashSet();
    for (int i = 0; i < ITERATIONS; i++) {
      Object key = new Object();
      long value = i % 2;
      map.put(key, value);
      if (value != 0L) {
        nonZeroKeys.add(key);
      }
    }
    assertEquals(ITERATIONS, map.size());
    assertTrue(map.asMap().containsValue(0L));

    map.removeAllZeros();
    assertFalse(map.asMap().containsValue(0L));
    assertEquals(ITERATIONS / 2, map.size());
    assertEquals(nonZeroKeys, map.asMap().keySet());
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testIncrementAndGet_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(1L, map.incrementAndGet(key));
    assertEquals(1L, map.get(key));

    assertEquals(0L, map.decrementAndGet(key));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(1L, map.incrementAndGet(key));
    assertEquals(1L, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testRemoveIfZero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0, map.size());
    assertTrue(map.isEmpty());
    assertFalse(map.removeIfZero(key));

    assertEquals(1, map.incrementAndGet(key));
    assertFalse(map.removeIfZero(key));
    assertEquals(2, map.incrementAndGet(key));
    assertFalse(map.removeIfZero(key));
    assertEquals(1, map.decrementAndGet(key));
    assertFalse(map.removeIfZero(key));
    assertEquals(0, map.decrementAndGet(key));
    assertTrue(map.removeIfZero(key));
    assertFalse(map.containsKey(key));
  }
 Pattern Name: FocalMethod_Match - Action: removeIfZero - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testAddAndGet_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    long value = random.nextInt(MAX_ADDEND);
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(value, map.addAndGet(key, value));
    assertEquals(value, map.get(key));

    assertEquals(0L, map.addAndGet(key, -1 * value));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(value, map.addAndGet(key, value));
    assertEquals(value, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testRemove_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.remove(key));
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.put(key, 0L));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.remove(key));
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testGetAndIncrement_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.getAndIncrement(key));
    assertEquals(1L, map.get(key));

    assertEquals(1L, map.getAndDecrement(key));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.getAndIncrement(key));
    assertEquals(1L, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testGetAndDecrement_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.getAndDecrement(key));
    assertEquals(-1L, map.get(key));

    assertEquals(-1L, map.getAndIncrement(key));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.getAndDecrement(key));
    assertEquals(-1L, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: AtomicLongMapTest
 Method: testPutIfAbsent_zero
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    String key = "key";
    long value = random.nextInt(MAX_ADDEND);
    assertEquals(0L, map.get(key));
    assertFalse(map.containsKey(key));

    assertEquals(0L, map.putIfAbsent(key, value));
    assertEquals(value, map.get(key));

    assertEquals(value, map.put(key, 0L));
    assertEquals(0L, map.get(key));
    assertTrue(map.containsKey(key));

    assertEquals(0L, map.putIfAbsent(key, value));
    assertEquals(value, map.get(key));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: StringsTest
 Method: testRepeat
 Body: {
    String input = "20";
    assertEquals("", Strings.repeat(input, 0));
    assertEquals("20", Strings.repeat(input, 1));
    assertEquals("2020", Strings.repeat(input, 2));
    assertEquals("202020", Strings.repeat(input, 3));

    assertEquals("", Strings.repeat("", 4));

    for (int i = 0; i < 100; ++i) {
      assertEquals(2 * i, Strings.repeat(input, i).length());
    }

    try {
      Strings.repeat("x", -1);
      fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
      // Massive string
      Strings.repeat("12345678", (1 << 30) + 3);
      fail();
    } catch (ArrayIndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: repeat - Predicate: N/A - Scenario: input

Project: guava
 Class: BiMapEntrySetTester
 Method: testSetValueNullUnsupported
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      try {
        entry.setValue(null);
        fail("Expected NullPointerException");
      } catch (NullPointerException expected) {
      }
      expectUnchanged();
    }
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: BiMapEntrySetTester
 Method: testSetValueNullSupported
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      if (entry.getKey().equals(k0())) {
        entry.setValue(null);
      }
    }
    expectReplacement(entry(k0(), (V) null));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: BiMapEntrySetTester
 Method: testSetValue_valueAbsent
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      if (entry.getKey().equals(k0())) {
        assertEquals("entry.setValue() should return the old value", v0(), entry.setValue(v3()));
      }
    }
    expectReplacement(entry(k0(), v3()));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: BiMapEntrySetTester
 Method: testSetValue_valuePresent
 Body: {
    for (Entry<K, V> entry : getMap().entrySet()) {
      if (entry.getKey().equals(k0())) {
        try {
          entry.setValue(v1());
          fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException expected) {
        }
      }
    }
    expectUnchanged();
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeySetLast
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertSame("foo", sortedTable.rowKeySet().last());
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testSerialization
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    SerializableTester.reserializeAndAssert(table);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeySetFirst
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertSame("bar", sortedTable.rowKeySet().first());
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeyMapSubMap
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c', "dog", 2, 'd');
    Map<String, Map<Integer, Character>> map = sortedTable.rowMap().subMap("cat", "egg");
    assertEquals(ImmutableMap.of(2, 'd'), map.get("dog"));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(ImmutableSet.of("bar", "foo"), sortedTable.rowKeySet());
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_isSorted
 Body: {
    table =
        create(
            "a", 2, 'X', "a", 2, 'X', "b", 3, 'X', "b", 2, 'X', "c", 10, 'X', "c", 10, 'X', "c", 20,
            'X', "d", 15, 'X', "d", 20, 'X', "d", 1, 'X', "e", 5, 'X');
    assertEquals("[1, 2, 3, 5, 10, 15, 20]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowComparator
 Body: {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowComparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowComparator());
  }
 Pattern Name: FocalMethod_Match - Action: rowComparator - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testRowMapValuesAreSorted
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c', "dog", 2, 'd');
    assertTrue(sortedTable.rowMap().get("foo") instanceof SortedMap);
  }
 Pattern Name: FocalMethod_Match - Action: rowMap - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testValuesToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[b, a, c]", table.values().toString());
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_empty
 Body: {
    table = create();
    assertEquals("[]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testCellSetToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[(bar,1)=b, (foo,1)=a, (foo,3)=c]", table.cellSet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: cellSet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeyMapTailMap
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<String, Map<Integer, Character>> map = sortedTable.rowMap().tailMap("cat");
    assertEquals(1, map.size());
    assertEquals(ImmutableMap.of(1, 'a', 3, 'c'), map.get("foo"));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(Collections.singleton("bar"), sortedTable.rowKeySet());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: map

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_isSortedWithRealComparator
 Body: {
    table =
        create(
            String.CASE_INSENSITIVE_ORDER,
            Ordering.natural().reverse(),
            "a",
            2,
            'X',
            "a",
            2,
            'X',
            "b",
            3,
            'X',
            "b",
            2,
            'X',
            "c",
            10,
            'X',
            "c",
            10,
            'X',
            "c",
            20,
            'X',
            "d",
            15,
            'X',
            "d",
            20,
            'X',
            "d",
            1,
            'X',
            "e",
            5,
            'X');
    assertEquals("[20, 15, 10, 5, 3, 2, 1]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_oneColumn
 Body: {
    table = create("a", 1, 'X', "b", 1, 'X');
    assertEquals("[1]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeyMapHeadMap
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<String, Map<Integer, Character>> map = sortedTable.rowMap().headMap("cat");
    assertEquals(1, map.size());
    assertEquals(ImmutableMap.of(1, 'b'), map.get("bar"));
    map.clear();
    assertTrue(map.isEmpty());
    assertEquals(Collections.singleton("foo"), sortedTable.rowKeySet());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: map

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeySetToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[bar, foo]", table.rowKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowMapComparator
 Body: {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowMap().comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowMap().comparator());
  }
 Pattern Name: FocalMethod_Match - Action: rowMap - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testRowMapLastKey
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertSame("foo", sortedTable.rowMap().lastKey());
  }
 Pattern Name: FocalMethod_Match - Action: rowMap - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_oneRow
 Body: {
    table = create("a", 2, 'X', "a", 1, 'X');
    assertEquals("[1, 2]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowKeySetComparator
 Body: {
    sortedTable = TreeBasedTable.create();
    assertSame(Ordering.natural(), sortedTable.rowKeySet().comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    assertSame(Collections.reverseOrder(), sortedTable.rowKeySet().comparator());
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnComparator
 Body: {
    sortedTable = TreeBasedTable.create();
    sortedTable.put("", 42, 'x');
    assertSame(Ordering.natural(), sortedTable.columnComparator());
    assertSame(
        Ordering.natural(),
        ((SortedMap<Integer, Character>) sortedTable.rowMap().values().iterator().next())
            .comparator());

    sortedTable = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    sortedTable.put("", 42, 'x');
    assertSame(Ordering.usingToString(), sortedTable.columnComparator());
    assertSame(
        Ordering.usingToString(),
        ((SortedMap<Integer, Character>) sortedTable.rowMap().values().iterator().next())
            .comparator());
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: TreeBasedTableTest
 Method: testColumnKeySet_oneEntry
 Body: {
    table = create("a", 1, 'X');
    assertEquals("[1]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("{bar={1=b}, foo={1=a, 3=c}}", table.toString());
    assertEquals("{bar={1=b}, foo={1=a, 3=c}}", table.rowMap().toString());
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testCreateExplicitComparators
 Body: {
    table = TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    table.put("foo", 3, 'a');
    table.put("foo", 12, 'b');
    table.put("bar", 5, 'c');
    table.put("cat", 8, 'd');
    assertThat(table.rowKeySet()).containsExactly("foo", "cat", "bar").inOrder();
    assertThat(table.row("foo").keySet()).containsExactly(12, 3).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: table

Project: guava
 Class: TreeBasedTableTest
 Method: testRowMapFirstKey
 Body: {
    sortedTable = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertSame("bar", sortedTable.rowMap().firstKey());
  }
 Pattern Name: FocalMethod_Match - Action: rowMap - Predicate: N/A - Scenario: sortedTable

Project: guava
 Class: SettableFutureTest
 Method: testSetValue_simpleThreaded
 Body: {
    SettableFuture<Integer> future = SettableFuture.create();
    assertTrue(future.set(42));
    // Later attempts to set the future should return false.
    assertFalse(future.set(23));
    assertFalse(future.setException(new Exception("bar")));
    assertFalse(future.setFuture(SettableFuture.<Integer>create()));
    // Check that the future has been set properly.
    assertTrue(future.isDone());
    assertFalse(future.isCancelled());
    assertEquals(42, (int) future.get());
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: future

Project: guava
 Class: StripedTest
 Method: testMaxSize
 Body: {
    for (Striped<?> striped :
        ImmutableList.of(
            Striped.lazyWeakLock(Integer.MAX_VALUE),
            Striped.lazyWeakSemaphore(Integer.MAX_VALUE, Integer.MAX_VALUE),
            Striped.lazyWeakReadWriteLock(Integer.MAX_VALUE))) {
      for (int i = 0; i < 3; i++) {
        // doesn't throw exception
        Object unused = striped.getAt(Integer.MAX_VALUE - i);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: getAt - Predicate: N/A - Scenario: striped

Project: guava
 Class: StripedTest
 Method: testBasicInvariants
 Body: {
    for (Striped<?> striped : allImplementations()) {
      assertBasicInvariants(striped);
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: striped

Project: guava
 Class: StripedTest
 Method: testBulkGetReturnsSorted
 Body: {
    for (Striped<?> striped : allImplementations()) {
      Map<Object, Integer> indexByLock = Maps.newHashMap();
      for (int i = 0; i < striped.size(); i++) {
        indexByLock.put(striped.getAt(i), i);
      }

      // ensure that bulkGet returns locks in monotonically increasing order
      for (int objectsNum = 1; objectsNum <= striped.size() * 2; objectsNum++) {
        Set<Object> objects = Sets.newHashSetWithExpectedSize(objectsNum);
        for (int i = 0; i < objectsNum; i++) {
          objects.add(new Object());
        }

        Iterable<?> locks = striped.bulkGet(objects);
        assertTrue(Ordering.natural().onResultOf(Functions.forMap(indexByLock)).isOrdered(locks));

        // check idempotency
        Iterable<?> locks2 = striped.bulkGet(objects);
        assertEquals(Lists.newArrayList(locks), Lists.newArrayList(locks2));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: newHashSetWithExpectedSize - Predicate: N/A - Scenario: objectsNum

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_trimmedBoth
 Body: {
    Map<String, String> m =
        COMMA_SPLITTER
            .trimResults()
            .withKeyValueSeparator(Splitter.on(':').trimResults())
            .split("boy  : tom , girl: tina , cat  : kitty , dog: tommy ");
    ImmutableMap<String, String> expected =
        ImmutableMap.of("boy", "tom", "girl", "tina", "cat", "kitty", "dog", "tommy");
    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_CharacterSeparator
 Body: {
    // try different delimiters.
    Map<String, String> m =
        Splitter.on(",").withKeyValueSeparator(':').split("boy:tom,girl:tina,cat:kitty,dog:tommy");
    ImmutableMap<String, String> expected =
        ImmutableMap.of("boy", "tom", "girl", "tina", "cat", "kitty", "dog", "tommy");

    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_multiCharacterSeparator
 Body: {
    // try different delimiters.
    Map<String, String> m =
        Splitter.on(",")
            .withKeyValueSeparator(":^&")
            .split("boy:^&tom,girl:^&tina,cat:^&kitty,dog:^&tommy");
    ImmutableMap<String, String> expected =
        ImmutableMap.of("boy", "tom", "girl", "tina", "cat", "kitty", "dog", "tommy");

    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_trimmedEntries
 Body: {
    Map<String, String> m =
        COMMA_SPLITTER
            .trimResults()
            .withKeyValueSeparator(":")
            .split("boy  : tom , girl: tina , cat  : kitty , dog: tommy ");
    ImmutableMap<String, String> expected =
        ImmutableMap.of("boy  ", " tom", "girl", " tina", "cat  ", " kitty", "dog", " tommy");

    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_notTrimmed
 Body: {
    Map<String, String> m =
        COMMA_SPLITTER
            .withKeyValueSeparator(":")
            .split(" boy:tom , girl: tina , cat :kitty , dog:  tommy ");
    ImmutableMap<String, String> expected =
        ImmutableMap.of(" boy", "tom ", " girl", " tina ", " cat ", "kitty ", " dog", "  tommy ");
    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: SplitterTest
 Method: testMapSplitter_trimmedKeyValue
 Body: {
    Map<String, String> m =
        COMMA_SPLITTER
            .withKeyValueSeparator(Splitter.on(':').trimResults())
            .split("boy  : tom , girl: tina , cat  : kitty , dog: tommy ");
    ImmutableMap<String, String> expected =
        ImmutableMap.of("boy", "tom", "girl", "tina", "cat", "kitty", "dog", "tommy");
    assertThat(m).isEqualTo(expected);
    assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: expected

Project: guava
 Class: IntsTest
 Method: testTryParse_radix
 Body: {
    for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
      radixEncodeParseAndAssertEquals(0, radix);
      radixEncodeParseAndAssertEquals(8000, radix);
      radixEncodeParseAndAssertEquals(-8000, radix);
      radixEncodeParseAndAssertEquals(GREATEST, radix);
      radixEncodeParseAndAssertEquals(LEAST, radix);
      assertNull("Radix: " + radix, Ints.tryParse("9999999999999999", radix));
      assertNull(
          "Radix: " + radix, Ints.tryParse(Long.toString((long) GREATEST + 1, radix), radix));
      assertNull("Radix: " + radix, Ints.tryParse(Long.toString((long) LEAST - 1, radix), radix));
    }
    assertNull("Hex string and dec parm", Ints.tryParse("FFFF", 10));
    assertEquals("Mixed hex case", 65535, (int) Ints.tryParse("ffFF", 16));
  }
 Pattern Name: FocalMethod_Match - Action: tryParse - Predicate: N/A - Scenario: radix

Project: guava
 Class: IntsTest
 Method: testStringConverter_reverse
 Body: {
    Converter<String, Integer> converter = Ints.stringConverter();
    assertEquals("1", converter.reverse().convert(1));
    assertEquals("0", converter.reverse().convert(0));
    assertEquals("-1", converter.reverse().convert(-1));
    assertEquals("255", converter.reverse().convert(0xff));
    assertEquals("255", converter.reverse().convert(0xFF));
    assertEquals("-255", converter.reverse().convert(-0xFF));
    assertEquals("438", converter.reverse().convert(0666));
  }
 Pattern Name: FocalMethod_Match - Action: reverse - Predicate: N/A - Scenario: converter

Project: guava
 Class: IntsTest
 Method: testByteArrayRoundTrips
 Body: {
    Random r = new Random(5);
    byte[] b = new byte[Ints.BYTES];

    // total overkill, but, it takes 0.1 sec so why not...
    for (int i = 0; i < 10000; i++) {
      int num = r.nextInt();
      assertEquals(num, Ints.fromByteArray(Ints.toByteArray(num)));

      r.nextBytes(b);
      assertTrue(Arrays.equals(b, Ints.toByteArray(Ints.fromByteArray(b))));
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextBytes - Predicate: N/A - Scenario: b

Project: guava
 Class: IntsTest
 Method: testStringConverter_convert
 Body: {
    Converter<String, Integer> converter = Ints.stringConverter();
    assertEquals((Integer) 1, converter.convert("1"));
    assertEquals((Integer) 0, converter.convert("0"));
    assertEquals((Integer) (-1), converter.convert("-1"));
    assertEquals((Integer) 255, converter.convert("0xff"));
    assertEquals((Integer) 255, converter.convert("0xFF"));
    assertEquals((Integer) (-255), converter.convert("-0xFF"));
    assertEquals((Integer) 255, converter.convert("#0000FF"));
    assertEquals((Integer) 438, converter.convert("0666"));
  }
 Pattern Name: FocalMethod_Match - Action: convert - Predicate: N/A - Scenario: converter

Project: guava
 Class: CharSinkTest
 Method: testClosesOnErrors_copyingFromCharSourceThatThrows
 Body: {
    for (TestOption option : EnumSet.of(OPEN_THROWS, READ_THROWS, CLOSE_THROWS)) {
      TestCharSource failSource = new TestCharSource(STRING, option);
      TestCharSink okSink = new TestCharSink();
      try {
        failSource.copyTo(okSink);
        fail();
      } catch (IOException expected) {
      }
      // ensure writer was closed IF it was opened (depends on implementation whether or not it's
      // opened at all if source.newReader() throws).
      assertTrue(
          "stream not closed when copying from source with option: " + option,
          !okSink.wasStreamOpened() || okSink.wasStreamClosed());
    }
  }
 Pattern Name: FocalMethod_Match - Action: copyTo - Predicate: N/A - Scenario: okSink

Project: guava
 Class: UnsignedIntsTest
 Method: testParseIntWithRadix
 Body: {
    for (long a : UNSIGNED_INTS) {
      for (int radix = Character.MIN_RADIX; radix <= Character.MAX_RADIX; radix++) {
        assertEquals((int) a, UnsignedInts.parseUnsignedInt(Long.toString(a, radix), radix));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: radix

Project: guava
 Class: UnsignedIntsTest
 Method: testDivideRemainderEuclideanProperty
 Body: {
    // Use a seed so that the test is deterministic:
    Random r = new Random(0L);
    for (int i = 0; i < 1000000; i++) {
      int dividend = r.nextInt();
      int divisor = r.nextInt();
      // Test that the Euclidean property is preserved:
      assertTrue(
          dividend
                  - (divisor * UnsignedInts.divide(dividend, divisor)
                      + UnsignedInts.remainder(dividend, divisor))
              == 0);
    }
  }
 Pattern Name: FocalMethod_Match - Action: nextInt - Predicate: N/A - Scenario: r

Project: guava
 Class: UnsignedIntsTest
 Method: testToString
 Body: {
    int[] bases = {2, 5, 7, 8, 10, 16};
    for (long a : UNSIGNED_INTS) {
      for (int base : bases) {
        assertEquals(UnsignedInts.toString((int) a, base), Long.toString(a, base));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: bases

Project: guava
 Class: AbstractIteratorTest
 Method: testSneakyThrow
 Body: {
    Iterator<Integer> iter =
        new AbstractIterator<Integer>() {
          boolean haveBeenCalled;

          @Override
          public Integer computeNext() {
            if (haveBeenCalled) {
              fail("Should not have been called again");
            } else {
              haveBeenCalled = true;
              sneakyThrow(new SomeCheckedException());
            }
            return null; // never reached
          }
        };

    // The first time, the sneakily-thrown exception comes out
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (Exception e) {
      if (!(e instanceof SomeCheckedException)) {
        throw e;
      }
    }

    // But the second time, AbstractIterator itself throws an ISE
    try {
      iter.hasNext();
      fail("No exception thrown");
    } catch (IllegalStateException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasNext - Predicate: N/A - Scenario: e

Project: guava
 Class: IntMathTest
 Method: testCeilingPowerOfTwoNegative
 Body: {
    for (int x : NEGATIVE_INTEGER_CANDIDATES) {
      try {
        IntMath.ceilingPowerOfTwo(x);
        fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: ceilingPowerOfTwo - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testSqrtNegativeAlwaysThrows
 Body: {
    for (int x : NEGATIVE_INTEGER_CANDIDATES) {
      for (RoundingMode mode : RoundingMode.values()) {
        try {
          IntMath.sqrt(x, mode);
          fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: sqrt - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testSaturatedPow
 Body: {
    for (int a : ALL_INTEGER_CANDIDATES) {
      for (int b : EXPONENTS) {
        assertOperationEquals(
            a, b, "s^", saturatedCast(valueOf(a).pow(b)), IntMath.saturatedPow(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: pow - Predicate: N/A - Scenario: b

Project: guava
 Class: IntMathTest
 Method: testSaturatedMultiply
 Body: {
    for (int a : ALL_INTEGER_CANDIDATES) {
      for (int b : ALL_INTEGER_CANDIDATES) {
        assertOperationEquals(
            a,
            b,
            "s*",
            saturatedCast(valueOf(a).multiply(valueOf(b))),
            IntMath.saturatedMultiply(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: multiply - Predicate: N/A - Scenario: b

Project: guava
 Class: IntMathTest
 Method: testFloorPowerOfTwoNegative
 Body: {
    for (int x : NEGATIVE_INTEGER_CANDIDATES) {
      try {
        IntMath.floorPowerOfTwo(x);
        fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: floorPowerOfTwo - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testLessThanBranchFree
 Body: {
    for (int x : ALL_INTEGER_CANDIDATES) {
      for (int y : ALL_INTEGER_CANDIDATES) {
        if (LongMath.fitsInInt((long) x - y)) {
          int expected = (x < y) ? 1 : 0;
          int actual = IntMath.lessThanBranchFree(x, y);
          assertEquals(expected, actual);
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: fitsInInt - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testCeilingPowerOfTwo
 Body: {
    for (int x : POSITIVE_INTEGER_CANDIDATES) {
      BigInteger expectedResult = BigIntegerMath.ceilingPowerOfTwo(BigInteger.valueOf(x));
      if (fitsInInt(expectedResult)) {
        assertEquals(expectedResult.intValue(), IntMath.ceilingPowerOfTwo(x));
      } else {
        try {
          IntMath.ceilingPowerOfTwo(x);
          fail("Expected ArithmeticException");
        } catch (ArithmeticException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: valueOf - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testSaturatedSubtract
 Body: {
    for (int a : ALL_INTEGER_CANDIDATES) {
      for (int b : ALL_INTEGER_CANDIDATES) {
        assertOperationEquals(
            a,
            b,
            "s-",
            saturatedCast(valueOf(a).subtract(valueOf(b))),
            IntMath.saturatedSubtract(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: subtract - Predicate: N/A - Scenario: b

Project: guava
 Class: IntMathTest
 Method: testMod
 Body: {
    for (int x : ALL_INTEGER_CANDIDATES) {
      for (int m : POSITIVE_INTEGER_CANDIDATES) {
        assertEquals(valueOf(x).mod(valueOf(m)).intValue(), IntMath.mod(x, m));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: mod - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testModNegativeModulusFails
 Body: {
    for (int x : POSITIVE_INTEGER_CANDIDATES) {
      for (int m : NEGATIVE_INTEGER_CANDIDATES) {
        try {
          IntMath.mod(x, m);
          fail("Expected ArithmeticException");
        } catch (ArithmeticException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: mod - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testMean
 Body: {
    // Odd-sized ranges have an obvious mean
    assertMean(2, 1, 3);

    assertMean(-2, -3, -1);
    assertMean(0, -1, 1);
    assertMean(1, -1, 3);
    assertMean((1 << 30) - 1, -1, Integer.MAX_VALUE);

    // Even-sized ranges should prefer the lower mean
    assertMean(2, 1, 4);
    assertMean(-3, -4, -1);
    assertMean(0, -1, 2);
    assertMean(0, Integer.MIN_VALUE + 2, Integer.MAX_VALUE);
    assertMean(0, 0, 1);
    assertMean(-1, -1, 0);
    assertMean(-1, Integer.MIN_VALUE, Integer.MAX_VALUE);

    // x == y == mean
    assertMean(1, 1, 1);
    assertMean(0, 0, 0);
    assertMean(-1, -1, -1);
    assertMean(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
    assertMean(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);

    // Exhaustive checks
    for (int x : ALL_INTEGER_CANDIDATES) {
      for (int y : ALL_INTEGER_CANDIDATES) {
        assertMean(x, y);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testGCD
 Body: {
    for (int a : POSITIVE_INTEGER_CANDIDATES) {
      for (int b : POSITIVE_INTEGER_CANDIDATES) {
        assertEquals(valueOf(a).gcd(valueOf(b)), valueOf(IntMath.gcd(a, b)));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: gcd - Predicate: N/A - Scenario: b

Project: guava
 Class: IntMathTest
 Method: testModZeroModulusFails
 Body: {
    for (int x : ALL_INTEGER_CANDIDATES) {
      try {
        IntMath.mod(x, 0);
        fail("Expected ArithmeticException");
      } catch (ArithmeticException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: mod - Predicate: N/A - Scenario: x

Project: guava
 Class: IntMathTest
 Method: testSaturatedAdd
 Body: {
    for (int a : ALL_INTEGER_CANDIDATES) {
      for (int b : ALL_INTEGER_CANDIDATES) {
        assertOperationEquals(
            a, b, "s+", saturatedCast(valueOf(a).add(valueOf(b))), IntMath.saturatedAdd(a, b));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: b

Project: guava
 Class: SafeTreeSetTest
 Method: testViewSerialization
 Body: {
    Map<String, Integer> map = ImmutableSortedMap.of("one", 1, "two", 2, "three", 3);
    SerializableTester.reserializeAndAssert(map.entrySet());
    SerializableTester.reserializeAndAssert(map.keySet());
    assertEquals(
        Lists.newArrayList(map.values()),
        Lists.newArrayList(SerializableTester.reserialize(map.values())));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: MapCacheTest
 Method: testKeySetIterator
 Body: {
    mapCache.put("A", "A_value");
    mapCache.put("B", "B_value");
    mapCache.put("C", "C_value");

    assertThat(mapCache.unmodifiableKeySet()).hasSize(3);
    for (String key : mapCache.unmodifiableKeySet()) {
      assertThat(mapCache.get(key)).isEqualTo(key + "_value");
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: key

Project: guava
 Class: MapCacheTest
 Method: testRemoveEqualKeyWithDifferentReference
 Body: {
    String fooReference1 = new String("foo");
    String fooReference2 = new String("foo");
    assertThat(fooReference1).isNotSameAs(fooReference2);

    assertThat(mapCache.put(fooReference1, "bar")).isNull();
    assertThat(mapCache.get(fooReference1)).isEqualTo("bar"); // ensure first reference is cached
    assertThat(mapCache.remove(fooReference2)).isEqualTo("bar");
    assertThat(mapCache.get(fooReference1)).isNull();
  }
 Pattern Name: FocalMethod_Match - Action: isNotSameAs - Predicate: N/A - Scenario: fooReference2

Project: guava
 Class: LinkedHashMultisetTest
 Method: testCreateFromIterable
 Body: {
    Multiset<String> multiset = LinkedHashMultiset.create(Arrays.asList("foo", "bar", "foo"));
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals("[foo x 2, bar]", multiset.toString());
  }
 Pattern Name: FocalMethod_Match - Action: size - Predicate: N/A - Scenario: multiset

Project: guava
 Class: ConfigurableSimpleDirectedGraphTest
 Method: addEdge_selfLoop
 Body: {
    try {
      putEdge(N1, N1);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: RegularImmutableAsListTest
 Method: testDoesntCheckForNull
 Body: {
    ImmutableSet<Integer> set = ImmutableSet.of(1, 2, 3);
    new RegularImmutableAsList<Integer>(set, new Object[] {null, null, null});
    // shouldn't throw!
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: set

Project: guava
 Class: GeneralRangeTest
 Method: testLowerRange
 Body: {
    for (BoundType lBoundType : BoundType.values()) {
      GeneralRange<Integer> range = GeneralRange.downTo(ORDERING, 3, lBoundType);
      for (Integer i : IN_ORDER_VALUES) {
        assertEquals(
            ORDERING.compare(i, 3) > 0 || (ORDERING.compare(i, 3) == 0 && lBoundType == CLOSED),
            range.contains(i));
        assertEquals(
            ORDERING.compare(i, 3) < 0 || (ORDERING.compare(i, 3) == 0 && lBoundType == OPEN),
            range.tooLow(i));
        assertFalse(range.tooHigh(i));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: downTo - Predicate: N/A - Scenario: lBoundType

Project: guava
 Class: GeneralRangeTest
 Method: testUpperRange
 Body: {
    for (BoundType lBoundType : BoundType.values()) {
      GeneralRange<Integer> range = GeneralRange.upTo(ORDERING, 3, lBoundType);
      for (Integer i : IN_ORDER_VALUES) {
        assertEquals(
            ORDERING.compare(i, 3) < 0 || (ORDERING.compare(i, 3) == 0 && lBoundType == CLOSED),
            range.contains(i));
        assertEquals(
            ORDERING.compare(i, 3) > 0 || (ORDERING.compare(i, 3) == 0 && lBoundType == OPEN),
            range.tooHigh(i));
        assertFalse(range.tooLow(i));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: upTo - Predicate: N/A - Scenario: lBoundType

Project: guava
 Class: SortedMapNavigationTester
 Method: testHeadMap
 Body: {
    List<Entry<K, V>> entries =
        Helpers.copyToList(
            getSubjectGenerator()
                .getSampleElements(getSubjectGenerator().getCollectionSize().getNumElements()));
    Collections.sort(entries, Helpers.<K, V>entryComparator(navigableMap.comparator()));
    for (int i = 0; i < entries.size(); i++) {
      assertEqualInOrder(
          entries.subList(0, i), navigableMap.headMap(entries.get(i).getKey()).entrySet());
    }
  }
 Pattern Name: FocalMethod_Match - Action: sort - Predicate: N/A - Scenario: entries

Project: guava
 Class: SortedMapNavigationTester
 Method: testSubMap
 Body: {
    List<Entry<K, V>> entries =
        Helpers.copyToList(
            getSubjectGenerator()
                .getSampleElements(getSubjectGenerator().getCollectionSize().getNumElements()));
    Collections.sort(entries, Helpers.<K, V>entryComparator(navigableMap.comparator()));
    for (int i = 0; i < entries.size(); i++) {
      for (int j = i + 1; j < entries.size(); j++) {
        assertEqualInOrder(
            entries.subList(i, j),
            navigableMap.subMap(entries.get(i).getKey(), entries.get(j).getKey()).entrySet());
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: sort - Predicate: N/A - Scenario: entries

Project: guava
 Class: SortedMapNavigationTester
 Method: testTailMap
 Body: {
    List<Entry<K, V>> entries =
        Helpers.copyToList(
            getSubjectGenerator()
                .getSampleElements(getSubjectGenerator().getCollectionSize().getNumElements()));
    Collections.sort(entries, Helpers.<K, V>entryComparator(navigableMap.comparator()));
    for (int i = 0; i < entries.size(); i++) {
      assertEqualInOrder(
          entries.subList(i, entries.size()),
          navigableMap.tailMap(entries.get(i).getKey()).entrySet());
    }
  }
 Pattern Name: FocalMethod_Match - Action: sort - Predicate: N/A - Scenario: entries

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutNullValue
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put(null, 1);
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    try {
      builder.put("foo", null);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll("foo", Arrays.asList(1, null, 3));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll("foo", 4, null, 6);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(toPut);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testCopyOfEmpty
 Body: {
    HashMultimap<String, Integer> input = HashMultimap.create();
    Multimap<String, Integer> multimap = ImmutableSetMultimap.copyOf(input);
    assertEquals(multimap, input);
    assertEquals(input, multimap);
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: input

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testSortedSerialization
 Body: {
    Multimap<String, Integer> multimap =
        new ImmutableSetMultimap.Builder<String, Integer>()
            .orderKeysBy(Ordering.natural().reverse())
            .orderValuesBy(Ordering.usingToString())
            .put("a", 2)
            .put("a", 10)
            .put("b", 1)
            .build();
    multimap = SerializableTester.reserialize(multimap);
    assertThat(multimap.keySet()).containsExactly("b", "a").inOrder();
    assertThat(multimap.get("a")).containsExactly(10, 2).inOrder();
    assertEquals(
        Ordering.usingToString(), ((ImmutableSortedSet<Integer>) multimap.get("a")).comparator());
    assertEquals(
        Ordering.usingToString(), ((ImmutableSortedSet<Integer>) multimap.get("z")).comparator());
  }
 Pattern Name: FocalMethod_Match - Action: reserialize - Predicate: N/A - Scenario: multimap

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutNullKey
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", null);
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    try {
      builder.put(null, 1);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(null, Arrays.asList(1, 2, 3));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(null, 1, 2, 3);
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.putAll(toPut);
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: builder - Predicate: N/A - Scenario: builder

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testEmptyMultimapReads
 Body: {
    Multimap<String, Integer> multimap = ImmutableSetMultimap.of();
    assertFalse(multimap.containsKey("foo"));
    assertFalse(multimap.containsValue(1));
    assertFalse(multimap.containsEntry("foo", 1));
    assertTrue(multimap.entries().isEmpty());
    assertTrue(multimap.equals(HashMultimap.create()));
    assertEquals(Collections.emptySet(), multimap.get("foo"));
    assertEquals(0, multimap.hashCode());
    assertTrue(multimap.isEmpty());
    assertEquals(HashMultiset.create(), multimap.keys());
    assertEquals(Collections.emptySet(), multimap.keySet());
    assertEquals(0, multimap.size());
    assertTrue(multimap.values().isEmpty());
    assertEquals("{}", multimap.toString());
  }
 Pattern Name: FocalMethod_Match - Action: containsKey - Predicate: N/A - Scenario: multimap

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testSerialization
 Body: {
    Multimap<String, Integer> multimap = createMultimap();
    SerializableTester.reserializeAndAssert(multimap);
    assertEquals(multimap.size(), SerializableTester.reserialize(multimap).size());
    SerializableTester.reserializeAndAssert(multimap.get("foo"));
    LenientSerializableTester.reserializeAndAssertLenient(multimap.keySet());
    LenientSerializableTester.reserializeAndAssertLenient(multimap.keys());
    SerializableTester.reserializeAndAssert(multimap.asMap());
    Collection<Integer> valuesCopy = SerializableTester.reserialize(multimap.values());
    assertEquals(HashMultiset.create(multimap.values()), HashMultiset.create(valuesCopy));
  }
 Pattern Name: FocalMethod_Match - Action: create - Predicate: N/A - Scenario: valuesCopy

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testMultimapReads
 Body: {
    Multimap<String, Integer> multimap = createMultimap();
    assertTrue(multimap.containsKey("foo"));
    assertFalse(multimap.containsKey("cat"));
    assertTrue(multimap.containsValue(1));
    assertFalse(multimap.containsValue(5));
    assertTrue(multimap.containsEntry("foo", 1));
    assertFalse(multimap.containsEntry("cat", 1));
    assertFalse(multimap.containsEntry("foo", 5));
    assertFalse(multimap.entries().isEmpty());
    assertEquals(3, multimap.size());
    assertFalse(multimap.isEmpty());
    assertEquals("{foo=[1, 3], bar=[2]}", multimap.toString());
  }
 Pattern Name: FocalMethod_Match - Action: containsKey - Predicate: N/A - Scenario: multimap

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilder_withImmutableEntryAndNullContents
 Body: {
    Builder<String, Integer> builder = new Builder<>();
    try {
      builder.put(Maps.immutableEntry("one", (Integer) null));
      fail();
    } catch (NullPointerException expected) {
    }
    try {
      builder.put(Maps.immutableEntry((String) null, 1));
      fail();
    } catch (NullPointerException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: builder

Project: guava
 Class: ArrayTableTest
 Method: testToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals(
        "{foo={1=a, 2=null, 3=c}, "
            + "bar={1=b, 2=null, 3=null}, "
            + "cat={1=null, 2=null, 3=null}}",
        table.toString());
    assertEquals(
        "{foo={1=a, 2=null, 3=c}, "
            + "bar={1=b, 2=null, 3=null}, "
            + "cat={1=null, 2=null, 3=null}}",
        table.rowMap().toString());
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testColumnKeySetToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[1, 2, 3]", table.columnKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: columnKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testCreateCopyEmptyTable
 Body: {
    Table<String, Integer, Character> original = HashBasedTable.create();
    ArrayTable<String, Integer, Character> copy = ArrayTable.create(original);
    assertThat(copy).isEqualTo(original);
    assertThat(copy)
        .isEqualTo(ArrayTable.create(Arrays.<String>asList(), Arrays.<Integer>asList()));
    assertThat(copy).isEmpty();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: copy

Project: guava
 Class: ArrayTableTest
 Method: testColumnPutIllegal
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<String, Character> map = table.column(3);
    try {
      map.put("dog", 'd');
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasMessage("Row dog not in [foo, bar, cat]");
    }
  }
 Pattern Name: FocalMethod_Match - Action: column - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testPutIllegal
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    try {
      table.put("dog", 1, 'd');
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasMessage("Row dog not in [foo, bar, cat]");
    }
    try {
      table.put("foo", 4, 'd');
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasMessage("Column 4 not in [1, 2, 3]");
    }
    assertFalse(table.containsValue('d'));
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testErase
 Body: {
    ArrayTable<String, Integer, Character> table =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals((Character) 'b', table.erase("bar", 1));
    assertNull(table.get("bar", 1));
    assertEquals(9, table.size());
    assertNull(table.erase("bar", 1));
    assertNull(table.erase("foo", 2));
    assertNull(table.erase("dog", 1));
    assertNull(table.erase("bar", 5));
    assertNull(table.erase(null, 1));
    assertNull(table.erase("bar", null));
  }
 Pattern Name: FocalMethod_Match - Action: erase - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testValuesToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[a, null, c, b, null, null, null, null, null]", table.values().toString());
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testRowKeySetToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals("[foo, bar, cat]", table.rowKeySet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: rowKeySet - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testCellSetToString_ordered
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals(
        "[(foo,1)=a, (foo,2)=null, (foo,3)=c, "
            + "(bar,1)=b, (bar,2)=null, (bar,3)=null, "
            + "(cat,1)=null, (cat,2)=null, (cat,3)=null]",
        table.cellSet().toString());
  }
 Pattern Name: FocalMethod_Match - Action: cellSet - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testSet
 Body: {
    ArrayTable<String, Integer, Character> table =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals((Character) 'b', table.set(1, 0, 'd'));
    assertEquals((Character) 'd', table.get("bar", 1));
    assertNull(table.set(2, 0, 'e'));
    assertEquals((Character) 'e', table.get("cat", 1));
    assertEquals((Character) 'a', table.set(0, 0, null));
    assertNull(table.get("foo", 1));
    try {
      table.set(1, 3, 'z');
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.set(1, -1, 'z');
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.set(3, 2, 'z');
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.set(-1, 2, 'z');
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    assertFalse(table.containsValue('z'));
  }
 Pattern Name: FocalMethod_Match - Action: set - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testRowMissing
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<Integer, Character> row = table.row("dog");
    assertTrue(row.isEmpty());
    try {
      row.put(1, 'd');
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: row - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testToStringSize1
 Body: {
    table = ArrayTable.create(ImmutableList.of("foo"), ImmutableList.of(1));
    table.put("foo", 1, 'a');
    assertEquals("{foo={1=a}}", table.toString());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testAt
 Body: {
    ArrayTable<String, Integer, Character> table =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    assertEquals((Character) 'b', table.at(1, 0));
    assertEquals((Character) 'c', table.at(0, 2));
    assertNull(table.at(1, 2));
    try {
      table.at(1, 3);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.at(1, -1);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.at(3, 2);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
    try {
      table.at(-1, 2);
      fail();
    } catch (IndexOutOfBoundsException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: at - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testSerialization
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    SerializableTester.reserializeAndAssert(table);
  }
 Pattern Name: FocalMethod_Match - Action: reserializeAndAssert - Predicate: N/A - Scenario: table

Project: guava
 Class: ArrayTableTest
 Method: testCreateCopyEmptyArrayTable
 Body: {
    Table<String, Integer, Character> original =
        ArrayTable.create(Arrays.<String>asList(), Arrays.<Integer>asList());
    ArrayTable<String, Integer, Character> copy = ArrayTable.create(original);
    assertThat(copy).isEqualTo(original);
    assertThat(copy).isEmpty();
  }
 Pattern Name: FocalMethod_Match - Action: isEqualTo - Predicate: N/A - Scenario: copy

Project: guava
 Class: ArrayTableTest
 Method: testCellReflectsChanges
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Cell<String, Integer, Character> cell = table.cellSet().iterator().next();
    assertEquals(Tables.immutableCell("foo", 1, 'a'), cell);
    assertEquals((Character) 'a', table.put("foo", 1, 'd'));
    assertEquals(Tables.immutableCell("foo", 1, 'd'), cell);
  }
 Pattern Name: FocalMethod_Match - Action: cellSet - Predicate: N/A - Scenario: cell

Project: guava
 Class: ArrayTableTest
 Method: testRowPutIllegal
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<Integer, Character> map = table.row("foo");
    try {
      map.put(4, 'd');
      fail();
    } catch (IllegalArgumentException expected) {
      assertThat(expected).hasMessage("Column 4 not in [1, 2, 3]");
    }
  }
 Pattern Name: FocalMethod_Match - Action: row - Predicate: N/A - Scenario: table

Project: guava
 Class: AppendableWriterTest
 Method: testCloseIsFinal
 Body: {
    StringBuilder builder = new StringBuilder();
    Writer writer = new AppendableWriter(builder);

    writer.write("Hi");
    writer.close();

    try {
      writer.write(" Greg");
      fail("Should have thrown IOException due to writer already closed");
    } catch (IOException expected) {
    }

    try {
      writer.flush();
      fail("Should have thrown IOException due to writer already closed");
    } catch (IOException expected) {
    }

    // close()ing already closed writer is allowed
    writer.close();
  }
 Pattern Name: FocalMethod_Match - Action: write - Predicate: N/A - Scenario: writer

Project: guava
 Class: ConfigurableSimpleDirectedNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: addEdge_selfLoop
 Body: {
    try {
      addEdge(N1, N1, E11);
      fail(ERROR_ADDED_SELF_LOOP);
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: addEdge_existingEdgeBetweenDifferentNodes_selfLoops
 Body: {
    addEdge(N1, N1, E11);
    try {
      addEdge(N1, N2, E11);
      fail("Reusing an existing self-loop edge to connect different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    try {
      addEdge(N2, N2, E11);
      fail("Reusing an existing self-loop edge to make a different self-loop edge succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
    addEdge(N1, N2, E12);
    try {
      addEdge(N1, N1, E12);
      fail("Reusing an existing edge to add a self-loop edge between different nodes succeeded");
    } catch (IllegalArgumentException e) {
      assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMessage - Predicate: N/A - Scenario: e

Project: guava
 Class: HashCodeTest
 Method: testFromBytesNoCopy_noCopyOccurs
 Body: {
    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
    HashCode hashCode = HashCode.fromBytesNoCopy(bytes);

    assertEquals(0x0000abcd, hashCode.asInt());
    assertEquals("cdab0000", hashCode.toString());

    bytes[0] = (byte) 0x00;

    assertEquals(0x0000ab00, hashCode.asInt());
    assertEquals("00ab0000", hashCode.toString());
  }
 Pattern Name: FocalMethod_Match - Action: fromBytesNoCopy - Predicate: N/A - Scenario: bytes

Project: guava
 Class: HashCodeTest
 Method: testGetBytesInternal_noCloneOccurs
 Body: {
    byte[] bytes = new byte[] {(byte) 0xcd, (byte) 0xab, (byte) 0x00, (byte) 0x00};
    HashCode hashCode = HashCode.fromBytes(bytes);

    assertEquals(0x0000abcd, hashCode.asInt());
    assertEquals("cdab0000", hashCode.toString());

    hashCode.getBytesInternal()[0] = (byte) 0x00;

    assertEquals(0x0000ab00, hashCode.asInt());
    assertEquals("00ab0000", hashCode.toString());
  }
 Pattern Name: FocalMethod_Match - Action: fromBytes - Predicate: N/A - Scenario: bytes

Project: guava
 Class: HashCodeTest
 Method: testRoundTrip
 Body: {
    for (ExpectedHashCode expected : expectedHashCodes) {
      String string = HashCode.fromBytes(expected.bytes).toString();
      assertEquals(expected.toString, string);
      assertEquals(
          expected.toString,
          HashCode.fromBytes(BaseEncoding.base16().lowerCase().decode(string)).toString());
    }
  }
 Pattern Name: FocalMethod_Match - Action: decode - Predicate: N/A - Scenario: string

Project: guava
 Class: MathPreconditionsTest
 Method: testCheckNoOverflow_failure
 Body: {
    try {
      MathPreconditions.checkNoOverflow(false, "testCheckNoOverflow_failure", 0, 0);
      fail();
    } catch (ArithmeticException expected) {
      assertThat(expected).hasMessageThat().contains("testCheckNoOverflow_failure(0, 0)");
    }
  }
 Pattern Name: FocalMethod_Match - Action: hasMessageThat - Predicate: N/A - Scenario: expected

Project: guava
 Class: CallablesTest
 Method: testReturning
 Body: {
    assertNull(Callables.returning(null).call());

    Object value = new Object();
    Callable<Object> callable = Callables.returning(value);
    assertSame(value, callable.call());
    // Expect the same value on subsequent calls
    assertSame(value, callable.call());
  }
 Pattern Name: FocalMethod_Match - Action: call - Predicate: N/A - Scenario: callable

Project: guava
 Class: CallablesTest
 Method: testAsAsyncCallable
 Body: {
    final String expected = "MyCallableString";
    Callable<String> callable =
        new Callable<String>() {
          @Override
          public String call() throws Exception {
            return expected;
          }
        };

    AsyncCallable<String> asyncCallable =
        Callables.asAsyncCallable(callable, MoreExecutors.newDirectExecutorService());

    ListenableFuture<String> future = asyncCallable.call();
    assertSame(expected, future.get());
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: future

Project: guava
 Class: TypeTokenResolutionTest
 Method: testTypeArgNotFound
 Body: {
    StringFoo<Integer> foo = new StringFoo<>();
    assertEquals(String.class, foo.getClassA());
    assertEquals(String[].class, foo.getArrayClassA());
    assertEquals(Object.class, foo.getClassB());
    assertEquals(Object[].class, foo.getArrayClassB());
  }
 Pattern Name: FocalMethod_Match - Action: getClassA - Predicate: N/A - Scenario: foo

Project: guava
 Class: TypeTokenResolutionTest
 Method: testSimpleTypeToken
 Body: {
    Foo<String, Integer> foo = new Foo<String, Integer>() {};
    assertEquals(String.class, foo.getClassA());
    assertEquals(Integer.class, foo.getClassB());
    assertEquals(String[].class, foo.getArrayClassA());
    assertEquals(Integer[].class, foo.getArrayClassB());
  }
 Pattern Name: FocalMethod_Match - Action: getClassA - Predicate: N/A - Scenario: foo

Project: guava
 Class: TypeTokenResolutionTest
 Method: testWithMutualRecursiveBoundInTypeVariable
 Body: {
    ParameterizedType paramType =
        (ParameterizedType)
            new WithGenericBound<String>() {}.getTargetType("withMutualRecursiveBound");
    TypeVariable<?> k = (TypeVariable<?>) paramType.getActualTypeArguments()[0];
    TypeVariable<?> v = (TypeVariable<?>) paramType.getActualTypeArguments()[1];
    assertEquals(Types.newParameterizedType(List.class, v), k.getBounds()[0]);
    assertEquals(Types.newParameterizedType(List.class, k), v.getBounds()[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getTargetType - Predicate: N/A - Scenario: v

Project: guava
 Class: TypeTokenResolutionTest
 Method: testPartialSpecialization
 Body: {
    StringFoo<Integer> foo = new StringFoo<Integer>() {};
    assertEquals(String.class, foo.getClassA());
    assertEquals(Integer.class, foo.getClassB());
    assertEquals(String[].class, foo.getArrayClassA());
    assertEquals(Integer[].class, foo.getArrayClassB());
    assertEquals(new TypeToken<String[]>() {}.getType(), foo.getArrayTypeA());
  }
 Pattern Name: FocalMethod_Match - Action: getClassA - Predicate: N/A - Scenario: foo

Project: guava
 Class: TypeTokenResolutionTest
 Method: testResolveType_parameterizedType
 Body: {
    @SuppressWarnings("rawtypes") // trying to test raw type
    Parameterized<?, ?, ?> parameterized =
        new Parameterized<TypeTokenResolutionTest, Bar, String>() {};
    TypeResolver typeResolver = TypeResolver.covariantly(parameterized.getClass());
    ParameterizedType resolved =
        (ParameterizedType) typeResolver.resolveType(parameterized.parameterizedType());
    assertEquals(TypeTokenResolutionTest.class, resolved.getOwnerType());
    assertEquals(Bar.class, resolved.getRawType());
    assertThat(resolved.getActualTypeArguments()).asList().contains(String.class);
  }
 Pattern Name: FocalMethod_Match - Action: getOwnerType - Predicate: N/A - Scenario: resolved

Project: guava
 Class: TypeTokenResolutionTest
 Method: testCompositeTypeToken
 Body: {
    Foo<String[], List<int[]>> foo = new Foo<String[], List<int[]>>() {};
    assertEquals(String[].class, foo.getClassA());
    assertEquals(List.class, foo.getClassB());
    assertEquals(String[][].class, foo.getArrayClassA());
    assertEquals(List[].class, foo.getArrayClassB());
  }
 Pattern Name: FocalMethod_Match - Action: getClassA - Predicate: N/A - Scenario: foo

Project: guava
 Class: TypeTokenResolutionTest
 Method: testResolveToGenericArrayType
 Body: {
    GenericArrayType arrayType =
        (GenericArrayType) new Holder<List<int[][]>[]>() {}.getContentType();
    ParameterizedType listType = (ParameterizedType) arrayType.getGenericComponentType();
    assertEquals(List.class, listType.getRawType());
    assertEquals(Types.newArrayType(int[].class), listType.getActualTypeArguments()[0]);
  }
 Pattern Name: FocalMethod_Match - Action: getRawType - Predicate: N/A - Scenario: listType

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformPutEntryIsUnsupported
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    try {
      map.put("b", "2");
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.putAll(ImmutableMap.of("b", "2"));
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    try {
      map.entrySet().iterator().next().setValue("one");
      fail();
    } catch (UnsupportedOperationException expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: map

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformSingletonMapEquality
 Body: {
    Map<String, String> map =
        Maps.transformValues(ImmutableMap.of("a", 1), Functions.toStringFunction());
    Map<String, String> expected = ImmutableMap.of("a", "1");
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: map

Project: guava
 Class: MapCreationTester
 Method: testCreateWithNullKeyAndValueSupported
 Body: {
    Entry<K, V>[] entries = createSamplesArray();
    entries[getNullLocation()] = entry(null, null);
    resetMap(entries);
    expectContents(entries);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: entries

Project: guava
 Class: ByteSinkTest
 Method: testClosesOnErrors_copyingFromByteSourceThatThrows
 Body: {
    for (TestOption option : EnumSet.of(OPEN_THROWS, READ_THROWS, CLOSE_THROWS)) {
      TestByteSource failSource = new TestByteSource(new byte[10], option);
      TestByteSink okSink = new TestByteSink();
      try {
        failSource.copyTo(okSink);
        fail();
      } catch (IOException expected) {
      }
      // ensure stream was closed IF it was opened (depends on implementation whether or not it's
      // opened at all if source.newInputStream() throws).
      assertTrue(
          "stream not closed when copying from source with option: " + option,
          !okSink.wasStreamOpened() || okSink.wasStreamClosed());
    }
  }
 Pattern Name: FocalMethod_Match - Action: copyTo - Predicate: N/A - Scenario: okSink

Project: guava
 Class: InetAddressesTest
 Method: testForStringBogusInput
 Body: {
    String[] bogusInputs = {
      "",
      "016.016.016.016",
      "016.016.016",
      "016.016",
      "016",
      "000.000.000.000",
      "000",
      "0x0a.0x0a.0x0a.0x0a",
      "0x0a.0x0a.0x0a",
      "0x0a.0x0a",
      "0x0a",
      "42.42.42.42.42",
      "42.42.42",
      "42.42",
      "42",
      "42..42.42",
      "42..42.42.42",
      "42.42.42.42.",
      "42.42.42.42...",
      ".42.42.42.42",
      "...42.42.42.42",
      "42.42.42.-0",
      "42.42.42.+0",
      ".",
      "...",
      "bogus",
      "bogus.com",
      "192.168.0.1.com",
      "12345.67899.-54321.-98765",
      "257.0.0.0",
      "42.42.42.-42",
      "3ffe::1.net",
      "3ffe::1::1",
      "1::2::3::4:5",
      "::7:6:5:4:3:2:", // should end with ":0"
      ":6:5:4:3:2:1::", // should begin with "0:"
      "2001::db:::1",
      "FEDC:9878",
      "+1.+2.+3.4",
      "1.2.3.4e0",
      "::7:6:5:4:3:2:1:0", // too many parts
      "7:6:5:4:3:2:1:0::", // too many parts
      "9:8:7:6:5:4:3::2:1", // too many parts
      "0:1:2:3::4:5:6:7", // :: must remove at least one 0.
      "3ffe:0:0:0:0:0:0:0:1", // too many parts (9 instead of 8)
      "3ffe::10000", // hextet exceeds 16 bits
      "3ffe::goog",
      "3ffe::-0",
      "3ffe::+0",
      "3ffe::-1",
      ":",
      ":::",
      "::1.2.3",
      "::1.2.3.4.5",
      "::1.2.3.4:",
      "1.2.3.4::",
      "2001:db8::1:",
      ":2001:db8::1",
      ":1:2:3:4:5:6:7",
      "1:2:3:4:5:6:7:",
      ":1:2:3:4:5:6:"
    };

    for (int i = 0; i < bogusInputs.length; i++) {
      try {
        InetAddresses.forString(bogusInputs[i]);
        fail("IllegalArgumentException expected for '" + bogusInputs[i] + "'");
      } catch (IllegalArgumentException expected) {
      }
      assertFalse(InetAddresses.isInetAddress(bogusInputs[i]));
    }
  }
 Pattern Name: FocalMethod_Match - Action: forString - Predicate: N/A - Scenario: bogusInputs

Project: guava
 Class: InetAddressesTest
 Method: testForStringIPv4Input
 Body: {
    String ipStr = "192.168.0.1";
    InetAddress ipv4Addr = null;
    // Shouldn't hit DNS, because it's an IP string literal.
    ipv4Addr = InetAddress.getByName(ipStr);
    assertEquals(ipv4Addr, InetAddresses.forString(ipStr));
    assertTrue(InetAddresses.isInetAddress(ipStr));
  }
 Pattern Name: FocalMethod_Match - Action: getByName - Predicate: N/A - Scenario: ipStr

Project: guava
 Class: InetAddressesTest
 Method: testIsatapAddresses
 Body: {
    InetAddress ipv4 = InetAddresses.forString("1.2.3.4");
    String[] validIsatapAddresses = {
      "2001:db8::5efe:102:304",
      "2001:db8::100:5efe:102:304", // Private Multicast? Not likely.
      "2001:db8::200:5efe:102:304",
      "2001:db8::300:5efe:102:304" // Public Multicast? Also unlikely.
    };
    String[] nonIsatapAddresses = {
      "::1.2.3.4",
      "3ffe::1",
      "::",
      "::1",
      "2001:db8::0040:5efe:102:304",
      "2001:db8::5ffe:102:304",
      "2001:db8::5eff:102:304",
      "2001:0:102:203:200:5efe:506:708", // Teredo address; not ISATAP
    };

    for (int i = 0; i < validIsatapAddresses.length; i++) {
      InetAddress ip = InetAddresses.forString(validIsatapAddresses[i]);
      assertTrue(InetAddresses.isIsatapAddress((Inet6Address) ip));
      assertEquals(
          "checking '" + validIsatapAddresses[i] + "'",
          ipv4,
          InetAddresses.getIsatapIPv4Address((Inet6Address) ip));
    }
    for (int i = 0; i < nonIsatapAddresses.length; i++) {
      InetAddress ip = InetAddresses.forString(nonIsatapAddresses[i]);
      assertFalse(InetAddresses.isIsatapAddress((Inet6Address) ip));
      try {
        InetAddresses.getIsatapIPv4Address((Inet6Address) ip);
        fail("IllegalArgumentException expected for '" + nonIsatapAddresses[i] + "'");
      } catch (IllegalArgumentException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: ipv4

Project: guava
 Class: InetAddressesTest
 Method: testTeredoAddress_nullServer
 Body: {
    InetAddresses.TeredoInfo info = new InetAddresses.TeredoInfo(null, null, 80, 1000);
    assertEquals(InetAddresses.forString("0.0.0.0"), info.getServer());
    assertEquals(InetAddresses.forString("0.0.0.0"), info.getClient());
    assertEquals(80, info.getPort());
    assertEquals(1000, info.getFlags());
  }
 Pattern Name: FocalMethod_Match - Action: getServer - Predicate: N/A - Scenario: info

Project: guava
 Class: InetAddressesTest
 Method: testIsMaximum
 Body: {
    InetAddress address = InetAddress.getByName("255.255.255.254");
    assertFalse(InetAddresses.isMaximum(address));

    address = InetAddress.getByName("255.255.255.255");
    assertTrue(InetAddresses.isMaximum(address));

    address = InetAddress.getByName("ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe");
    assertFalse(InetAddresses.isMaximum(address));

    address = InetAddress.getByName("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");
    assertTrue(InetAddresses.isMaximum(address));
  }
 Pattern Name: FocalMethod_Match - Action: isMaximum - Predicate: N/A - Scenario: address

Project: guava
 Class: InetAddressesTest
 Method: testGetEmbeddedIPv4ClientAddress
 Body: {
    Inet6Address testIp;

    // Test regular global unicast address.
    testIp = (Inet6Address) InetAddresses.forString("2001:db8::1");
    assertFalse(InetAddresses.hasEmbeddedIPv4ClientAddress(testIp));

    // Test ISATAP address.
    testIp = (Inet6Address) InetAddresses.forString("2001:db8::5efe:102:304");
    assertFalse(InetAddresses.hasEmbeddedIPv4ClientAddress(testIp));

    // Test compat address.
    testIp = (Inet6Address) InetAddresses.forString("::1.2.3.4");
    assertTrue(InetAddresses.hasEmbeddedIPv4ClientAddress(testIp));
    InetAddress ipv4 = InetAddresses.forString("1.2.3.4");
    assertEquals(ipv4, InetAddresses.getEmbeddedIPv4ClientAddress(testIp));

    // Test 6to4 address.
    testIp = (Inet6Address) InetAddresses.forString("2002:0102:0304::1");
    assertTrue(InetAddresses.hasEmbeddedIPv4ClientAddress(testIp));
    ipv4 = InetAddresses.forString("1.2.3.4");
    assertEquals(ipv4, InetAddresses.getEmbeddedIPv4ClientAddress(testIp));

    // Test Teredo address.
    testIp = (Inet6Address) InetAddresses.forString("2001:0000:4136:e378:8000:63bf:3fff:fdd2");
    assertTrue(InetAddresses.hasEmbeddedIPv4ClientAddress(testIp));
    ipv4 = InetAddresses.forString("192.0.2.45");
    assertEquals(ipv4, InetAddresses.getEmbeddedIPv4ClientAddress(testIp));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: ipv4

Project: guava
 Class: InetAddressesTest
 Method: testForStringIPv6Input
 Body: {
    String ipStr = "3ffe::1";
    InetAddress ipv6Addr = null;
    // Shouldn't hit DNS, because it's an IP string literal.
    ipv6Addr = InetAddress.getByName(ipStr);
    assertEquals(ipv6Addr, InetAddresses.forString(ipStr));
    assertTrue(InetAddresses.isInetAddress(ipStr));
  }
 Pattern Name: FocalMethod_Match - Action: getByName - Predicate: N/A - Scenario: ipStr

Project: guava
 Class: ImmutableSortedSetTest
 Method: testOf_tailSet
 Body: {
    SortedSet<String> set = of("e", "f", "b", "d", "c");
    assertTrue(set.tailSet("e") instanceof ImmutableSortedSet);
    assertThat(set.tailSet("e")).containsExactly("e", "f").inOrder();
    assertThat(set.tailSet("a")).containsExactly("b", "c", "d", "e", "f").inOrder();
    assertSame(of(), set.tailSet("g"));
  }
 Pattern Name: FocalMethod_Match - Action: tailSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testCopyOf_subSet
 Body: {
    SortedSet<String> set = of("e", "a", "f", "b", "d", "c");
    SortedSet<String> subset = set.subSet("c", "e");
    SortedSet<String> copy = copyOf(subset);
    assertEquals(subset, copy);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testOf_serialization
 Body: {
    SortedSet<String> set = of("e", "f", "b", "d", "c");
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertTrue(Iterables.elementsEqual(set, copy));
    assertEquals(set.comparator(), copy.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: elementsEqual - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testSingle_tailSet
 Body: {
    SortedSet<String> set = of("e");
    assertTrue(set.tailSet("c") instanceof ImmutableSortedSet);
    assertThat(set.tailSet("c")).contains("e");
    assertThat(set.tailSet("e")).contains("e");
    assertSame(of(), set.tailSet("g"));
  }
 Pattern Name: FocalMethod_Match - Action: tailSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testContainsAll_sameComparator
 Body: {
    SortedSet<String> set = of("a", "b", "f");
    assertTrue(set.containsAll(Sets.newTreeSet()));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("b"))));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("a", "f"))));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("a", "b", "f"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("d"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("z"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("b", "d"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("f", "d", "a"))));
  }
 Pattern Name: FocalMethod_Match - Action: containsAll - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testContainsAll_notSortedSet
 Body: {
    SortedSet<String> set = of("a", "b", "f");
    assertTrue(set.containsAll(Collections.emptyList()));
    assertTrue(set.containsAll(asList("b")));
    assertTrue(set.containsAll(asList("b", "b")));
    assertTrue(set.containsAll(asList("b", "f")));
    assertTrue(set.containsAll(asList("b", "f", "a")));
    assertFalse(set.containsAll(asList("d")));
    assertFalse(set.containsAll(asList("z")));
    assertFalse(set.containsAll(asList("b", "d")));
    assertFalse(set.containsAll(asList("f", "d", "a")));
  }
 Pattern Name: FocalMethod_Match - Action: containsAll - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testAsListReturnTypeAndSerialization
 Body: {
    ImmutableSet<String> set = ImmutableSortedSet.of("a", "e", "i", "o", "u");
    ImmutableList<String> list = set.asList();
    assertTrue(list instanceof ImmutableSortedAsList);
    ImmutableList<String> copy = SerializableTester.reserializeAndAssert(list);
    assertTrue(copy instanceof ImmutableSortedAsList);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testBuilderGenerics_SelfComparable
 Body: {
    // testing simple creation
    ImmutableSortedSet.Builder<SelfComparableExample> natural = ImmutableSortedSet.naturalOrder();
    assertThat(natural).isNotNull();
    ImmutableSortedSet.Builder<SelfComparableExample> reverse = ImmutableSortedSet.reverseOrder();
    assertThat(reverse).isNotNull();
  }
 Pattern Name: FocalMethod_Match - Action: reverseOrder - Predicate: N/A - Scenario: reverse

Project: guava
 Class: ImmutableSortedSetTest
 Method: testExplicit_serialization
 Body: {
    SortedSet<String> set =
        ImmutableSortedSet.orderedBy(STRING_LENGTH)
            .add("in", "the", "quick", "jumped", "over", "a")
            .build();
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertTrue(Iterables.elementsEqual(set, copy));
    assertSame(set.comparator(), copy.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: elementsEqual - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testAsList
 Body: {
    ImmutableSet<String> set = ImmutableSortedSet.of("a", "e", "i", "o", "u");
    ImmutableList<String> list = set.asList();
    assertEquals(ImmutableList.of("a", "e", "i", "o", "u"), list);
    assertSame(list, ImmutableList.copyOf(set));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: list

Project: guava
 Class: ImmutableSortedSetTest
 Method: testBuilderGenerics_SuperComparable
 Body: {
    // testing simple creation
    ImmutableSortedSet.Builder<SuperComparableExample> natural = ImmutableSortedSet.naturalOrder();
    assertThat(natural).isNotNull();
    ImmutableSortedSet.Builder<SuperComparableExample> reverse = ImmutableSortedSet.reverseOrder();
    assertThat(reverse).isNotNull();
  }
 Pattern Name: FocalMethod_Match - Action: reverseOrder - Predicate: N/A - Scenario: reverse

Project: guava
 Class: ImmutableSortedSetTest
 Method: testSubsetAsListReturnTypeAndSerialization
 Body: {
    ImmutableSet<String> set = ImmutableSortedSet.of("a", "e", "i", "o", "u").subSet("c", "r");
    ImmutableList<String> list = set.asList();
    assertTrue(list instanceof ImmutableSortedAsList);
    ImmutableList<String> copy = SerializableTester.reserializeAndAssert(list);
    assertTrue(copy instanceof ImmutableSortedAsList);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testSingle_headSet
 Body: {
    SortedSet<String> set = of("e");
    assertTrue(set.headSet("g") instanceof ImmutableSortedSet);
    assertThat(set.headSet("g")).contains("e");
    assertSame(of(), set.headSet("c"));
    assertSame(of(), set.headSet("e"));
  }
 Pattern Name: FocalMethod_Match - Action: headSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testAsListInconsistentComprator
 Body: {
    ImmutableSet<String> set =
        ImmutableSortedSet.orderedBy(STRING_LENGTH)
            .add("in", "the", "quick", "jumped", "over", "a")
            .build();
    ImmutableList<String> list = set.asList();
    assertTrue(list.contains("the"));
    assertEquals(2, list.indexOf("the"));
    assertEquals(2, list.lastIndexOf("the"));
    assertFalse(list.contains("dog"));
    assertEquals(-1, list.indexOf("dog"));
    assertEquals(-1, list.lastIndexOf("dog"));
    assertFalse(list.contains("chicken"));
    assertEquals(-1, list.indexOf("chicken"));
    assertEquals(-1, list.lastIndexOf("chicken"));
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: list

Project: guava
 Class: ImmutableSortedSetTest
 Method: testCopyOf_headSet
 Body: {
    SortedSet<String> set = of("e", "a", "f", "b", "d", "c");
    SortedSet<String> headset = set.headSet("d");
    SortedSet<String> copy = copyOf(headset);
    assertEquals(headset, copy);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testCopyOf_tailSet
 Body: {
    SortedSet<String> set = of("e", "a", "f", "b", "d", "c");
    SortedSet<String> tailset = set.tailSet("d");
    SortedSet<String> copy = copyOf(tailset);
    assertEquals(tailset, copy);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testEquals_bothDefaultOrdering
 Body: {
    SortedSet<String> set = of("a", "b", "c");
    assertEquals(set, Sets.newTreeSet(asList("a", "b", "c")));
    assertEquals(Sets.newTreeSet(asList("a", "b", "c")), set);
    assertFalse(set.equals(Sets.newTreeSet(asList("a", "b", "d"))));
    assertFalse(Sets.newTreeSet(asList("a", "b", "d")).equals(set));
    assertFalse(set.equals(Sets.newHashSet(4, 5, 6)));
    assertFalse(Sets.newHashSet(4, 5, 6).equals(set));
  }
 Pattern Name: FocalMethod_Match - Action: equals - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testSingle_subSet
 Body: {
    SortedSet<String> set = of("e");
    assertTrue(set.subSet("c", "g") instanceof ImmutableSortedSet);
    assertThat(set.subSet("c", "g")).contains("e");
    assertThat(set.subSet("e", "g")).contains("e");
    assertSame(of(), set.subSet("f", "g"));
    assertSame(of(), set.subSet("c", "e"));
    assertSame(of(), set.subSet("c", "d"));
  }
 Pattern Name: FocalMethod_Match - Action: subSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testSubsetAsList
 Body: {
    ImmutableSet<String> set = ImmutableSortedSet.of("a", "e", "i", "o", "u").subSet("c", "r");
    ImmutableList<String> list = set.asList();
    assertEquals(ImmutableList.of("e", "i", "o"), list);
    assertEquals(list, ImmutableList.copyOf(set));
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: list

Project: guava
 Class: ImmutableSortedSetTest
 Method: testExplicitEmpty_serialization
 Body: {
    SortedSet<String> set = ImmutableSortedSet.orderedBy(STRING_LENGTH).build();
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertTrue(set.isEmpty());
    assertTrue(copy.isEmpty());
    assertSame(set.comparator(), copy.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: isEmpty - Predicate: N/A - Scenario: copy

Project: guava
 Class: ImmutableSortedSetTest
 Method: testOf_subSetSerialization
 Body: {
    SortedSet<String> set = of("e", "f", "b", "d", "c");
    SerializableTester.reserializeAndAssert(set.subSet("c", "e"));
  }
 Pattern Name: FocalMethod_Match - Action: subSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ImmutableSortedSetTest
 Method: testDifferentComparator_serialization
 Body: {
    // don't use Collections.reverseOrder(); it didn't reserialize to the same instance in JDK5
    Comparator<Comparable<?>> comparator = Ordering.natural().reverse();
    SortedSet<String> set =
        new ImmutableSortedSet.Builder<String>(comparator).add("a", "b", "c").build();
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertTrue(Iterables.elementsEqual(set, copy));
    assertEquals(set.comparator(), copy.comparator());
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: comparator

Project: guava
 Class: ImmutableSortedSetTest
 Method: testContainsAll_differentComparator
 Body: {
    Comparator<Comparable<?>> comparator = Collections.reverseOrder();
    SortedSet<String> set =
        new ImmutableSortedSet.Builder<String>(comparator).add("a", "b", "f").build();
    assertTrue(set.containsAll(Sets.newTreeSet()));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("b"))));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("a", "f"))));
    assertTrue(set.containsAll(Sets.newTreeSet(asList("a", "b", "f"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("d"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("z"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("b", "d"))));
    assertFalse(set.containsAll(Sets.newTreeSet(asList("f", "d", "a"))));
  }
 Pattern Name: FocalMethod_Match - Action: add - Predicate: N/A - Scenario: comparator

Project: guava
 Class: ImmutableSortedSetTest
 Method: testOf_headSet
 Body: {
    SortedSet<String> set = of("e", "f", "b", "d", "c");
    assertTrue(set.headSet("e") instanceof ImmutableSortedSet);
    assertThat(set.headSet("e")).containsExactly("b", "c", "d").inOrder();
    assertThat(set.headSet("g")).containsExactly("b", "c", "d", "e", "f").inOrder();
    assertSame(of(), set.headSet("a"));
    assertSame(of(), set.headSet("b"));
  }
 Pattern Name: FocalMethod_Match - Action: headSet - Predicate: N/A - Scenario: set

Project: guava
 Class: ByteSourceTest
 Method: testContentEquals
 Body: {
    assertTrue(source.contentEquals(source));
    assertTrue(source.wasStreamOpened() && source.wasStreamClosed());

    ByteSource equalSource = new TestByteSource(bytes);
    assertTrue(source.contentEquals(equalSource));
    assertTrue(new TestByteSource(bytes).contentEquals(source));

    ByteSource fewerBytes = new TestByteSource(newPreFilledByteArray(bytes.length / 2));
    assertFalse(source.contentEquals(fewerBytes));

    byte[] copy = bytes.clone();
    copy[9876] = 1;
    ByteSource oneByteOff = new TestByteSource(copy);
    assertFalse(source.contentEquals(oneByteOff));
  }
 Pattern Name: FocalMethod_Match - Action: contentEquals - Predicate: N/A - Scenario: fewerBytes

Project: guava
 Class: ByteSourceTest
 Method: testConcat_infiniteIterable
 Body: {
    ByteSource source = ByteSource.wrap(new byte[] {0, 1, 2, 3});
    Iterable<ByteSource> cycle = Iterables.cycle(ImmutableList.of(source));
    ByteSource concatenated = ByteSource.concat(cycle);

    byte[] expected = {0, 1, 2, 3, 0, 1, 2, 3};
    assertArrayEquals(expected, concatenated.slice(0, 8).read());
  }
 Pattern Name: FocalMethod_Match - Action: of - Predicate: N/A - Scenario: source

Project: guava
 Class: IteratorTesterTest_gwt
 Method: testVerifyCanThrowAssertionThatFailsTest
 Body: {
  com.google.common.collect.testing.IteratorTesterTest testCase = new com.google.common.collect.testing.IteratorTesterTest();
  testCase.testVerifyCanThrowAssertionThatFailsTest();
}
 Pattern Name: FocalMethod_Match - Action: testVerifyCanThrowAssertionThatFailsTest - Predicate: N/A - Scenario: testCase

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testExplicitComparatorSerialization
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    TreeMultimap<String, Integer> copy = SerializableTester.reserializeAndAssert(multimap);
    assertThat(copy.values()).containsExactly(1, 3, 7, 2, 6, 0, 4).inOrder();
    assertThat(copy.keySet()).containsExactly("foo", "google", "tree").inOrder();
    assertEquals(multimap.keyComparator(), copy.keyComparator());
    assertEquals(multimap.valueComparator(), copy.valueComparator());
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: copy

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testOrderedGet
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    assertThat(multimap.get("foo")).containsExactly(1, 3, 7).inOrder();
    assertThat(multimap.get("google")).containsExactly(2, 6).inOrder();
    assertThat(multimap.get("tree")).containsExactly(0, 4).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: multimap

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testAsMapBridgeMethods
 Body: {
    for (Method m : TreeMultimap.class.getMethods()) {
      if (m.getName().equals("asMap") && m.getReturnType().equals(SortedMap.class)) {
        return;
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: getMethods - Predicate: N/A - Scenario: m

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testKeySetBridgeMethods
 Body: {
    for (Method m : TreeMultimap.class.getMethods()) {
      if (m.getName().equals("keySet") && m.getReturnType().equals(SortedSet.class)) {
        return;
      }
    }
    fail("No bridge method found");
  }
 Pattern Name: FocalMethod_Match - Action: getMethods - Predicate: N/A - Scenario: m

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testGetBridgeMethods
 Body: {
    for (Method m : TreeMultimap.class.getMethods()) {
      if (m.getName().equals("get") && m.getReturnType().equals(SortedSet.class)) {
        return;
      }
    }
    fail("No bridge method found");
  }
 Pattern Name: FocalMethod_Match - Action: getMethods - Predicate: N/A - Scenario: m

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testOrderedAsMapEntries
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    Iterator<Entry<String, Collection<Integer>>> iterator = multimap.asMap().entrySet().iterator();
    Entry<String, Collection<Integer>> entry = iterator.next();
    assertEquals("foo", entry.getKey());
    assertThat(entry.getValue()).containsExactly(1, 3, 7);
    entry = iterator.next();
    assertEquals("google", entry.getKey());
    assertThat(entry.getValue()).containsExactly(2, 6);
    entry = iterator.next();
    assertEquals("tree", entry.getKey());
    assertThat(entry.getValue()).containsExactly(0, 4);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: Crc32cHashFunctionTest
 Method: testDescending
 Body: {
    // Test 32 byte arrays of descending.
    byte[] descending = new byte[32];
    for (int i = 0; i < 32; i++) {
      descending[i] = (byte) (31 - i);
    }
    assertCrc(0x113fdb5c, descending);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: descending

Project: guava
 Class: Crc32cHashFunctionTest
 Method: testAscending
 Body: {
    // Test 32 byte arrays of ascending.
    byte[] ascending = new byte[32];
    for (int i = 0; i < 32; i++) {
      ascending[i] = (byte) i;
    }
    assertCrc(0x46dd794e, ascending);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: ascending

Project: guava
 Class: DoubleMathTest
 Method: testRoundLog2Ceiling
 Body: {
    for (double d : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      int log2 = DoubleMath.log2(d, CEILING);
      assertTrue(StrictMath.pow(2.0, log2) >= d);
      double z = StrictMath.pow(2.0, log2 - 1);
      assertTrue(z < d);
    }
  }
 Pattern Name: FocalMethod_Match - Action: log2 - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testLog2Accuracy
 Body: {
    for (double d : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      double dmLog2 = DoubleMath.log2(d);
      double trueLog2 = trueLog2(d);
      assertTrue(Math.abs(dmLog2 - trueLog2) <= Math.ulp(trueLog2));
    }
  }
 Pattern Name: FocalMethod_Match - Action: abs - Predicate: N/A - Scenario: trueLog2

Project: guava
 Class: DoubleMathTest
 Method: testIsPowerOfTwoYes
 Body: {
    for (int i = -1074; i <= 1023; i++) {
      assertTrue(DoubleMath.isPowerOfTwo(StrictMath.pow(2.0, i)));
    }
  }
 Pattern Name: FocalMethod_Match - Action: pow - Predicate: N/A - Scenario: i

Project: guava
 Class: DoubleMathTest
 Method: testLog2SemiMonotonic
 Body: {
    for (double d : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      assertTrue(DoubleMath.log2(d + 0.01) >= DoubleMath.log2(d));
    }
  }
 Pattern Name: FocalMethod_Match - Action: log2 - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testFuzzyCompareBadTolerance
 Body: {
    for (double tolerance : BAD_TOLERANCE_CANDIDATES) {
      try {
        DoubleMath.fuzzyCompare(1, 2, tolerance);
        fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException expected) {
        // success
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: fuzzyCompare - Predicate: N/A - Scenario: tolerance

Project: guava
 Class: DoubleMathTest
 Method: testRoundExactFractionalDoubleToIntFails
 Body: {
    for (double d : FRACTIONAL_DOUBLE_CANDIDATES) {
      try {
        DoubleMath.roundToInt(d, UNNECESSARY);
        fail("Expected ArithmeticException");
      } catch (ArithmeticException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: roundToInt - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testFuzzyEqualsInfiniteTolerance
 Body: {
    for (double a : DOUBLE_CANDIDATES_EXCEPT_NAN) {
      for (double b : DOUBLE_CANDIDATES_EXCEPT_NAN) {
        assertTrue(DoubleMath.fuzzyEquals(a, b, Double.POSITIVE_INFINITY));
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: fuzzyEquals - Predicate: N/A - Scenario: b

Project: guava
 Class: DoubleMathTest
 Method: testFuzzyEqualsBadTolerance
 Body: {
    for (double tolerance : BAD_TOLERANCE_CANDIDATES) {
      try {
        DoubleMath.fuzzyEquals(1, 2, tolerance);
        fail("Expected IllegalArgumentException");
      } catch (IllegalArgumentException expected) {
        // success
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: fuzzyEquals - Predicate: N/A - Scenario: tolerance

Project: guava
 Class: DoubleMathTest
 Method: testRoundExactFractionalDoubleToBigIntegerFails
 Body: {
    for (double d : FRACTIONAL_DOUBLE_CANDIDATES) {
      try {
        DoubleMath.roundToBigInteger(d, UNNECESSARY);
        fail("Expected ArithmeticException");
      } catch (ArithmeticException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: roundToBigInteger - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testRoundExactFractionalDoubleToLongFails
 Body: {
    for (double d : FRACTIONAL_DOUBLE_CANDIDATES) {
      try {
        DoubleMath.roundToLong(d, UNNECESSARY);
        fail("Expected ArithmeticException");
      } catch (ArithmeticException expected) {
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: roundToLong - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testRoundLog2Up
 Body: {
    for (double d : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      int log2 = DoubleMath.log2(d, UP);
      if (d >= 1.0) {
        assertTrue(log2 >= 0);
        assertTrue(StrictMath.pow(2.0, log2) >= d);
        assertTrue(StrictMath.pow(2.0, log2 - 1) < d);
      } else {
        assertTrue(log2 <= 0);
        assertTrue(StrictMath.pow(2.0, log2) <= d);
        assertTrue(StrictMath.pow(2.0, log2 + 1) > d);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: log2 - Predicate: N/A - Scenario: d

Project: guava
 Class: DoubleMathTest
 Method: testRoundLog2Floor
 Body: {
    for (double d : POSITIVE_FINITE_DOUBLE_CANDIDATES) {
      int log2 = DoubleMath.log2(d, FLOOR);
      assertTrue(StrictMath.pow(2.0, log2) <= d);
      assertTrue(StrictMath.pow(2.0, log2 + 1) > d);
    }
  }
 Pattern Name: FocalMethod_Match - Action: log2 - Predicate: N/A - Scenario: d

Project: guava
 Class: MoreFilesFileTraverserTest
 Method: testFileTraverser_multipleDirectoryLayers_traversalReturnsAll
 Body: {
    Path fileA = newFile("file-a");
    Path dir1 = newDir("dir-1");
    Path fileB = newFile("dir-1/file-b");
    Path dir2 = newFile("dir-1/dir-2");

    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir))
        .containsExactly(rootDir, fileA, fileB, dir1, dir2);
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: dir2

Project: guava
 Class: MoreFilesFileTraverserTest
 Method: testFileTraverser_multipleFilesAndDirectories
 Body: {
    Path fileA = newFile("file-a");
    Path fileB = newFile("file-b");
    Path dir1 = newDir("dir-1");
    Path dir2 = newDir("dir-2");

    assertThat(MoreFiles.fileTraverser().breadthFirst(rootDir))
        .containsExactly(rootDir, fileA, fileB, dir1, dir2);
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: dir2

Project: guava
 Class: ValueGraphTest
 Method: putEdgeValue_undirected
 Body: {
    graph = ValueGraphBuilder.undirected().build();

    assertThat(graph.putEdgeValue(1, 2, "valueA")).isNull();
    assertThat(graph.putEdgeValue(2, 1, "valueB")).isEqualTo("valueA");
    assertThat(graph.putEdgeValue(1, 2, "valueC")).isEqualTo("valueB");
    assertThat(graph.putEdgeValue(2, 1, "valueD")).isEqualTo("valueC");
  }
 Pattern Name: FocalMethod_Match - Action: putEdgeValue - Predicate: N/A - Scenario: graph

Project: guava
 Class: ValueGraphTest
 Method: removeEdge_undirected
 Body: {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, "valueA");
    graph.putEdgeValue(2, 1, "valueB");
    graph.putEdgeValue(2, 3, "valueC");

    assertThat(graph.removeEdge(1, 2)).isEqualTo("valueB");
    assertThat(graph.removeEdge(1, 2)).isNull();
    assertThat(graph.removeEdge(2, 1)).isNull();
    assertThat(graph.removeEdge(2, 3)).isEqualTo("valueC");
    assertThat(graph.removeEdge(2, 3)).isNull();
  }
 Pattern Name: FocalMethod_Match - Action: putEdgeValue - Predicate: N/A - Scenario: graph

Project: guava
 Class: ValueGraphTest
 Method: putEdgeValue_directed
 Body: {
    graph = ValueGraphBuilder.directed().build();

    assertThat(graph.putEdgeValue(1, 2, "valueA")).isNull();
    assertThat(graph.putEdgeValue(2, 1, "valueB")).isNull();
    assertThat(graph.putEdgeValue(1, 2, "valueC")).isEqualTo("valueA");
    assertThat(graph.putEdgeValue(2, 1, "valueD")).isEqualTo("valueB");
  }
 Pattern Name: FocalMethod_Match - Action: putEdgeValue - Predicate: N/A - Scenario: graph

Project: guava
 Class: ValueGraphTest
 Method: removeEdge_directed
 Body: {
    graph = ValueGraphBuilder.directed().build();
    graph.putEdgeValue(1, 2, "valueA");
    graph.putEdgeValue(2, 1, "valueB");
    graph.putEdgeValue(2, 3, "valueC");

    assertThat(graph.removeEdge(1, 2)).isEqualTo("valueA");
    assertThat(graph.removeEdge(1, 2)).isNull();
    assertThat(graph.removeEdge(2, 1)).isEqualTo("valueB");
    assertThat(graph.removeEdge(2, 1)).isNull();
    assertThat(graph.removeEdge(2, 3)).isEqualTo("valueC");
    assertThat(graph.removeEdge(2, 3)).isNull();
  }
 Pattern Name: FocalMethod_Match - Action: putEdgeValue - Predicate: N/A - Scenario: graph

Project: guava
 Class: Murmur3Hash128Test
 Method: testKnownValues
 Body: {
    assertHash(0, 0x629942693e10f867L, 0x92db0b82baeb5347L, "hell");
    assertHash(1, 0xa78ddff5adae8d10L, 0x128900ef20900135L, "hello");
    assertHash(2, 0x8a486b23f422e826L, 0xf962a2c58947765fL, "hello ");
    assertHash(3, 0x2ea59f466f6bed8cL, 0xc610990acc428a17L, "hello w");
    assertHash(4, 0x79f6305a386c572cL, 0x46305aed3483b94eL, "hello wo");
    assertHash(5, 0xc2219d213ec1f1b5L, 0xa1d8e2e0a52785bdL, "hello wor");
    assertHash(
        0, 0xe34bbc7bbc071b6cL, 0x7a433ca9c49a9347L, "The quick brown fox jumps over the lazy dog");
    assertHash(
        0, 0x658ca970ff85269aL, 0x43fee3eaa68e5c3eL, "The quick brown fox jumps over the lazy cog");

    // Known output from Python smhasher
    HashCode foxHash =
        murmur3_128(0).hashString("The quick brown fox jumps over the lazy dog", Charsets.UTF_8);
    assertEquals("6c1b07bc7bbc4be347939ac4a93c437a", foxHash.toString());
  }
 Pattern Name: FocalMethod_Match - Action: toString - Predicate: N/A - Scenario: foxHash

Project: guava
 Class: InvokableTest
 Method: testStaticMethod_typeParameters
 Body: {
    Invokable<?, ?> delegate = Prepender.method("prepend", String.class, Iterable.class);
    TypeVariable<?>[] variables = delegate.getTypeParameters();
    assertThat(variables).hasLength(1);
    assertEquals("T", variables[0].getName());
  }
 Pattern Name: FocalMethod_Match - Action: hasLength - Predicate: N/A - Scenario: variables

Project: guava
 Class: InvokableTest
 Method: testStaticFinalMethod_isFinal
 Body: {
    Invokable<?, ?> delegate = Prepender.method("staticFinalMethod");
    assertTrue(delegate.isStatic());
    assertTrue(delegate.isFinal());
    assertFalse(delegate.isOverridable());
    assertFalse(delegate.isVarArgs());
  }
 Pattern Name: FocalMethod_Match - Action: isStatic - Predicate: N/A - Scenario: delegate

Project: guava
 Class: InvokableTest
 Method: testPrivateInstanceMethod_isOverridable
 Body: {
    Invokable<?, ?> delegate = Prepender.method("privateMethod");
    assertTrue(delegate.isPrivate());
    assertFalse(delegate.isOverridable());
    assertFalse(delegate.isVarArgs());
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: delegate

Project: guava
 Class: InvokableTest
 Method: testInstanceMethod_returning
 Body: {
    Invokable<Prepender, Iterable<String>> delegate =
        Prepender.method("prepend", Iterable.class).returning(new TypeToken<Iterable<String>>() {});
    assertEquals(new TypeToken<Iterable<String>>() {}, delegate.getReturnType());
    Iterable<String> result = delegate.invoke(new Prepender("a", 2), ImmutableList.of("b", "c"));
    assertEquals(ImmutableList.of("a", "a", "b", "c"), ImmutableList.copyOf(result));
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: result

Project: guava
 Class: InvokableTest
 Method: testStaticMethod_returningRawType
 Body: {
    @SuppressWarnings("rawtypes") // the purpose is to test raw type
    Invokable<?, Iterable> delegate =
        Prepender.method("prepend", String.class, Iterable.class).returning(Iterable.class);
    assertEquals(new TypeToken<Iterable<String>>() {}, delegate.getReturnType());
    @SuppressWarnings("unchecked") // prepend() returns Iterable<String>
    Iterable<String> result = delegate.invoke(null, "a", ImmutableList.of("b", "c"));
    assertEquals(ImmutableList.of("a", "b", "c"), ImmutableList.copyOf(result));
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: result

Project: guava
 Class: InvokableTest
 Method: testLocalClassDefaultConstructor
 Body: {
    final int i = 1;
    final String s = "hello world";
    class LocalWithDefaultConstructor implements Runnable {
      @Override
      public void run() {
        System.out.println(s + i);
      }
    }
    Constructor<?> constructor = LocalWithDefaultConstructor.class.getDeclaredConstructors()[0];
    assertEquals(0, Invokable.from(constructor).getParameters().size());
  }
 Pattern Name: FocalMethod_Match - Action: getDeclaredConstructors - Predicate: N/A - Scenario: s

Project: guava
 Class: InvokableTest
 Method: testConstructor_returning
 Body: {
    Invokable<?, Prepender> delegate =
        Prepender.constructor(String.class, int.class).returning(Prepender.class);
    Prepender prepender = delegate.invoke(null, "a", 1);
    assertEquals("a", prepender.prefix);
    assertEquals(1, prepender.times);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: prepender

Project: guava
 Class: InvokableTest
 Method: testStaticMethod_returning
 Body: {
    Invokable<?, Iterable<String>> delegate =
        Prepender.method("prepend", String.class, Iterable.class)
            .returning(new TypeToken<Iterable<String>>() {});
    assertEquals(new TypeToken<Iterable<String>>() {}, delegate.getReturnType());
    Iterable<String> result = delegate.invoke(null, "a", ImmutableList.of("b", "c"));
    assertEquals(ImmutableList.of("a", "b", "c"), ImmutableList.copyOf(result));
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: result

Project: guava
 Class: InvokableTest
 Method: testConstructor_call
 Body: {
    Invokable<?, Prepender> delegate = Prepender.constructor(String.class, int.class);
    Prepender prepender = delegate.invoke(null, "a", 1);
    assertEquals("a", prepender.prefix);
    assertEquals(1, prepender.times);
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: prepender

Project: guava
 Class: InvokableTest
 Method: testConstructor_returnType_hasTypeParameter
 Body: {
    @SuppressWarnings("rawtypes") // Foo.class for Foo<T> is always raw type
    Class<WithConstructorAndTypeParameter> type = WithConstructorAndTypeParameter.class;
    @SuppressWarnings("rawtypes") // Foo.class
    Constructor<WithConstructorAndTypeParameter> constructor = type.getDeclaredConstructor();
    Invokable<?, ?> factory = Invokable.from(constructor);
    assertThat(factory.getTypeParameters()).hasLength(2);
    assertEquals(type.getTypeParameters()[0], factory.getTypeParameters()[0]);
    assertEquals(constructor.getTypeParameters()[0], factory.getTypeParameters()[1]);
    ParameterizedType returnType = (ParameterizedType) factory.getReturnType().getType();
    assertEquals(type, returnType.getRawType());
    assertEquals(
        ImmutableList.copyOf(type.getTypeParameters()),
        ImmutableList.copyOf(returnType.getActualTypeArguments()));
  }
 Pattern Name: FocalMethod_Match - Action: getDeclaredConstructor - Predicate: N/A - Scenario: type

Project: guava
 Class: InvokableTest
 Method: testPrivateFinalInstanceMethod_isOverridable
 Body: {
    Invokable<?, ?> delegate = Prepender.method("privateFinalMethod");
    assertTrue(delegate.isPrivate());
    assertTrue(delegate.isFinal());
    assertFalse(delegate.isOverridable());
    assertFalse(delegate.isVarArgs());
  }
 Pattern Name: FocalMethod_Match - Action: isPrivate - Predicate: N/A - Scenario: delegate

Project: guava
 Class: InvokableTest
 Method: testInstanceMethod_returningRawType
 Body: {
    @SuppressWarnings("rawtypes") // the purpose is to test raw type
    Invokable<Prepender, Iterable> delegate =
        Prepender.method("prepend", Iterable.class).returning(Iterable.class);
    assertEquals(new TypeToken<Iterable<String>>() {}, delegate.getReturnType());
    @SuppressWarnings("unchecked") // prepend() returns Iterable<String>
    Iterable<String> result = delegate.invoke(new Prepender("a", 2), ImmutableList.of("b", "c"));
    assertEquals(ImmutableList.of("a", "a", "b", "c"), ImmutableList.copyOf(result));
  }
 Pattern Name: FocalMethod_Match - Action: copyOf - Predicate: N/A - Scenario: result

Project: guava
 Class: InvokableTest
 Method: testStaticMethod_isOverridable
 Body: {
    Invokable<?, ?> delegate = Prepender.method("staticMethod");
    assertTrue(delegate.isStatic());
    assertFalse(delegate.isOverridable());
    assertFalse(delegate.isVarArgs());
  }
 Pattern Name: FocalMethod_Match - Action: isStatic - Predicate: N/A - Scenario: delegate

Project: guava
 Class: CharStreamsTest
 Method: testCopyWithReaderThatDoesNotFillBuffer
 Body: {
    // need a long enough string for the buffer to hit 0 remaining before the copy completes
    String string = Strings.repeat("0123456789", 100);
    StringBuilder b = new StringBuilder();
    // the main assertion of this test is here... the copy will fail if the buffer size goes down
    // each time it is not filled completely
    long copied = CharStreams.copy(newNonBufferFillingReader(new StringReader(string)), b);
    assertEquals(string, b.toString());
    assertEquals(string.length(), copied);
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: b

Project: guava
 Class: CharStreamsTest
 Method: testExhaust_reader
 Body: {
    Reader reader = new StringReader(ASCII);
    assertEquals(ASCII.length(), CharStreams.exhaust(reader));
    assertEquals(-1, reader.read());
    assertEquals(0, CharStreams.exhaust(reader));

    Reader empty = new StringReader("");
    assertEquals(0, CharStreams.exhaust(empty));
    assertEquals(-1, empty.read());
  }
 Pattern Name: FocalMethod_Match - Action: exhaust - Predicate: N/A - Scenario: reader

Project: guava
 Class: CharStreamsTest
 Method: testCopy_toWriter_fromReadable
 Body: {
    StringWriter writer = new StringWriter();
    long copied = CharStreams.copy(wrapAsGenericReadable(new StringReader(ASCII)), writer);
    assertEquals(ASCII, writer.toString());
    assertEquals(ASCII.length(), copied);

    StringWriter writer2 = new StringWriter();
    copied = CharStreams.copy(wrapAsGenericReadable(new StringReader(I18N)), writer2);
    assertEquals(I18N, writer2.toString());
    assertEquals(I18N.length(), copied);
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: writer

Project: guava
 Class: CharStreamsTest
 Method: testCopy_toWriter_fromReader
 Body: {
    StringWriter writer = new StringWriter();
    long copied = CharStreams.copy(new StringReader(ASCII), writer);
    assertEquals(ASCII, writer.toString());
    assertEquals(ASCII.length(), copied);

    StringWriter writer2 = new StringWriter();
    copied = CharStreams.copy(new StringReader(I18N), writer2);
    assertEquals(I18N, writer2.toString());
    assertEquals(I18N.length(), copied);
  }
 Pattern Name: FocalMethod_Match - Action: copy - Predicate: N/A - Scenario: writer

Project: guava
 Class: ThrowablesTest
 Method: testLazyStackTrace
 Body: {
    Exception e = new Exception();
    StackTraceElement[] originalStackTrace = e.getStackTrace();

    assertThat(lazyStackTrace(e)).containsExactly((Object[]) originalStackTrace).inOrder();

    try {
      lazyStackTrace(e).set(0, null);
      fail();
    } catch (UnsupportedOperationException expected) {
    }

    // Now we test a property that holds only for the lazy implementation.

    if (!lazyStackTraceIsLazy()) {
      return;
    }

    e.setStackTrace(new StackTraceElement[0]);
    assertThat(lazyStackTrace(e)).containsExactly((Object[]) originalStackTrace).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: getStackTrace - Predicate: N/A - Scenario: e

Project: guava
 Class: MultisetsTest
 Method: testRemoveOccurrencesIterableEmpty
 Body: {
    Multiset<String> multiset = HashMultiset.create();
    Iterable<String> toRemove = Arrays.asList("a", "b", "a");
    assertFalse(Multisets.removeOccurrences(multiset, toRemove));
    assertTrue(multiset.isEmpty());
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testRemoveEmptyOccurrencesMultiset
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Arrays.asList("a", "b", "a"));
    Multiset<String> toRemove = HashMultiset.create();
    assertFalse(Multisets.removeOccurrences(multiset, toRemove));
    assertThat(multiset).containsExactly("a", "a", "b").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testRemoveEmptyOccurrencesIterable
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Arrays.asList("a", "b", "a"));
    Iterable<String> toRemove = ImmutableList.of();
    assertFalse(Multisets.removeOccurrences(multiset, toRemove));
    assertThat(multiset).containsExactly("a", "a", "b").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testRemoveOccurrencesMultiset
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Arrays.asList("a", "b", "a", "c"));
    Multiset<String> toRemove = HashMultiset.create(Arrays.asList("a", "b", "b"));
    assertTrue(Multisets.removeOccurrences(multiset, toRemove));
    assertThat(multiset).containsExactly("a", "c").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testRemoveOccurrencesMultisetEmpty
 Body: {
    Multiset<String> multiset = HashMultiset.create();
    Multiset<String> toRemove = HashMultiset.create(Arrays.asList("a", "b", "a"));
    assertFalse(Multisets.removeOccurrences(multiset, toRemove));
    assertTrue(multiset.isEmpty());
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testRemoveOccurrencesMultisetIterable
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Arrays.asList("a", "b", "a", "c"));
    List<String> toRemove = Arrays.asList("a", "b", "b");
    assertTrue(Multisets.removeOccurrences(multiset, toRemove));
    assertThat(multiset).containsExactly("a", "c").inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: removeOccurrences - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testHighestCountFirst
 Body: {
    Multiset<String> multiset = HashMultiset.create(Arrays.asList("a", "a", "a", "b", "c", "c"));
    ImmutableMultiset<String> sortedMultiset = Multisets.copyHighestCountFirst(multiset);

    assertThat(sortedMultiset.entrySet())
        .containsExactly(
            Multisets.immutableEntry("a", 3),
            Multisets.immutableEntry("c", 2),
            Multisets.immutableEntry("b", 1))
        .inOrder();

    assertThat(sortedMultiset).containsExactly("a", "a", "a", "c", "c", "b").inOrder();

    assertThat(Multisets.copyHighestCountFirst(ImmutableMultiset.of())).isEmpty();
  }
 Pattern Name: FocalMethod_Match - Action: copyHighestCountFirst - Predicate: N/A - Scenario: multiset

Project: guava
 Class: MultisetsTest
 Method: testDifferenceWithMoreElementsInSecondMultiset
 Body: {
    Multiset<String> ms1 = HashMultiset.create(Arrays.asList("a", "b", "a"));
    Multiset<String> ms2 = HashMultiset.create(Arrays.asList("a", "b", "b", "b"));
    Multiset<String> diff = Multisets.difference(ms1, ms2);
    assertThat(diff).contains("a");
    assertEquals(0, diff.count("b"));
    assertEquals(1, diff.count("a"));
    assertFalse(diff.contains("b"));
    assertTrue(diff.contains("a"));
  }
 Pattern Name: FocalMethod_Match - Action: difference - Predicate: N/A - Scenario: diff

Project: guava
 Class: MapReplaceAllTester
 Method: testReplaceAllPreservesOrder
 Body: {
    getMap()
        .replaceAll(
            (K k, V v) -> {
              int index = keys().asList().indexOf(k);
              return values().asList().get(index + 1);
            });
    List<Entry<K, V>> orderedEntries = getOrderedElements();
    int index = 0;
    for (K key : getMap().keySet()) {
      assertEquals(orderedEntries.get(index).getKey(), key);
      index++;
    }
  }
 Pattern Name: FocalMethod_Match - Action: replaceAll - Predicate: N/A - Scenario: key

Project: guava
 Class: ListSubListTester
 Method: testSubList_lastIndexOf
 Body: {
    List<E> list = getList();
    int size = list.size();
    List<E> copy = list.subList(0, size);
    List<E> head = list.subList(0, size - 1);
    List<E> tail = list.subList(1, size);
    assertEquals(size - 1, copy.lastIndexOf(list.get(size - 1)));
    assertEquals(size - 2, head.lastIndexOf(list.get(size - 2)));
    assertEquals(size - 2, tail.lastIndexOf(list.get(size - 1)));
    // The following assumes all elements are distinct.
    assertEquals(0, copy.lastIndexOf(list.get(0)));
    assertEquals(0, head.lastIndexOf(list.get(0)));
    assertEquals(0, tail.lastIndexOf(list.get(1)));
    assertEquals(-1, head.lastIndexOf(list.get(size - 1)));
    assertEquals(-1, tail.lastIndexOf(list.get(0)));
  }
 Pattern Name: FocalMethod_Match - Action: lastIndexOf - Predicate: N/A - Scenario: copy

Project: guava
 Class: ListSubListTester
 Method: testSubList_contains
 Body: {
    List<E> list = getList();
    int size = getNumElements();
    List<E> copy = list.subList(0, size);
    List<E> head = list.subList(0, size - 1);
    List<E> tail = list.subList(1, size);
    assertTrue(copy.contains(list.get(0)));
    assertTrue(head.contains(list.get(0)));
    assertTrue(tail.contains(list.get(1)));
    // The following assumes all elements are distinct.
    assertTrue(copy.contains(list.get(size - 1)));
    assertTrue(head.contains(list.get(size - 2)));
    assertTrue(tail.contains(list.get(size - 1)));
    assertFalse(head.contains(list.get(size - 1)));
    assertFalse(tail.contains(list.get(0)));
  }
 Pattern Name: FocalMethod_Match - Action: contains - Predicate: N/A - Scenario: copy

Project: guava
 Class: ListSubListTester
 Method: testSubList_indexOf
 Body: {
    List<E> list = getList();
    int size = getNumElements();
    List<E> copy = list.subList(0, size);
    List<E> head = list.subList(0, size - 1);
    List<E> tail = list.subList(1, size);
    assertEquals(0, copy.indexOf(list.get(0)));
    assertEquals(0, head.indexOf(list.get(0)));
    assertEquals(0, tail.indexOf(list.get(1)));
    // The following assumes all elements are distinct.
    assertEquals(size - 1, copy.indexOf(list.get(size - 1)));
    assertEquals(size - 2, head.indexOf(list.get(size - 2)));
    assertEquals(size - 2, tail.indexOf(list.get(size - 1)));
    assertEquals(-1, head.indexOf(list.get(size - 1)));
    assertEquals(-1, tail.indexOf(list.get(0)));
  }
 Pattern Name: FocalMethod_Match - Action: indexOf - Predicate: N/A - Scenario: copy

Project: guava
 Class: ListSubListTester
 Method: testSubList_get
 Body: {
    List<E> list = getList();
    int size = getNumElements();
    List<E> copy = list.subList(0, size);
    List<E> head = list.subList(0, size - 1);
    List<E> tail = list.subList(1, size);
    assertEquals(list.get(0), copy.get(0));
    assertEquals(list.get(size - 1), copy.get(size - 1));
    assertEquals(list.get(1), tail.get(0));
    assertEquals(list.get(size - 1), tail.get(size - 2));
    assertEquals(list.get(0), head.get(0));
    assertEquals(list.get(size - 2), head.get(size - 2));
    for (List<E> subList : Arrays.asList(copy, head, tail)) {
      for (int index : Arrays.asList(-1, subList.size())) {
        try {
          subList.get(index);
          fail("expected IndexOutOfBoundsException");
        } catch (IndexOutOfBoundsException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: copy

Project: guava
 Class: ListSubListTester
 Method: testSubList_size
 Body: {
    List<E> list = getList();
    int size = getNumElements();
    assertEquals(size, list.subList(0, size).size());
    assertEquals(size - 1, list.subList(0, size - 1).size());
    assertEquals(size - 1, list.subList(1, size).size());
    assertEquals(0, list.subList(size, size).size());
    assertEquals(0, list.subList(0, 0).size());
  }
 Pattern Name: FocalMethod_Match - Action: subList - Predicate: N/A - Scenario: list

Project: guava
 Class: RegularImmutableTableTest
 Method: testValues
 Body: {
    for (ImmutableTable<Character, Integer, String> testInstance : getTestInstances()) {
      assertThat(testInstance.values()).containsExactly("foo", "bar", "baz").inOrder();
    }
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: testInstance

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_accessExpirationHours
 Body: {
    CacheBuilderSpec spec = parse("expireAfterAccess=150h");
    assertEquals(TimeUnit.HOURS, spec.accessExpirationTimeUnit);
    assertEquals(150L, spec.accessExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterAccess(150L, TimeUnit.HOURS), CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_writeExpirationHours
 Body: {
    CacheBuilderSpec spec = parse("expireAfterWrite=150h");
    assertEquals(TimeUnit.HOURS, spec.writeExpirationTimeUnit);
    assertEquals(150L, spec.writeExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterWrite(150L, TimeUnit.HOURS), CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_accessExpirationSeconds
 Body: {
    CacheBuilderSpec spec = parse("expireAfterAccess=10s");
    assertEquals(TimeUnit.SECONDS, spec.accessExpirationTimeUnit);
    assertEquals(10L, spec.accessExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterAccess(10L, TimeUnit.SECONDS),
        CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_writeExpirationMinutes
 Body: {
    CacheBuilderSpec spec = parse("expireAfterWrite=10m");
    assertEquals(TimeUnit.MINUTES, spec.writeExpirationTimeUnit);
    assertEquals(10L, spec.writeExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterWrite(10L, TimeUnit.MINUTES), CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_writeExpirationSeconds
 Body: {
    CacheBuilderSpec spec = parse("expireAfterWrite=10s");
    assertEquals(TimeUnit.SECONDS, spec.writeExpirationTimeUnit);
    assertEquals(10L, spec.writeExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterWrite(10L, TimeUnit.SECONDS), CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_accessExpirationMinutes
 Body: {
    CacheBuilderSpec spec = parse("expireAfterAccess=10m");
    assertEquals(TimeUnit.MINUTES, spec.accessExpirationTimeUnit);
    assertEquals(10L, spec.accessExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder().expireAfterAccess(10L, TimeUnit.MINUTES),
        CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: CacheBuilderSpecTest
 Method: testParse_accessExpirationAndWriteExpiration
 Body: {
    CacheBuilderSpec spec = parse("expireAfterAccess=10s,expireAfterWrite=9m");
    assertEquals(TimeUnit.MINUTES, spec.writeExpirationTimeUnit);
    assertEquals(9L, spec.writeExpirationDuration);
    assertEquals(TimeUnit.SECONDS, spec.accessExpirationTimeUnit);
    assertEquals(10L, spec.accessExpirationDuration);
    assertCacheBuilderEquivalence(
        CacheBuilder.newBuilder()
            .expireAfterAccess(10L, TimeUnit.SECONDS)
            .expireAfterWrite(9L, TimeUnit.MINUTES),
        CacheBuilder.from(spec));
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: spec

Project: guava
 Class: ParameterTest
 Method: testNulls
 Body: {
    for (Method method : ParameterTest.class.getDeclaredMethods()) {
      for (Parameter param : Invokable.from(method).getParameters()) {
        new NullPointerTester().testAllPublicInstanceMethods(param);
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: method

Project: guava
 Class: ParameterTest
 Method: testEquals
 Body: {
    EqualsTester tester = new EqualsTester();
    for (Method method : ParameterTest.class.getDeclaredMethods()) {
      for (Parameter param : Invokable.from(method).getParameters()) {
        tester.addEqualityGroup(param);
      }
    }
    tester.testEquals();
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: method

Project: guava
 Class: HelpersTest
 Method: testAssertContainsAllOf
 Body: {
    List<?> list = Arrays.asList("a", "a", "b", "c");
    Helpers.assertContainsAllOf(list, "a");
    Helpers.assertContainsAllOf(list, "a", "a");
    Helpers.assertContainsAllOf(list, "a", "b", "c");
    Helpers.assertContainsAllOf(list, "a", "b", "c", "a");

    try {
      Helpers.assertContainsAllOf(list, "d");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }

    try {
      Helpers.assertContainsAllOf(list, "a", "b", "c", "d");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }

    try {
      Helpers.assertContainsAllOf(list, "a", "a", "a");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: assertContainsAllOf - Predicate: N/A - Scenario: list

Project: guava
 Class: HelpersTest
 Method: testAssertContains
 Body: {
    List<?> list = Arrays.asList("a", "b");
    Helpers.assertContains(list, "a");
    Helpers.assertContains(list, "b");

    try {
      Helpers.assertContains(list, "c");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: assertContains - Predicate: N/A - Scenario: list

Project: guava
 Class: HelpersTest
 Method: testIsEmpty_iterable
 Body: {
    List<Object> list = new ArrayList<>();
    Helpers.assertEmpty(list);
    Helpers.assertEmpty(
        new Iterable<Object>() {
          @Override
          public Iterator<Object> iterator() {
            return Collections.emptyList().iterator();
          }
        });

    list.add("a");
    try {
      Helpers.assertEmpty(list);
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
    try {
      Helpers.assertEmpty(
          new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
              return Collections.singleton("a").iterator();
            }
          });
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: assertEmpty - Predicate: N/A - Scenario: list

Project: guava
 Class: HelpersTest
 Method: testAssertContentsInOrder
 Body: {
    List<?> list = Arrays.asList("a", "b", "c");
    Helpers.assertContentsInOrder(list, "a", "b", "c");

    try {
      Helpers.assertContentsInOrder(list, "a", "b");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }

    try {
      Helpers.assertContentsInOrder(list, "a", "b", "c", "d");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }

    try {
      Helpers.assertContentsInOrder(list, "a", "c", "b");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }

    try {
      Helpers.assertContentsInOrder(list, "a", "B", "c");
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: assertContentsInOrder - Predicate: N/A - Scenario: list

Project: guava
 Class: HelpersTest
 Method: testIsEmpty_map
 Body: {
    Map<Object, Object> map = new HashMap<>();
    Helpers.assertEmpty(map);

    map.put("a", "b");
    try {
      Helpers.assertEmpty(map);
      throw new Error();
    } catch (AssertionFailedError expected) {
    }
  }
 Pattern Name: FocalMethod_Match - Action: assertEmpty - Predicate: N/A - Scenario: map

Project: guava
 Class: ImmutableSortedMapTest
 Method: testMutableValues
 Body: {
    IntHolder holderA = new IntHolder(1);
    IntHolder holderB = new IntHolder(2);
    Map<String, IntHolder> map = ImmutableSortedMap.of("a", holderA, "b", holderB);
    holderA.value = 3;
    assertTrue(map.entrySet().contains(Maps.immutableEntry("a", new IntHolder(3))));
    Map<String, Integer> intMap = ImmutableSortedMap.of("a", 3, "b", 2);
    assertEquals(intMap.hashCode(), map.entrySet().hashCode());
    assertEquals(intMap.hashCode(), map.hashCode());
  }
 Pattern Name: FocalMethod_Match - Action: hashCode - Predicate: N/A - Scenario: intMap

Project: guava
 Class: ImmutableSortedMapTest
 Method: testNullValuesInCopyOfMap
 Body: {
    for (int i = 1; i <= 10; i++) {
      for (int j = 0; j < i; j++) {
        Map<Integer, Integer> source = new TreeMap<>();
        for (int k = 0; k < i; k++) {
          source.put(k, k);
        }
        source.put(j, null);
        try {
          ImmutableSortedMap.copyOf(source);
          fail("Expected NullPointerException in copyOf(" + source + ")");
        } catch (NullPointerException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: source

Project: guava
 Class: ImmutableSortedMapTest
 Method: testViewSerialization
 Body: {
    Map<String, Integer> map = ImmutableSortedMap.of("one", 1, "two", 2, "three", 3);
    SerializableTester.reserializeAndAssert(map.entrySet());
    SerializableTester.reserializeAndAssert(map.keySet());
    assertEquals(
        Lists.newArrayList(map.values()),
        Lists.newArrayList(SerializableTester.reserialize(map.values())));
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: map

Project: guava
 Class: ImmutableSortedMapTest
 Method: testNullValuesInCopyOfEntries
 Body: {
    for (int i = 1; i <= 10; i++) {
      for (int j = 0; j < i; j++) {
        Map<Integer, Integer> source = new TreeMap<>();
        for (int k = 0; k < i; k++) {
          source.put(k, k);
        }
        source.put(j, null);
        try {
          ImmutableSortedMap.copyOf(source.entrySet());
          fail("Expected NullPointerException in copyOf(" + source.entrySet() + ")");
        } catch (NullPointerException expected) {
        }
      }
    }
  }
 Pattern Name: FocalMethod_Match - Action: put - Predicate: N/A - Scenario: source

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testOrderedAsMapEntries
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    Iterator<Entry<String, Collection<Integer>>> iterator = multimap.asMap().entrySet().iterator();
    Entry<String, Collection<Integer>> entry = iterator.next();
    assertEquals(null, entry.getKey());
    assertThat(entry.getValue()).containsExactly(7, 3, 1);
    entry = iterator.next();
    assertEquals("tree", entry.getKey());
    assertThat(entry.getValue()).containsExactly(null, 0);
    entry = iterator.next();
    assertEquals("google", entry.getKey());
    assertThat(entry.getValue()).containsExactly(6, 2);
  }
 Pattern Name: FocalMethod_Match - Action: entrySet - Predicate: N/A - Scenario: entry

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testExplicitComparatorSerialization
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    TreeMultimap<String, Integer> copy = SerializableTester.reserializeAndAssert(multimap);
    assertThat(copy.values()).containsExactly(7, 3, 1, null, 0, 6, 2).inOrder();
    assertThat(copy.keySet()).containsExactly(null, "tree", "google").inOrder();
    assertEquals(multimap.keyComparator(), copy.keyComparator());
    assertEquals(multimap.valueComparator(), copy.valueComparator());
  }
 Pattern Name: FocalMethod_Match - Action: values - Predicate: N/A - Scenario: copy

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testOrderedGet
 Body: {
    TreeMultimap<String, Integer> multimap = createPopulate();
    assertThat(multimap.get(null)).containsExactly(7, 3, 1).inOrder();
    assertThat(multimap.get("google")).containsExactly(6, 2).inOrder();
    assertThat(multimap.get("tree")).containsExactly(null, 0).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: get - Predicate: N/A - Scenario: multimap

Project: guava
 Class: FluentIterableTest
 Method: testAppend
 Body: {
    FluentIterable<Integer> result =
        FluentIterable.<Integer>from(asList(1, 2, 3)).append(Lists.newArrayList(4, 5, 6));
    assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
    assertEquals("[1, 2, 3, 4, 5, 6]", result.toString());

    result = FluentIterable.<Integer>from(asList(1, 2, 3)).append(4, 5, 6);
    assertEquals(asList(1, 2, 3, 4, 5, 6), Lists.newArrayList(result));
    assertEquals("[1, 2, 3, 4, 5, 6]", result.toString());
  }
 Pattern Name: FocalMethod_Match - Action: newArrayList - Predicate: N/A - Scenario: result

Project: guava
 Class: FluentIterableTest
 Method: testConcatPeformingFiniteCycle
 Body: {
    Iterable<Integer> iterable = asList(1, 2, 3);
    int n = 4;
    FluentIterable<Integer> repeated = FluentIterable.concat(Collections.nCopies(n, iterable));
    assertThat(repeated).containsExactly(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3).inOrder();
  }
 Pattern Name: FocalMethod_Match - Action: containsExactly - Predicate: N/A - Scenario: repeated

Project: guava
 Class: FluentIterableTest
 Method: testFirstMatch
 Body: {
    FluentIterable<String> iterable = FluentIterable.from(Lists.newArrayList("cool", "pants"));
    assertThat(iterable.firstMatch(Predicates.equalTo("cool"))).hasValue("cool");
    assertThat(iterable.firstMatch(Predicates.equalTo("pants"))).hasValue("pants");
    assertThat(iterable.firstMatch(Predicates.alwaysFalse())).isAbsent();
    assertThat(iterable.firstMatch(Predicates.alwaysTrue())).hasValue("cool");
  }
 Pattern Name: FocalMethod_Match - Action: firstMatch - Predicate: N/A - Scenario: iterable

Project: guava
 Class: FluentIterableTest
 Method: testLimit
 Body: {
    Iterable<String> iterable = Lists.newArrayList("foo", "bar", "baz");
    FluentIterable<String> limited = FluentIterable.from(iterable).limit(2);

    assertEquals(ImmutableList.of("foo", "bar"), Lists.newArrayList(limited));
    assertCanIterateAgain(limited);
    assertEquals("[foo, bar]", limited.toString());
  }
 Pattern Name: FocalMethod_Match - Action: newArrayList - Predicate: N/A - Scenario: limited

Project: guava
 Class: FluentIterableTest
 Method: testCycle
 Body: {
    FluentIterable<String> cycle = FluentIterable.from(asList("a", "b")).cycle();

    int howManyChecked = 0;
    for (String string : cycle) {
      String expected = (howManyChecked % 2 == 0) ? "a" : "b";
      assertEquals(expected, string);
      if (howManyChecked++ == 5) {
        break;
      }
    }

    // We left the last iterator pointing to "b". But a new iterator should
    // always point to "a".
    assertEquals("a", cycle.iterator().next());
  }
 Pattern Name: FocalMethod_Match - Action:  - Predicate: N/A - Scenario: string

Project: guava
 Class: FluentIterableTest
 Method: testTransformWith
 Body: {
    List<String> input = asList("1", "2", "3");
    Iterable<Integer> iterable = FluentIterable.from(input).transform(new IntegerValueOfFunction());

    assertEquals(asList(1, 2, 3), Lists.newArrayList(iterable));
    assertCanIterateAgain(iterable);
    assertEquals("[1, 2, 3]", iterable.toString());
  }
 Pattern Name: FocalMethod_Match - Action: from - Predicate: N/A - Scenario: input

