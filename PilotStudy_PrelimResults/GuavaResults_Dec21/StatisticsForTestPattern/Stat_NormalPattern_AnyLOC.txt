Project: guava
 Class: LocalCacheTest
 Method: testSegmentReplaceValue
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).expireAfterAccess(99999, SECONDS));
    Segment<Object, Object> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    int index = hash & (table.length() - 1);

    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
    entry.setValueReference(oldValueRef);

    // no entry
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(0, segment.count);

    // same value
    table.set(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertTrue(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // different value
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    entry.setValueReference(oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: get=5 ) - Predicate: replace - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testComputeExistingEntry
 Body: {
    CountingLoader loader = new CountingLoader();
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
    assertEquals(0, loader.getCount());

    Object key = new Object();
    Object value = new Object();
    map.put(key, value);

    assertEquals(value, map.get(key, loader));
    assertEquals(0, loader.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getCount=2 ) - Predicate: getCount - Scenario: loader (Alternative Scenario: loader=1 )

Project: guava
 Class: LocalCacheTest
 Method: testClear_notification
 Body: {
    QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .initialCapacity(1)
                .maximumSize(SMALL_MAX_SIZE)
                .expireAfterWrite(99999, SECONDS)
                .removalListener(listener));
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);
    segment.recordWrite(entry, 1, map.ticker.read());
    segment.table.set(0, entry);
    segment.readCount.incrementAndGet();
    segment.count = 1;
    segment.totalWeight = 1;

    assertSame(entry, table.get(0));
    assertSame(entry, segment.accessQueue.peek());
    assertSame(entry, segment.writeQueue.peek());

    segment.clear();
    assertNull(table.get(0));
    assertTrue(segment.accessQueue.isEmpty());
    assertTrue(segment.writeQueue.isEmpty());
    assertEquals(0, segment.readCount.get());
    assertEquals(0, segment.count);
    assertEquals(0, segment.totalWeight);
    assertNotified(listener, key, value, RemovalCause.EXPLICIT);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: recordWrite (Alternative Action: get=3 ) - Predicate: length - Scenario: listener (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testGetOrDefault
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
    map.put(1, 1);
    assertEquals(1, map.getOrDefault(1, 2));
    assertEquals(2, map.getOrDefault(2, 2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getOrDefault=2 ) - Predicate: getOrDefault - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LocalCacheTest
 Method: testSegmentPut
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).expireAfterAccess(99999, SECONDS));
    Segment<Object, Object> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, false));
    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
    DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
    entry.setValueReference(oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: get=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemoveComputingValue
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .initialCapacity(1)
                .maximumSize(SMALL_MAX_SIZE)
                .expireAfterWrite(99999, SECONDS)
                .removalListener(countingRemovalListener()));
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    int hash = map.hash(key);
    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    LoadingValueReference<Object, Object> valueRef = new LoadingValueReference<>();
    entry.setValueReference(valueRef);

    // absent
    assertFalse(segment.removeLoadingValue(key, hash, valueRef));

    // live
    table.set(0, entry);
    // don't increment count; this is used during computation
    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
    // no notification sent with removeLoadingValue
    assertTrue(map.removalNotificationQueue.isEmpty());
    assertEquals(0, segment.count);
    assertNull(table.get(0));

    // active
    Object value = new Object();
    DummyValueReference<Object, Object> previousRef = DummyValueReference.create(value);
    valueRef = new LoadingValueReference<>(previousRef);
    entry.setValueReference(valueRef);
    table.set(0, entry);
    segment.count = 1;
    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
    assertSame(entry, table.get(0));
    assertSame(value, segment.get(key, hash));

    // wrong value reference
    table.set(0, entry);
    DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);
    entry.setValueReference(otherValueRef);
    assertFalse(segment.removeLoadingValue(key, hash, valueRef));
    entry.setValueReference(valueRef);
    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: removeLoadingValue=5 ) - Predicate: length - Scenario: map (Alternative Scenario: valueRef=1 )

Project: guava
 Class: LocalCacheTest
 Method: testComputePartiallyCollectedKey
 Body: {
    CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);
    CountingLoader loader = new CountingLoader();
    LocalCache<Object, Object> map = makeLocalCache(builder);
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(0, loader.getCount());

    Object key = new Object();
    int hash = map.hash(key);
    Object value = new Object();
    int index = hash & (table.length() - 1);

    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> valueRef = DummyValueReference.create(value);
    entry.setValueReference(valueRef);
    table.set(index, entry);
    segment.count++;

    assertSame(value, map.get(key, loader));
    assertEquals(0, loader.getCount());
    assertEquals(1, segment.count);

    entry.clearKey();
    assertNotSame(value, map.get(key, loader));
    assertEquals(1, loader.getCount());
    assertEquals(2, segment.count);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: getCount=3 ) - Predicate: getCount - Scenario: builder (Alternative Scenario: valueRef=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemoveIfWithConcurrentRemoval
 Body: {
    LocalCache<Integer, Integer> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
    map.put(0, 1);
    map.put(1, 1);
    map.put(2, 1);
    map.entrySet()
        .removeIf(
            entry -> {
              assertThat(entry.getValue()).isNotNull();
              map.remove((entry.getKey() + 1) % 3);
              return false;
            });
    assertEquals(1, map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemovalListener_size
 Body: {
    QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));
    assertTrue(listener.isEmpty());

    Object one = new Object();
    Object two = new Object();
    Object three = new Object();
    Object four = new Object();

    map.put(one, two);
    map.put(two, three);
    assertTrue(listener.isEmpty());
    map.put(three, four);
    assertNotified(listener, one, two, RemovalCause.SIZE);

    assertTrue(listener.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: isEmpty=3 ) - Predicate: isEmpty - Scenario: listener (Alternative Scenario: four=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemovalListener_replaced
 Body: {
    QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));
    assertTrue(listener.isEmpty());

    Object one = new Object();
    Object two = new Object();
    Object three = new Object();
    Object four = new Object();
    Object five = new Object();
    Object six = new Object();

    map.put(one, two);
    map.put(one, three);
    assertNotified(listener, one, two, RemovalCause.REPLACED);

    Map<Object, Object> newMap = ImmutableMap.of(one, four);
    map.putAll(newMap);
    assertNotified(listener, one, three, RemovalCause.REPLACED);

    map.replace(one, five);
    assertNotified(listener, one, four, RemovalCause.REPLACED);

    map.replace(one, five, six);
    assertNotified(listener, one, five, RemovalCause.REPLACED);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: replace=2 ) - Predicate: isEmpty - Scenario: listener (Alternative Scenario: six=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemovalListener_collected
 Body: {
    QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));
    Segment<Object, Object> segment = map.segments[0];
    assertTrue(listener.isEmpty());

    Object one = new Object();
    Object two = new Object();
    Object three = new Object();

    map.put(one, two);
    map.put(two, three);
    assertTrue(listener.isEmpty());

    int hash = map.hash(one);
    ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);
    map.reclaimValue(entry.getValueReference());
    assertNotified(listener, one, two, RemovalCause.COLLECTED);

    assertTrue(listener.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: isEmpty=3 ) - Predicate: isEmpty - Scenario: listener (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testValues
 Body: {
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
    map.put("foo", "bar");
    map.put("baz", "bar");
    map.put("quux", "quux");
    assertFalse(map.values() instanceof Set);
    assertTrue(map.values().removeAll(ImmutableSet.of("bar")));
    assertEquals(1, map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LocalCacheTest
 Method: testSegmentPutIfAbsent
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).expireAfterAccess(99999, SECONDS));
    Segment<Object, Object> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, true));
    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));

    // cleared
    ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
    DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
    entry.setValueReference(oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: get=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemoveIfWithConcurrentModification
 Body: {
    LocalCache<Integer, Integer> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
    map.put(1, 1);
    map.put(2, 1);
    map.put(3, 1);
    map.entrySet()
        .removeIf(
            entry -> {
              if (entry.getValue().equals(1)) {
                map.put(entry.getKey(), 2);
                return true;
              } else {
                return false;
              }
            });
    assertEquals(3, map.size());
    assertFalse(map.containsValue(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: size - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LocalCacheTest
 Method: testClear
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .initialCapacity(1)
                .maximumSize(SMALL_MAX_SIZE)
                .expireAfterWrite(99999, SECONDS));
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);
    segment.recordWrite(entry, 1, map.ticker.read());
    segment.table.set(0, entry);
    segment.readCount.incrementAndGet();
    segment.count = 1;
    segment.totalWeight = 1;

    assertSame(entry, table.get(0));
    assertSame(entry, segment.accessQueue.peek());
    assertSame(entry, segment.writeQueue.peek());

    segment.clear();
    assertNull(table.get(0));
    assertTrue(segment.accessQueue.isEmpty());
    assertTrue(segment.writeQueue.isEmpty());
    assertEquals(0, segment.readCount.get());
    assertEquals(0, segment.count);
    assertEquals(0, segment.totalWeight);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: recordWrite (Alternative Action: get=3 ) - Predicate: length - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testSegmentReplace
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(createCacheBuilder().concurrencyLevel(1).expireAfterAccess(99999, SECONDS));
    Segment<Object, Object> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    int index = hash & (table.length() - 1);

    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
    entry.setValueReference(oldValueRef);

    // no entry
    assertNull(segment.replace(key, hash, newValue));
    assertEquals(0, segment.count);

    // same key
    table.set(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.replace(key, hash, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    entry.setValueReference(oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.replace(key, hash, newValue));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: get=4 ) - Predicate: replace - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemovalListener_expired
 Body: {
    FakeTicker ticker = new FakeTicker();
    QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .expireAfterWrite(3, TimeUnit.NANOSECONDS)
                .ticker(ticker)
                .removalListener(listener));
    assertTrue(listener.isEmpty());

    Object one = new Object();
    Object two = new Object();
    Object three = new Object();
    Object four = new Object();
    Object five = new Object();

    map.put(one, two);
    ticker.advance(1);
    map.put(two, three);
    ticker.advance(1);
    map.put(three, four);
    assertTrue(listener.isEmpty());
    ticker.advance(1);
    map.put(four, five);
    assertNotified(listener, one, two, RemovalCause.EXPIRED);

    assertTrue(listener.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: isEmpty - Scenario: ticker (Alternative Scenario: ticker=1 )

Project: guava
 Class: LocalCacheTest
 Method: testSegmentRefresh_duplicate
 Body: {
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().concurrencyLevel(1));
    Segment<Object, Object> segment = map.segments[0];

    Object key = new Object();
    int hash = map.hash(key);
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    int index = hash & (table.length() - 1);

    // already loading
    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> valueRef = DummyValueReference.create(null);
    valueRef.setLoading(true);
    entry.setValueReference(valueRef);
    table.set(index, entry);
    assertNull(segment.refresh(key, hash, identityLoader(), false));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setLoading (Alternative Action: create=2 ) - Predicate: refresh - Scenario: valueRef (Alternative Scenario: valueRef=1 )

Project: guava
 Class: LocalCacheTest
 Method: testExpireAfterWrite
 Body: {
    FakeTicker ticker = new FakeTicker();
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .ticker(ticker)
                .expireAfterWrite(2, TimeUnit.NANOSECONDS));
    Segment<Object, Object> segment = map.segments[0];

    Object key = new Object();
    Object value = new Object();
    map.put(key, value);
    ReferenceEntry<Object, Object> entry = map.getEntry(key);
    assertTrue(map.isLive(entry, ticker.read()));

    segment.writeQueue.add(entry);
    assertSame(value, map.get(key));
    assertSame(entry, segment.writeQueue.peek());
    assertEquals(1, segment.writeQueue.size());

    segment.recordRead(entry, ticker.read());
    segment.expireEntries(ticker.read());
    assertSame(value, map.get(key));
    assertSame(entry, segment.writeQueue.peek());
    assertEquals(1, segment.writeQueue.size());

    ticker.advance(1);
    segment.recordRead(entry, ticker.read());
    segment.expireEntries(ticker.read());
    assertSame(value, map.get(key));
    assertSame(entry, segment.writeQueue.peek());
    assertEquals(1, segment.writeQueue.size());

    ticker.advance(1);
    assertNull(map.get(key));
    segment.expireEntries(ticker.read());
    assertNull(map.get(key));
    assertTrue(segment.writeQueue.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: read=6 ) - Predicate: isLive - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testComputePartiallyCollectedValue
 Body: {
    CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);
    CountingLoader loader = new CountingLoader();
    LocalCache<Object, Object> map = makeLocalCache(builder);
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(0, loader.getCount());

    Object key = new Object();
    int hash = map.hash(key);
    Object value = new Object();
    int index = hash & (table.length() - 1);

    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> valueRef = DummyValueReference.create(value);
    entry.setValueReference(valueRef);
    table.set(index, entry);
    segment.count++;

    assertSame(value, map.get(key, loader));
    assertEquals(0, loader.getCount());
    assertEquals(1, segment.count);

    valueRef.clear();
    assertNotSame(value, map.get(key, loader));
    assertEquals(1, loader.getCount());
    assertEquals(1, segment.count);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: getCount=3 ) - Predicate: getCount - Scenario: builder (Alternative Scenario: valueRef=1 )

Project: guava
 Class: LocalCacheTest
 Method: testComputeIfAbsent_RemovalListener
 Body: {
    List<RemovalNotification<Object, Object>> notifications = new ArrayList<>();
    RemovalListener<Object, Object> removalListener =
        new RemovalListener<Object, Object>() {
          @Override
          public void onRemoval(RemovalNotification<Object, Object> notification) {
            notifications.add(notification);
          }
        };
    Cache<Object, Object> cache =
        CacheBuilder.newBuilder().removalListener(removalListener).build();
    cache.put("a", "b");
    cache.asMap().computeIfAbsent("a", k -> "c");
    assertTrue(notifications.toString(), notifications.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: add=1 ) - Predicate: toString - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: LocalCacheTest
 Method: testSegmentRemove
 Body: {
    LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().concurrencyLevel(1));
    Segment<Object, Object> segment = map.segments[0];

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    int index = hash & (table.length() - 1);

    DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);
    DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
    entry.setValueReference(oldValueRef);

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);

    // same key
    table.set(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.remove(key, hash));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));

    // cleared
    table.set(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueReference (Alternative Action: get=4 ) - Predicate: N/A - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: LocalCacheTest
 Method: testRemoveEntry
 Body: {
    LocalCache<Object, Object> map =
        makeLocalCache(
            createCacheBuilder()
                .concurrencyLevel(1)
                .initialCapacity(1)
                .maximumSize(SMALL_MAX_SIZE)
                .expireAfterWrite(99999, SECONDS)
                .removalListener(countingRemovalListener()));
    Segment<Object, Object> segment = map.segments[0];
    AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);

    // remove absent
    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));

    // remove live
    segment.recordWrite(entry, 1, map.ticker.read());
    table.set(0, entry);
    segment.count = 1;
    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));
    assertNotificationEnqueued(map, key, value, hash);
    assertTrue(map.removalNotificationQueue.isEmpty());
    assertFalse(segment.accessQueue.contains(entry));
    assertFalse(segment.writeQueue.contains(entry));
    assertEquals(0, segment.count);
    assertNull(table.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: recordWrite (Alternative Action: removeEntry=2 ) - Predicate: length - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: SetsTest
 Method: testNewTreeSetEmptyNonGeneric
 Body: {
    TreeSet<LegacyComparable> set = Sets.newTreeSet();
    assertTrue(set.isEmpty());
    set.add(new LegacyComparable("foo"));
    set.add(new LegacyComparable("bar"));
    assertThat(set)
        .containsExactly(new LegacyComparable("bar"), new LegacyComparable("foo"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: isEmpty - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: SetsTest
 Method: testNewTreeSetEmptyDerived
 Body: {
    TreeSet<Derived> set = Sets.newTreeSet();
    assertTrue(set.isEmpty());
    set.add(new Derived("foo"));
    set.add(new Derived("bar"));
    assertThat(set).containsExactly(new Derived("bar"), new Derived("foo")).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: isEmpty - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: SetsTest
 Method: testNewSetFromMapSerialization
 Body: {
    Set<Integer> set = Sets.newSetFromMap(new LinkedHashMap<Integer, Boolean>());
    set.addAll(SOME_COLLECTION);
    Set<Integer> copy = SerializableTester.reserializeAndAssert(set);
    assertThat(copy).containsExactly(0, 1).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: addAll=1 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: set=1 )

Project: guava
 Class: RangeTest
 Method: testOpen
 Body: {
    Range<Integer> range = Range.open(4, 8);
    checkContains(range);
    assertTrue(range.hasLowerBound());
    assertEquals(4, (int) range.lowerEndpoint());
    assertEquals(OPEN, range.lowerBoundType());
    assertTrue(range.hasUpperBound());
    assertEquals(8, (int) range.upperEndpoint());
    assertEquals(OPEN, range.upperBoundType());
    assertFalse(range.isEmpty());
    assertEquals("(4..8)", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkContains (Alternative Action: upperBoundType=1 ) - Predicate: hasLowerBound - Scenario: range (Alternative Scenario: range=1 )

Project: guava
 Class: RangeTest
 Method: testClosed
 Body: {
    Range<Integer> range = Range.closed(5, 7);
    checkContains(range);
    assertTrue(range.hasLowerBound());
    assertEquals(5, (int) range.lowerEndpoint());
    assertEquals(CLOSED, range.lowerBoundType());
    assertTrue(range.hasUpperBound());
    assertEquals(7, (int) range.upperEndpoint());
    assertEquals(CLOSED, range.upperBoundType());
    assertFalse(range.isEmpty());
    assertEquals("[5..7]", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkContains (Alternative Action: upperBoundType=1 ) - Predicate: hasLowerBound - Scenario: range (Alternative Scenario: range=1 )

Project: guava
 Class: RangeTest
 Method: testClosedOpen
 Body: {
    Range<Integer> range = Range.closedOpen(5, 8);
    checkContains(range);
    assertTrue(range.hasLowerBound());
    assertEquals(5, (int) range.lowerEndpoint());
    assertEquals(CLOSED, range.lowerBoundType());
    assertTrue(range.hasUpperBound());
    assertEquals(8, (int) range.upperEndpoint());
    assertEquals(OPEN, range.upperBoundType());
    assertFalse(range.isEmpty());
    assertEquals("[5..8)", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkContains (Alternative Action: closedOpen=1 ) - Predicate: hasLowerBound - Scenario: range (Alternative Scenario: range=1 )

Project: guava
 Class: RangeTest
 Method: testOpenClosed
 Body: {
    Range<Integer> range = Range.openClosed(4, 7);
    checkContains(range);
    assertTrue(range.hasLowerBound());
    assertEquals(4, (int) range.lowerEndpoint());
    assertEquals(OPEN, range.lowerBoundType());
    assertTrue(range.hasUpperBound());
    assertEquals(7, (int) range.upperEndpoint());
    assertEquals(CLOSED, range.upperBoundType());
    assertFalse(range.isEmpty());
    assertEquals("(4..7]", range.toString());
    reserializeAndAssert(range);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkContains (Alternative Action: openClosed=1 ) - Predicate: hasLowerBound - Scenario: range (Alternative Scenario: range=1 )

Project: guava
 Class: MapEntrySetTester
 Method: testEntrySetIteratorRemove
 Body: {
    Set<Entry<K, V>> entrySet = getMap().entrySet();
    Iterator<Entry<K, V>> entryItr = entrySet.iterator();
    assertEquals(e0(), entryItr.next());
    entryItr.remove();
    assertTrue(getMap().isEmpty());
    assertFalse(entrySet.contains(e0()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: e0=2 ) - Predicate: e0 - Scenario: entrySet (Alternative Scenario: entryItr=1 )

Project: guava
 Class: MultimapAsMapTester
 Method: testAsMapEntrySetReflectsPutDifferentKey
 Body: {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));

    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    assertTrue(multimap().put(k1(), v4()));
    assertEquals(2, asMapEntrySet.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k0=2 ) - Predicate: put - Scenario: asMapEntrySet (Alternative Scenario: asMapEntrySet=1 )

Project: guava
 Class: MultimapAsMapTester
 Method: testAsMapEntrySetIteratorRemovePropagatesToMultimap
 Body: {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Iterator<Entry<K, Collection<V>>> asMapEntryItr = asMapEntrySet.iterator();
    asMapEntryItr.next();
    asMapEntryItr.remove();
    assertTrue(multimap().isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: k0=2 ) - Predicate: isEmpty - Scenario: asMapEntryItr (Alternative Scenario: asMapEntrySet=1 )

Project: guava
 Class: MultimapAsMapTester
 Method: testAsMapEntrySetReflectsPutSameKey
 Body: {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));

    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Collection<V> valueCollection = Iterables.getOnlyElement(asMapEntrySet).getValue();
    assertContentsAnyOrder(valueCollection, v0(), v3());
    assertTrue(multimap().put(k0(), v4()));
    assertContentsAnyOrder(valueCollection, v0(), v3(), v4());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k0=3 ) - Predicate: v0 - Scenario: asMapEntrySet (Alternative Scenario: valueCollection=1 )

Project: guava
 Class: MultimapAsMapTester
 Method: testAsMapEntrySetRemovePropagatesToMultimap
 Body: {
    resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
    Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
    Entry<K, Collection<V>> asMapEntry0 = Iterables.getOnlyElement(asMapEntrySet);
    assertTrue(multimap().put(k1(), v4()));
    assertTrue(asMapEntrySet.remove(asMapEntry0));
    assertEquals(1, multimap().size());
    assertContentsInOrder(multimap().keySet(), k1());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: multimap=4 ) - Predicate: put - Scenario: asMapEntrySet (Alternative Scenario: asMapEntry0=1 )

Project: guava
 Class: FutureCallbackTest
 Method: testExecutorSuccess
 Body: {
    CountingSameThreadExecutor ex = new CountingSameThreadExecutor();
    SettableFuture<String> f = SettableFuture.create();
    MockCallback callback = new MockCallback("foo");
    Futures.addCallback(f, callback, ex);
    f.set("foo");
    assertEquals(1, ex.runCount);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addCallback (Alternative Action: set=1 ) - Predicate: N/A - Scenario: callback (Alternative Scenario: ex=1 )

Project: guava
 Class: FutureCallbackTest
 Method: testOnSuccessThrowsRuntimeException
 Body: {
    RuntimeException exception = new RuntimeException();
    String result = "result";
    SettableFuture<String> future = SettableFuture.create();
    @SuppressWarnings("unchecked") // Safe for a mock
    FutureCallback<String> callback = Mockito.mock(FutureCallback.class);
    addCallback(future, callback, directExecutor());
    Mockito.doThrow(exception).when(callback).onSuccess(result);
    future.set(result);
    assertEquals(result, future.get());
    Mockito.verify(callback).onSuccess(result);
    Mockito.verifyNoMoreInteractions(callback);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addCallback (Alternative Action: onSuccess=2 ) - Predicate: get - Scenario: callback (Alternative Scenario: result=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: SubscriberRegistryTest
 Method: testUnregister
 Body: {
    StringSubscriber s1 = new StringSubscriber();
    StringSubscriber s2 = new StringSubscriber();

    registry.register(s1);
    registry.register(s2);

    registry.unregister(s1);
    assertEquals(1, registry.getSubscribersForTesting(String.class).size());

    registry.unregister(s2);
    assertTrue(registry.getSubscribersForTesting(String.class).isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: register (Alternative Action: unregister=2 ) - Predicate: size - Scenario: s2 (Alternative Scenario: s1=1 )

Project: guava
 Class: ToStringHelperTest
 Method: testToString_ToStringTwice
 Body: {
    MoreObjects.ToStringHelper helper =
        MoreObjects.toStringHelper(new TestClass())
            .add("field1", 1)
            .addValue("value1")
            .add("field2", "value2");
    final String expected = "TestClass{field1=1, value1, field2=value2}";

    assertEquals(expected, helper.toString());
    // Call toString again
    assertEquals(expected, helper.toString());

    // Make sure the cached value is reset when we modify the helper at all
    final String expected2 = "TestClass{field1=1, value1, field2=value2, 2}";
    helper.addValue(2);
    assertEquals(expected2, helper.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addValue (Alternative Action: toString=3 ) - Predicate: toString - Scenario: helper (Alternative Scenario: expected2=1 )

Project: guava
 Class: ExecutionSequencerTest
 Method: testCallableStartsAfterFirstFutureCompletes
 Body: {
    @SuppressWarnings({"unused", "nullness"})
    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
    @SuppressWarnings({"unused", "nullness"})
    Future<?> possiblyIgnoredError1 = serializer.submitAsync(secondCallable, directExecutor());
    assertThat(firstCallable.called).isTrue();
    assertThat(secondCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isTrue();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: directExecutor=2 ) - Predicate: N/A - Scenario: possiblyIgnoredError (Alternative Scenario: secondCallable=1 )

Project: guava
 Class: ExecutionSequencerTest
 Method: testCancellationDoesNotViolateSerialization
 Body: {
    @SuppressWarnings({"unused", "nullness"})
    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
    ListenableFuture<Void> secondFuture = serializer.submitAsync(secondCallable, directExecutor());
    TestCallable thirdCallable = new TestCallable(Futures.<Void>immediateFuture(null));
    @SuppressWarnings({"unused", "nullness"})
    Future<?> possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
    secondFuture.cancel(true);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isFalse();
    firstFuture.set(null);
    assertThat(secondCallable.called).isFalse();
    assertThat(thirdCallable.called).isTrue();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: directExecutor=3 ) - Predicate: N/A - Scenario: possiblyIgnoredError1 (Alternative Scenario: thirdCallable=1 )

Project: guava
 Class: ExecutionSequencerTest
 Method: testCancellationMultipleThreads
 Body: {
    final BlockingCallable blockingCallable = new BlockingCallable();
    ListenableFuture<Void> unused = serializer.submit(blockingCallable, executor);
    ListenableFuture<Boolean> future2 =
        serializer.submit(
            new Callable<Boolean>() {
              @Override
              public Boolean call() {
                return blockingCallable.isRunning();
              }
            },
            directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: waitForStart (Alternative Action: submit=2 ) - Predicate: N/A - Scenario: future2 (Alternative Scenario: future2=1 )

Project: guava
 Class: ExecutionSequencerTest
 Method: testToString
 Body: {
    Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
    TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());
    Future<?> second = serializer.submitAsync(secondCallable, directExecutor());
    assertThat(secondCallable.called).isFalse();
    assertThat(second.toString()).contains(secondCallable.toString());
    firstFuture.set(null);
    assertThat(second.toString()).contains(secondCallable.future.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: toString=4 ) - Predicate: N/A - Scenario: first (Alternative Scenario: secondCallable=1 )

Project: guava
 Class: ExecutionSequencerTest
 Method: testSecondTaskWaitsForFirstEvenIfCancelled
 Body: {
    final BlockingCallable blockingCallable = new BlockingCallable();
    ListenableFuture<Void> future1 = serializer.submit(blockingCallable, executor);
    ListenableFuture<Boolean> future2 =
        serializer.submit(
            new Callable<Boolean>() {
              @Override
              public Boolean call() {
                return blockingCallable.isRunning();
              }
            },
            directExecutor());

    // Wait for the first task to be started in the background. It will block until we explicitly
    // stop it.
    blockingCallable.waitForStart();

    // This time, cancel the future for the first task. The task remains running, only the future
    // is cancelled.
    future1.cancel(false);

    // Give the second task a chance to (incorrectly) start up while the first task is running.
    // (This is the assertion that fails.)
    assertThat(future2.isDone()).isFalse();

    // Stop the first task. The second task should then run.
    blockingCallable.stop();
    executor.shutdown();
    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
    assertThat(getDone(future2)).isFalse();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: waitForStart (Alternative Action: submit=2 ) - Predicate: N/A - Scenario: future2 (Alternative Scenario: future1=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_overflow
 Body: {
    CountingRemovalListener<Object, Object> removalListener = countingRemovalListener();
    IdentityLoader<Object> loader = identityLoader();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumWeight(1L << 31)
            .weigher(constantWeigher(Integer.MAX_VALUE))
            .removalListener(removalListener)
            .build(loader);
    cache.getUnchecked(objectWithHash(0));
    cache.getUnchecked(objectWithHash(0));
    CacheTesting.processPendingNotifications(cache);
    assertEquals(1, removalListener.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: getUnchecked (Alternative Action: objectWithHash=2 ) - Predicate: getCount - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_maxWeight_zero
 Body: {
    CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();
    IdentityLoader<Integer> loader = identityLoader();

    // Even numbers are free, odd are too expensive
    Weigher<Integer, Integer> evensOnly =
        new Weigher<Integer, Integer>() {
          @Override
          public int weigh(Integer k, Integer v) {
            return k % 2;
          }
        };

    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumWeight(0)
            .weigher(evensOnly)
            .removalListener(removalListener)
            .build(loader);

    // 1 won't be cached
    assertThat(cache.getUnchecked(1)).isEqualTo(1);
    assertThat(cache.asMap().keySet()).isEmpty();

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(1);

    // 2 will be cached
    assertThat(cache.getUnchecked(2)).isEqualTo(2);
    assertThat(cache.asMap().keySet()).containsExactly(2);

    CacheTesting.processPendingNotifications(cache);
    CacheTesting.checkValidState(cache);
    assertThat(removalListener.getCount()).isEqualTo(1);

    // 4 will be cached
    assertThat(cache.getUnchecked(4)).isEqualTo(4);
    assertThat(cache.asMap().keySet()).containsExactly(2, 4);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(1);

    // 5 won't be cached, won't dump cache
    assertThat(cache.getUnchecked(5)).isEqualTo(5);
    assertThat(cache.asMap().keySet()).containsExactly(2, 4);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(2);

    // Should we pepper more of these calls throughout the above? Where?
    CacheTesting.checkValidState(cache);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: processPendingNotifications (Alternative Action: asMap=4 ) - Predicate: N/A - Scenario: removalListener (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_lru
 Body: {
    // test lru within a single segment
    IdentityLoader<Integer> loader = identityLoader();
    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(10).build(loader);
    CacheTesting.warmUp(cache, 0, 10);
    Set<Integer> keySet = cache.asMap().keySet();
    assertThat(keySet).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);

    // re-order
    getAll(cache, asList(0, 1, 2));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(3, 4, 5, 6, 7, 8, 9, 0, 1, 2);

    // evict 3, 4, 5
    getAll(cache, asList(10, 11, 12));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(6, 7, 8, 9, 0, 1, 2, 10, 11, 12);

    // re-order
    getAll(cache, asList(6, 7, 8));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(9, 0, 1, 2, 10, 11, 12, 6, 7, 8);

    // evict 9, 0, 1
    getAll(cache, asList(13, 14, 15));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(2, 10, 11, 12, 6, 7, 8, 13, 14, 15);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: warmUp (Alternative Action: getAll=4 ) - Predicate: N/A - Scenario: keySet (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_invalidateAll
 Body: {
    // test that .invalidateAll() resets total weight state correctly
    IdentityLoader<Integer> loader = identityLoader();
    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(10).build(loader);

    Set<Integer> keySet = cache.asMap().keySet();
    assertThat(keySet).isEmpty();

    // add 0, 1, 2, 3, 4
    getAll(cache, asList(0, 1, 2, 3, 4));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(0, 1, 2, 3, 4);

    // invalidate all
    cache.invalidateAll();
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).isEmpty();

    // add 5, 6, 7, 8, 9, 10, 11, 12
    getAll(cache, asList(5, 6, 7, 8, 9, 10, 11, 12));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(5, 6, 7, 8, 9, 10, 11, 12);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: getAll (Alternative Action: drainRecencyQueues=3 ) - Predicate: N/A - Scenario: loader (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_overweight
 Body: {
    // test weighted lru within a single segment
    IdentityLoader<Integer> loader = identityLoader();
    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumWeight(45)
            .weigher(intKeyWeigher())
            .build(loader);
    CacheTesting.warmUp(cache, 0, 10);
    Set<Integer> keySet = cache.asMap().keySet();
    assertThat(keySet).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);

    // add an at-the-maximum-weight entry
    getAll(cache, asList(45));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(0, 45);

    // add an over-the-maximum-weight entry
    getAll(cache, asList(46));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).contains(0);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: warmUp (Alternative Action: getAll=2 ) - Predicate: N/A - Scenario: keySet (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_maxWeight_entryTooBig
 Body: {
    CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();
    IdentityLoader<Integer> loader = identityLoader();

    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumWeight(4)
            .weigher(intValueWeigher())
            .removalListener(removalListener)
            .build(loader);

    // caches 2
    assertThat(cache.getUnchecked(2)).isEqualTo(2);
    assertThat(cache.asMap().keySet()).containsExactly(2);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(0);

    // caches 3, evicts 2
    assertThat(cache.getUnchecked(3)).isEqualTo(3);
    assertThat(cache.asMap().keySet()).containsExactly(3);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(1);

    // doesn't cache 5, doesn't evict
    assertThat(cache.getUnchecked(5)).isEqualTo(5);
    assertThat(cache.asMap().keySet()).containsExactly(3);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(2);

    // caches 1, evicts nothing
    assertThat(cache.getUnchecked(1)).isEqualTo(1);
    assertThat(cache.asMap().keySet()).containsExactly(3, 1);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(2);

    // caches 4, evicts 1 and 3
    assertThat(cache.getUnchecked(4)).isEqualTo(4);
    assertThat(cache.asMap().keySet()).containsExactly(4);

    CacheTesting.processPendingNotifications(cache);
    assertThat(removalListener.getCount()).isEqualTo(4);

    // Should we pepper more of these calls throughout the above? Where?
    CacheTesting.checkValidState(cache);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: processPendingNotifications (Alternative Action: asMap=5 ) - Predicate: N/A - Scenario: removalListener (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheEvictionTest
 Method: testEviction_weightedLru
 Body: {
    // test weighted lru within a single segment
    IdentityLoader<Integer> loader = identityLoader();
    LoadingCache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .maximumWeight(45)
            .weigher(intKeyWeigher())
            .build(loader);
    CacheTesting.warmUp(cache, 0, 10);
    Set<Integer> keySet = cache.asMap().keySet();
    assertThat(keySet).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);

    // re-order
    getAll(cache, asList(0, 1, 2));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(3, 4, 5, 6, 7, 8, 9, 0, 1, 2);

    // evict 3, 4, 5
    getAll(cache, asList(10));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(6, 7, 8, 9, 0, 1, 2, 10);

    // re-order
    getAll(cache, asList(6, 7, 8));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(9, 0, 1, 2, 10, 6, 7, 8);

    // evict 9, 1, 2, 10
    getAll(cache, asList(15));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(0, 6, 7, 8, 15);

    // fill empty space
    getAll(cache, asList(9));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(0, 6, 7, 8, 15, 9);

    // evict 6
    getAll(cache, asList(1));
    CacheTesting.drainRecencyQueues(cache);
    assertThat(keySet).containsExactly(0, 7, 8, 15, 9, 1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: warmUp (Alternative Action: getAll=6 ) - Predicate: N/A - Scenario: keySet (Alternative Scenario: cache=1 )

Project: guava
 Class: MultimapGetTester
 Method: testPropagatesRemoveToMultimap
 Body: {
    resetContainer(
        Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()), Helpers.mapEntry(k0(), v2()));
    Collection<V> result = multimap().get(k0());
    assertTrue(result.remove(v0()));
    assertFalse(multimap().containsEntry(k0(), v0()));
    assertEquals(2, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k0=5 ) - Predicate: remove - Scenario: result (Alternative Scenario: result=1 )

Project: guava
 Class: MultimapAsMapGetTester
 Method: testPropagatesClearToMultimap
 Body: {
    Collection<V> result = multimap().asMap().get(k0());
    result.clear();
    assertGet(k0());
    assertEmpty(result);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: k0=2 ) - Predicate: k0 - Scenario: result (Alternative Scenario: result=1 )

Project: guava
 Class: MultimapAsMapGetTester
 Method: testPropagatesRemoveToMultimap
 Body: {
    resetContainer(
        Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()), Helpers.mapEntry(k0(), v2()));
    Collection<V> result = multimap().asMap().get(k0());
    assertTrue(result.remove(v0()));
    assertFalse(multimap().containsEntry(k0(), v0()));
    assertEquals(2, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k0=5 ) - Predicate: remove - Scenario: result (Alternative Scenario: result=1 )

Project: guava
 Class: MoreExecutorsTest
 Method: testDirectExecutorServiceServiceInThreadExecution
 Body: {
    final ListeningExecutorService executor = newDirectExecutorService();
    final ThreadLocal<Integer> threadLocalCount =
        new ThreadLocal<Integer>() {
          @Override
          protected Integer initialValue() {
            return 0;
          }
        };
    final AtomicReference<Throwable> throwableFromOtherThread = new AtomicReference<>(null);
    final Runnable incrementTask =
        new Runnable() {
          @Override
          public void run() {
            threadLocalCount.set(threadLocalCount.get() + 1);
          }
        };

    Thread otherThread =
        new Thread(
            new Runnable() {
              @Override
              public void run() {
                try {
                  Future<?> future = executor.submit(incrementTask);
                  assertTrue(future.isDone());
                  assertEquals(1, threadLocalCount.get().intValue());
                } catch (Throwable t) {
                  throwableFromOtherThread.set(t);
                }
              }
            });

    otherThread.start();

    ListenableFuture<?> future = executor.submit(incrementTask);
    assertTrue(future.isDone());
    assertListenerRunImmediately(future);
    assertEquals(1, threadLocalCount.get().intValue());
    otherThread.join(1000);
    assertEquals(Thread.State.TERMINATED, otherThread.getState());
    Throwable throwable = throwableFromOtherThread.get();
    assertNull(
        "Throwable from other thread: "
            + (throwable == null ? null : Throwables.getStackTraceAsString(throwable)),
        throwableFromOtherThread.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: get=5 ) - Predicate: isDone - Scenario: future (Alternative Scenario: future=2 )

Project: guava
 Class: MoreExecutorsTest
 Method: testShutdownAndAwaitTermination_forcedShutDownInternal
 Body: {
    ExecutorService service = mock(ExecutorService.class);
    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS))
        .thenReturn(false)
        .thenReturn(true);
    when(service.isTerminated()).thenReturn(true);
    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));
    verify(service).shutdown();
    verify(service, times(2)).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);
    verify(service).shutdownNow();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=3 ) - Predicate: shutdownAndAwaitTermination - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: MoreExecutorsTest
 Method: testShutdownAndAwaitTermination_immediateShutdownInternal
 Body: {
    ExecutorService service = mock(ExecutorService.class);
    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS)).thenReturn(true);
    when(service.isTerminated()).thenReturn(true);
    assertTrue(shutdownAndAwaitTermination(service, 1L, SECONDS));
    verify(service).shutdown();
    verify(service).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=2 ) - Predicate: shutdownAndAwaitTermination - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: MoreExecutorsTest
 Method: testShutdownAndAwaitTermination_interruptedInternal
 Body: {
    final ExecutorService service = mock(ExecutorService.class);
    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS))
        .thenThrow(new InterruptedException());

    final AtomicBoolean terminated = new AtomicBoolean();
    // we need to keep this in a flag because t.isInterrupted() returns false after t.join()
    final AtomicBoolean interrupted = new AtomicBoolean();
    // we need to use another thread because it will be interrupted and thus using
    // the current one, owned by JUnit, would make the test fail
    Thread thread =
        new Thread(
            new Runnable() {
              @Override
              public void run() {
                terminated.set(shutdownAndAwaitTermination(service, 1L, SECONDS));
                interrupted.set(Thread.currentThread().isInterrupted());
              }
            });
    thread.start();
    thread.join();
    verify(service).shutdown();
    verify(service).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);
    verify(service).shutdownNow();
    assertTrue(interrupted.get());
    assertFalse(terminated.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: verify=3 ) - Predicate: get - Scenario: thread (Alternative Scenario: service=1 )

Project: guava
 Class: MoreExecutorsTest
 Method: testListeningDecorator_scheduleSuccess
 Body: {
    final CountDownLatch completed = new CountDownLatch(1);
    ScheduledThreadPoolExecutor delegate =
        new ScheduledThreadPoolExecutor(1) {
          @Override
          protected void afterExecute(Runnable r, Throwable t) {
            completed.countDown();
          }
        };
    ListeningScheduledExecutorService service = listeningDecorator(delegate);
    ListenableFuture<Integer> future =
        service.schedule(Callables.returning(42), 1, TimeUnit.MILLISECONDS);

    /*
     * Wait not just until the Future's value is set (as in future.get()) but
     * also until ListeningScheduledExecutorService's wrapper task is done
     * executing listeners, as detected by yielding control to afterExecute.
     */
    completed.await();
    assertTrue(future.isDone());
    assertThat(future.get()).isEqualTo(42);
    assertListenerRunImmediately(future);
    assertEquals(0, delegate.getQueue().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: await (Alternative Action: schedule=1 ) - Predicate: isDone - Scenario: future (Alternative Scenario: delegate=1 )

Project: guava
 Class: MoreExecutorsTest
 Method: testShutdownAndAwaitTermination_nonTerminationInternal
 Body: {
    ExecutorService service = mock(ExecutorService.class);
    when(service.awaitTermination(HALF_SECOND_NANOS, NANOSECONDS))
        .thenReturn(false)
        .thenReturn(false);
    assertFalse(shutdownAndAwaitTermination(service, 1L, SECONDS));
    verify(service).shutdown();
    verify(service, times(2)).awaitTermination(HALF_SECOND_NANOS, NANOSECONDS);
    verify(service).shutdownNow();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: verify=3 ) - Predicate: shutdownAndAwaitTermination - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: MultimapKeysTester
 Method: testKeysWithNullKey
 Body: {
    resetContainer(
        Helpers.mapEntry((K) null, v0()),
        Helpers.mapEntry((K) null, v1()),
        Helpers.mapEntry(k1(), v0()));
    Multiset<K> keys = multimap().keys();
    assertEquals(2, keys.count(null));
    assertEquals(1, keys.count(k1()));
    assertEquals(3, keys.size());
    assertContainsAllOf(keys, null, k1());
    assertContainsAllOf(
        keys.entrySet(), Multisets.immutableEntry((K) null, 2), Multisets.immutableEntry(k1(), 1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k1=4 ) - Predicate: count - Scenario: keys (Alternative Scenario: keys=1 )

Project: guava
 Class: MultimapKeysTester
 Method: testKeys
 Body: {
    resetContainer(
        Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v1()), Helpers.mapEntry(k1(), v0()));
    Multiset<K> keys = multimap().keys();
    assertEquals(2, keys.count(k0()));
    assertEquals(1, keys.count(k1()));
    assertEquals(3, keys.size());
    assertContainsAllOf(keys, k0(), k1());
    assertContainsAllOf(
        keys.entrySet(), Multisets.immutableEntry(k0(), 2), Multisets.immutableEntry(k1(), 1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: resetContainer (Alternative Action: k0=5 ) - Predicate: count - Scenario: keys (Alternative Scenario: keys=1 )

Project: guava
 Class: MultimapKeysTester
 Method: testKeysEntrySetIteratorRemove
 Body: {
    Multiset<K> keys = multimap().keys();
    Iterator<Multiset.Entry<K>> itr = keys.entrySet().iterator();
    assertEquals(Multisets.immutableEntry(k0(), 1), itr.next());
    itr.remove();
    assertTrue(multimap().isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: multimap=2 ) - Predicate: immutableEntry - Scenario: keys (Alternative Scenario: itr=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInverseEntrySetValueNewKey
 Body: {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, "a");
    map.put(2, "b");
    Iterator<Entry<String, Integer>> inverseEntryItr = map.inverse().entrySet().iterator();
    Entry<String, Integer> entry = inverseEntryItr.next();
    entry.setValue(3);
    assertEquals(Maps.immutableEntry("b", 2), inverseEntryItr.next());
    assertFalse(inverseEntryItr.hasNext());
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry(2, "b"), Maps.immutableEntry(3, "a"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: immutableEntry=3 ) - Predicate: immutableEntry - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrder
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);
    assertThat(map.entrySet())
        .containsExactly(
            Maps.immutableEntry("foo", 1),
            Maps.immutableEntry("bar", 2),
            Maps.immutableEntry("quux", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: immutableEntry=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrderAfterForcePut
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.forcePut("quux", 1);
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry("bar", 2), Maps.immutableEntry("quux", 1))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInverseInsertionOrderAfterInverse
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("bar", 2);
    map.put("quux", 1);

    assertThat(map.inverse().entrySet())
        .containsExactly(Maps.immutableEntry(2, "bar"), Maps.immutableEntry(1, "quux"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: immutableEntry=2 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInverseInsertionOrderAfterInverseForcePut
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.inverse().forcePut(1, "quux");
    assertThat(map.inverse().entrySet())
        .containsExactly(Maps.immutableEntry(2, "bar"), Maps.immutableEntry(1, "quux"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testBiMapEntrySetIteratorRemove
 Body: {
    BiMap<Integer, String> map = HashBiMap.create();
    map.put(1, "one");
    Set<Entry<Integer, String>> entries = map.entrySet();
    Iterator<Entry<Integer, String>> iterator = entries.iterator();
    Entry<Integer, String> entry = iterator.next();
    entry.setValue("two"); // changes the iterator's current entry value
    assertEquals("two", map.get(1));
    assertEquals(Integer.valueOf(1), map.inverse().get("two"));
    iterator.remove(); // removes the updated entry
    assertTrue(map.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: get=2 ) - Predicate: get - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInverseInsertionOrderAfterInverseForcePutPresentKey
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);
    map.put("nab", 4);

    map.inverse().forcePut(4, "bar");
    assertThat(map.entrySet())
        .containsExactly(
            Maps.immutableEntry("foo", 1),
            Maps.immutableEntry("bar", 4),
            Maps.immutableEntry("quux", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrderAfterRemoveMiddle
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.remove("bar");
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry("foo", 1), Maps.immutableEntry("quux", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrderAfterRemoveLast
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.remove("quux");
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry("foo", 1), Maps.immutableEntry("bar", 2))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrderAfterRemoveFirst
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.remove("foo");
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry("bar", 2), Maps.immutableEntry("quux", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: HashBiMapTest
 Method: testInsertionOrderAfterInverseForcePut
 Body: {
    BiMap<String, Integer> map = HashBiMap.create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("quux", 3);

    map.inverse().forcePut(1, "quux");
    assertThat(map.entrySet())
        .containsExactly(Maps.immutableEntry("bar", 2), Maps.immutableEntry("quux", 1))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_directedVsUndirected
 Body: {
    network.addEdge(N1, N2, E12);

    MutableNetwork<Integer, String> g2 = createNetwork(oppositeType(edgeType));
    g2.addEdge(N1, N2, E12);

    assertThat(network).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_propertiesDiffer
 Body: {
    network.addEdge(N1, N2, E12);

    MutableNetwork<Integer, String> g2 =
        NetworkBuilder.from(network)
            .allowsParallelEdges(!network.allowsParallelEdges())
            .allowsSelfLoops(!network.allowsSelfLoops())
            .build();
    g2.addEdge(N1, N2, E12);

    assertThat(network).isEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_edgeSetsDiffer
 Body: {
    network.addEdge(N1, N2, E12);

    MutableNetwork<Integer, String> g2 = createNetwork(edgeType);
    g2.addEdge(N1, N2, E13);

    assertThat(network).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_nodeSetsDiffer
 Body: {
    network.addNode(N1);

    MutableNetwork<Integer, String> g2 = createNetwork(edgeType);
    g2.addNode(N2);

    assertThat(network).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_selfLoop_directedVsUndirected
 Body: {
    network.addEdge(N1, N1, E11);

    MutableNetwork<Integer, String> g2 = createNetwork(oppositeType(edgeType));
    g2.addEdge(N1, N1, E11);

    assertThat(network).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_connectionsDiffer
 Body: {
    network.addEdge(N1, N2, E12);
    network.addEdge(N1, N3, E13);

    MutableNetwork<Integer, String> g2 = createNetwork(edgeType);
    // connect E13 to N1 and N2, and E12 to N1 and N3 => not equivalent
    g2.addEdge(N1, N2, E13);
    g2.addEdge(N1, N3, E12);

    assertThat(network).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=4 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: NetworkEquivalenceTest
 Method: equivalent_edgeAddOrdersDiffer
 Body: {
    NetworkBuilder<Integer, String> builder =
        NetworkBuilder.from(network).allowsParallelEdges(true);
    MutableNetwork<Integer, String> g1 = builder.build();
    MutableNetwork<Integer, String> g2 = builder.build();

    // for ug1, add e12 first, then e12_a
    g1.addEdge(N1, N2, E12);
    g1.addEdge(N1, N2, E12_A);

    // for ug2, add e12_a first, then e12
    g2.addEdge(N1, N2, E12_A);
    g2.addEdge(N1, N2, E12);

    assertThat(g1).isEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=4 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: builder=1 )

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceStartStop
 Body: {
    WaitOnRunService service = new WaitOnRunService();
    assertFalse(service.startUpCalled);

    service.startAsync().awaitRunning();
    assertTrue(service.startUpCalled);
    assertEquals(Service.State.RUNNING, service.state());

    enterRun.await(); // to avoid stopping the service until run() is invoked

    service.stopAsync().awaitTerminated();
    assertTrue(service.shutDownCalled);
    assertEquals(Service.State.TERMINATED, service.state());
    executionThread.join();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: N/A - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testStopWhileStarting_runNotCalled
 Body: {
    final CountDownLatch started = new CountDownLatch(1);
    FakeService service =
        new FakeService() {
          @Override
          protected void startUp() throws Exception {
            super.startUp();
            started.await();
          }
        };
    service.startAsync();
    service.stopAsync();
    started.countDown();
    service.awaitTerminated();
    assertEquals(Service.State.TERMINATED, service.state());
    assertEquals(1, service.startupCalled);
    assertEquals(0, service.runCalled);
    assertEquals(1, service.shutdownCalled);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: startUp=1 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceStopIdempotence
 Body: {
    WaitOnRunService service = new WaitOnRunService();

    service.startAsync().awaitRunning();
    enterRun.await(); // to avoid stopping the service until run() is invoked

    service.stopAsync();
    service.stopAsync();
    service.stopAsync().awaitTerminated();
    assertEquals(Service.State.TERMINATED, service.state());
    service.stopAsync().awaitTerminated();
    assertEquals(Service.State.TERMINATED, service.state());

    executionThread.join();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: stopAsync=4 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testServiceThrowOnShutDown
 Body: {
    ThrowOnShutDown service = new ThrowOnShutDown();

    service.startAsync().awaitRunning();
    assertEquals(Service.State.RUNNING, service.state());

    service.stopAsync();
    enterRun.countDown();
    executionThread.join();

    assertEquals(Service.State.FAILED, service.state());
    assertThat(service.failureCause()).hasMessage("kaboom!");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractExecutionThreadServiceTest
 Method: testStop_noStart
 Body: {
    FakeService service = new FakeService();
    service.stopAsync().awaitTerminated();
    assertEquals(Service.State.TERMINATED, service.state());
    assertEquals(0, service.startupCalled);
    assertEquals(0, service.runCalled);
    assertEquals(0, service.shutdownCalled);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitTerminated (Alternative Action: awaitTerminated=1 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: ConverterTest
 Method: testReverse
 Body: {
    Converter<Long, String> reverseConverter = STR_TO_LONG.reverse();

    assertEquals(STR_VAL, reverseConverter.convert(LONG_VAL));
    assertEquals(LONG_VAL, reverseConverter.reverse().convert(STR_VAL));

    Iterable<String> convertedValues = reverseConverter.convertAll(LONGS);
    assertEquals(STRINGS, ImmutableList.copyOf(convertedValues));

    assertSame(STR_TO_LONG, reverseConverter.reverse());

    assertEquals("string2long.reverse()", reverseConverter.toString());

    new EqualsTester()
        .addEqualityGroup(STR_TO_LONG, STR_TO_LONG.reverse().reverse())
        .addEqualityGroup(STR_TO_LONG.reverse(), STR_TO_LONG.reverse())
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: reverse=7 ) - Predicate: convert - Scenario: reverseConverter (Alternative Scenario: convertedValues=1 )

Project: guava
 Class: ConverterTest
 Method: testConvertAllIsView
 Body: {
    List<String> mutableList = Lists.newArrayList("789", "123");
    Iterable<Long> convertedValues = STR_TO_LONG.convertAll(mutableList);
    assertEquals(ImmutableList.of(789L, 123L), ImmutableList.copyOf(convertedValues));

    Iterator<Long> iterator = convertedValues.iterator();
    iterator.next();
    iterator.remove();
    assertEquals(ImmutableList.of("123"), mutableList);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: of=2 ) - Predicate: of - Scenario: mutableList (Alternative Scenario: convertedValues=1 )

Project: guava
 Class: LocalLoadingCacheTest
 Method: testRecordStats
 Body: {
    CacheBuilder<Object, Object> builder =
        createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);
    LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
    assertEquals(0, cache.stats().hitCount());
    assertEquals(0, cache.stats().missCount());

    Object one = new Object();
    cache.getUnchecked(one);
    assertEquals(0, cache.stats().hitCount());
    assertEquals(1, cache.stats().missCount());

    cache.getUnchecked(one);
    assertEquals(1, cache.stats().hitCount());
    assertEquals(1, cache.stats().missCount());

    Object two = new Object();
    cache.getUnchecked(two);
    assertEquals(1, cache.stats().hitCount());
    assertEquals(2, cache.stats().missCount());

    Object three = new Object();
    cache.getUnchecked(three);
    assertEquals(1, cache.stats().hitCount());
    assertEquals(3, cache.stats().missCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: getUnchecked (Alternative Action: stats=10 ) - Predicate: hitCount - Scenario: builder (Alternative Scenario: cache=1 )

Project: guava
 Class: LocalLoadingCacheTest
 Method: testStatsNoops
 Body: {
    CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);
    LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
    ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view
    assertEquals(EMPTY_STATS, cache.stats());

    Object one = new Object();
    assertNull(map.put(one, one));
    assertSame(one, map.get(one));
    assertTrue(map.containsKey(one));
    assertTrue(map.containsValue(one));
    Object two = new Object();
    assertSame(one, map.replace(one, two));
    assertTrue(map.containsKey(one));
    assertFalse(map.containsValue(one));
    Object three = new Object();
    assertTrue(map.replace(one, two, three));
    assertTrue(map.remove(one, three));
    assertFalse(map.containsKey(one));
    assertFalse(map.containsValue(one));
    assertNull(map.putIfAbsent(two, three));
    assertSame(three, map.remove(two));
    assertNull(map.put(three, one));
    assertNull(map.put(one, two));

    assertThat(map).containsEntry(three, one);
    assertThat(map).containsEntry(one, two);

    // TODO(cgruber): Confirm with fry@ that this is a reasonable substitute.
    // Set<Entry<Object, Object>> entries = map.entrySet();
    // assertThat(entries).containsExactly(
    //    Maps.immutableEntry(three, one), Maps.immutableEntry(one, two));
    // Set<Object> keys = map.keySet();
    // assertThat(keys).containsExactly(one, three);
    // Collection<Object> values = map.values();
    // assertThat(values).containsExactly(one, two);

    map.clear();

    assertEquals(EMPTY_STATS, cache.stats());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: containsKey=3 ) - Predicate: stats - Scenario: builder (Alternative Scenario: cache=1 )

Project: guava
 Class: LocalLoadingCacheTest
 Method: testNoStats
 Body: {
    CacheBuilder<Object, Object> builder =
        CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);
    LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
    assertEquals(EMPTY_STATS, cache.stats());

    Object one = new Object();
    cache.getUnchecked(one);
    assertEquals(EMPTY_STATS, cache.stats());

    cache.getUnchecked(one);
    assertEquals(EMPTY_STATS, cache.stats());

    Object two = new Object();
    cache.getUnchecked(two);
    assertEquals(EMPTY_STATS, cache.stats());

    Object three = new Object();
    cache.getUnchecked(three);
    assertEquals(EMPTY_STATS, cache.stats());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: getUnchecked (Alternative Action: stats=5 ) - Predicate: stats - Scenario: builder (Alternative Scenario: cache=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testServiceStartStop
 Body: {
    Service a = new NoOpService();
    Service b = new NoOpService();
    ServiceManager manager = new ServiceManager(asList(a, b));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);
    assertState(manager, Service.State.NEW, a, b);
    assertFalse(manager.isHealthy());
    manager.startAsync().awaitHealthy();
    assertState(manager, Service.State.RUNNING, a, b);
    assertTrue(manager.isHealthy());
    assertTrue(listener.healthyCalled);
    assertFalse(listener.stoppedCalled);
    assertTrue(listener.failedServices.isEmpty());
    manager.stopAsync().awaitStopped();
    assertState(manager, Service.State.TERMINATED, a, b);
    assertFalse(manager.isHealthy());
    assertTrue(listener.stoppedCalled);
    assertTrue(listener.failedServices.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: isHealthy=3 ) - Predicate: N/A - Scenario: listener (Alternative Scenario: a=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testDoCancelStart
 Body: {
    Service a =
        new AbstractService() {
          @Override
          protected void doStart() {
            // Never starts!
          }

          @Override
          protected void doCancelStart() {
            assertThat(state()).isEqualTo(Service.State.STOPPING);
            notifyStopped();
          }

          @Override
          protected void doStop() {
            throw new AssertionError(); // Should not be called.
          }
        };

    final ServiceManager manager = new ServiceManager(asList(a));
    manager.startAsync();
    manager.stopAsync();
    manager.awaitStopped(10, TimeUnit.MILLISECONDS);
    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.TERMINATED);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: awaitStopped=1 ) - Predicate: N/A - Scenario: manager (Alternative Scenario: a=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testListenerDeadlock
 Body: {
    final CountDownLatch failEnter = new CountDownLatch(1);
    final CountDownLatch failLeave = new CountDownLatch(1);
    final CountDownLatch afterStarted = new CountDownLatch(1);
    Service failRunService =
        new AbstractService() {
          @Override
          protected void doStart() {
            new Thread() {
              @Override
              public void run() {
                notifyStarted();
                // We need to wait for the main thread to leave the ServiceManager.startAsync call
                // to
                // ensure that the thread running the failure callbacks is not the main thread.
                Uninterruptibles.awaitUninterruptibly(afterStarted);
                notifyFailed(new Exception("boom"));
              }
            }.start();
          }

          @Override
          protected void doStop() {
            notifyStopped();
          }
        };
    final ServiceManager manager =
        new ServiceManager(Arrays.asList(failRunService, new NoOpService()));
    manager.addListener(
        new ServiceManager.Listener() {
          @Override
          public void failure(Service service) {
            failEnter.countDown();
            // block until after the service manager is shutdown
            Uninterruptibles.awaitUninterruptibly(failLeave);
          }
        });
    manager.startAsync();
    afterStarted.countDown();
    // We do not call awaitHealthy because, due to races, that method may throw an exception.  But
    // we really just want to wait for the thread to be in the failure callback so we wait for that
    // explicitly instead.
    failEnter.await();
    assertFalse("State should be updated before calling listeners", manager.isHealthy());
    // now we want to stop the services.
    Thread stoppingThread =
        new Thread() {
          @Override
          public void run() {
            manager.stopAsync().awaitStopped();
          }
        };
    stoppingThread.start();
    // this should be super fast since the only non stopped service is a NoOpService
    stoppingThread.join(1000);
    assertFalse("stopAsync has deadlocked!.", stoppingThread.isAlive());
    failLeave.countDown(); // release the background thread
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: countDown=3 ) - Predicate: isHealthy - Scenario: manager (Alternative Scenario: manager=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testNotifyStoppedAfterFailure
 Body: {
    Service a =
        new AbstractService() {
          @Override
          protected void doStart() {
            notifyFailed(new IllegalStateException("start failure"));
            notifyStopped(); // This will be a no-op.
          }

          @Override
          protected void doStop() {
            notifyStopped();
          }
        };
    final ServiceManager manager = new ServiceManager(asList(a));
    manager.startAsync();
    manager.awaitStopped(10, TimeUnit.MILLISECONDS);
    assertThat(manager.servicesByState().keySet()).containsExactly(Service.State.FAILED);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: notifyStopped=2 ) - Predicate: N/A - Scenario: manager (Alternative Scenario: a=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testServiceStartupTimes
 Body: {
    Service a = new NoOpDelayedService(150);
    Service b = new NoOpDelayedService(353);
    ServiceManager serviceManager = new ServiceManager(asList(a, b));
    serviceManager.startAsync().awaitHealthy();
    ImmutableMap<Service, Long> startupTimes = serviceManager.startupTimes();
    assertEquals(2, startupTimes.size());
    // TODO(kak): Use assertThat(startupTimes.get(a)).isAtLeast(150);
    assertTrue(startupTimes.get(a) >= 150);
    // TODO(kak): Use assertThat(startupTimes.get(b)).isAtLeast(353);
    assertTrue(startupTimes.get(b) >= 353);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitHealthy (Alternative Action: get=2 ) - Predicate: size - Scenario: startupTimes (Alternative Scenario: a=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testServiceStartupTimes_selfStartingServices
 Body: {
    // This tests to ensure that:
    // 1. service times are accurate when the service is started by the manager
    // 2. service times are recorded when the service is not started by the manager (but they may
    // not be accurate).
    final Service b =
        new NoOpDelayedService(353) {
          @Override
          protected void doStart() {
            super.doStart();
            // This will delay service listener execution at least 150 milliseconds
            Uninterruptibles.sleepUninterruptibly(150, TimeUnit.MILLISECONDS);
          }
        };
    Service a =
        new NoOpDelayedService(150) {
          @Override
          protected void doStart() {
            b.startAsync();
            super.doStart();
          }
        };
    ServiceManager serviceManager = new ServiceManager(asList(a, b));
    serviceManager.startAsync().awaitHealthy();
    ImmutableMap<Service, Long> startupTimes = serviceManager.startupTimes();
    assertEquals(2, startupTimes.size());
    // TODO(kak): Use assertThat(startupTimes.get(a)).isAtLeast(150);
    assertTrue(startupTimes.get(a) >= 150);
    // Service b startup takes at least 353 millis, but starting the timer is delayed by at least
    // 150 milliseconds. so in a perfect world the timing would be 353-150=203ms, but since either
    // of our sleep calls can be arbitrarily delayed we should just assert that there is a time
    // recorded.
    assertThat(startupTimes.get(b)).isNotNull();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitHealthy (Alternative Action: get=2 ) - Predicate: size - Scenario: startupTimes (Alternative Scenario: a=1 )

Project: guava
 Class: ServiceManagerTest
 Method: testFailStop
 Body: {
    Service a = new NoOpService();
    Service b = new FailStopService();
    Service c = new NoOpService();
    ServiceManager manager = new ServiceManager(asList(a, b, c));
    RecordingListener listener = new RecordingListener();
    manager.addListener(listener);

    manager.startAsync().awaitHealthy();
    assertTrue(listener.healthyCalled);
    assertFalse(listener.stoppedCalled);
    manager.stopAsync().awaitStopped();

    assertTrue(listener.stoppedCalled);
    assertEquals(ImmutableSet.of(b), listener.failedServices);
    assertState(manager, Service.State.FAILED, b);
    assertState(manager, Service.State.TERMINATED, a, c);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: awaitStopped=1 ) - Predicate: N/A - Scenario: listener (Alternative Scenario: a=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testInvalidateAll
 Body: {
    Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();

    cache.put(654, 2675);
    cache.put(2456, 56);
    cache.put(2, 15);

    cache.invalidateAll();
    assertFalse(cache.asMap().containsKey(654));
    assertFalse(cache.asMap().containsKey(2456));
    assertFalse(cache.asMap().containsKey(2));

    cache.put(654, 2675);
    cache.put(2456, 56);
    cache.put(2, 15);
    cache.put(1, 3);

    cache.invalidateAll(ImmutableSet.of(1, 2));

    assertFalse(cache.asMap().containsKey(1));
    assertFalse(cache.asMap().containsKey(2));
    assertTrue(cache.asMap().containsKey(654));
    assertTrue(cache.asMap().containsKey(2456));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: asMap=7 ) - Predicate: containsKey - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testRemovalListener
 Body: {
    final int[] stats = new int[4];

    RemovalListener<Integer, Integer> countingListener =
        new RemovalListener<Integer, Integer>() {
          @Override
          public void onRemoval(RemovalNotification<Integer, Integer> notification) {
            switch (notification.getCause()) {
              case EXPIRED:
                stats[0]++;
                break;
              case EXPLICIT:
                stats[1]++;
                break;
              case REPLACED:
                stats[2]++;
                break;
              case SIZE:
                stats[3]++;
                break;
              default:
                throw new IllegalStateException("No collected exceptions in GWT CacheBuilder.");
            }
          }
        };

    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .removalListener(countingListener)
            .ticker(fakeTicker)
            .maximumSize(2)
            .build();

    // Add more than two elements to increment size removals.
    cache.put(3, 20);
    cache.put(6, 2);
    cache.put(98, 45);
    cache.put(56, 76);
    cache.put(23, 84);

    // Replace the two present elements.
    cache.put(23, 20);
    cache.put(56, 49);
    cache.put(23, 2);
    cache.put(56, 4);

    // Expire the two present elements.
    fakeTicker.advance(1001, TimeUnit.MILLISECONDS);

    cache.getIfPresent(23);
    cache.getIfPresent(56);

    // Add two elements and invalidate them.
    cache.put(1, 4);
    cache.put(2, 8);

    cache.invalidateAll();

    assertEquals(2, stats[0]);
    assertEquals(2, stats[1]);
    assertEquals(4, stats[2]);
    assertEquals(3, stats[3]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=11 ) - Predicate: N/A - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testLoader
 Body: {

    final Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();

    Callable<Integer> loader =
        new Callable<Integer>() {
          private int i = 0;

          @Override
          public Integer call() throws Exception {
            return ++i;
          }
        };

    cache.put(0, 10);

    assertEquals(Integer.valueOf(10), cache.get(0, loader));
    assertEquals(Integer.valueOf(1), cache.get(20, loader));
    assertEquals(Integer.valueOf(2), cache.get(34, loader));

    cache.invalidate(0);
    assertEquals(Integer.valueOf(3), cache.get(0, loader));

    cache.put(0, 10);
    cache.invalidateAll();
    assertEquals(Integer.valueOf(4), cache.get(0, loader));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: valueOf=5 ) - Predicate: valueOf - Scenario: loader (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMapValues_contains
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 20);
    fakeTicker.advance(500, TimeUnit.MILLISECONDS);
    cache.put(20, 22);
    cache.put(5, 10);

    fakeTicker.advance(501, TimeUnit.MILLISECONDS);

    assertTrue(cache.asMap().values().contains(22));
    assertTrue(cache.asMap().values().contains(10));
    assertFalse(cache.asMap().values().contains(20));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=3 ) - Predicate: contains - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testMapMethods
 Body: {
    Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();

    ConcurrentMap<Integer, Integer> asMap = cache.asMap();

    cache.put(10, 100);
    cache.put(2, 52);

    asMap.replace(2, 79);
    asMap.replace(3, 60);

    assertEquals(null, cache.getIfPresent(3));
    assertEquals(null, asMap.get(3));

    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
    assertEquals(Integer.valueOf(79), asMap.get(2));

    asMap.replace(10, 100, 50);
    asMap.replace(2, 52, 99);

    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(50), asMap.get(10));
    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
    assertEquals(Integer.valueOf(79), asMap.get(2));

    asMap.remove(10, 100);
    asMap.remove(2, 79);

    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(50), asMap.get(10));
    assertEquals(null, cache.getIfPresent(2));
    assertEquals(null, asMap.get(2));

    asMap.putIfAbsent(2, 20);
    asMap.putIfAbsent(10, 20);

    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
    assertEquals(Integer.valueOf(20), asMap.get(2));
    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(50), asMap.get(10));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: valueOf=12 ) - Predicate: getIfPresent - Scenario: asMap (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testLoadingCache
 Body: {
    CacheLoader<Integer, Integer> loader =
        new CacheLoader<Integer, Integer>() {
          int i = 0;

          @Override
          public Integer load(Integer key) throws Exception {
            return i++;
          }
        };

    LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().build(loader);

    cache.put(10, 20);

    Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));

    assertEquals(Integer.valueOf(20), map.get(10));
    assertEquals(Integer.valueOf(0), map.get(20));
    assertEquals(Integer.valueOf(1), map.get(30));
    assertEquals(Integer.valueOf(2), map.get(54));
    assertEquals(Integer.valueOf(3), map.get(443));
    assertEquals(Integer.valueOf(4), map.get(1));
    assertEquals(Integer.valueOf(5), cache.get(6));
    assertEquals(Integer.valueOf(6), cache.apply(7));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: valueOf=8 ) - Predicate: valueOf - Scenario: map (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMap_containsKey
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(20000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(654, 2675);
    fakeTicker.advance(10000, TimeUnit.MILLISECONDS);
    cache.put(2456, 56);
    cache.put(2, 15);

    fakeTicker.advance(10001, TimeUnit.MILLISECONDS);

    assertTrue(cache.asMap().containsKey(2));
    assertTrue(cache.asMap().containsKey(2456));
    assertFalse(cache.asMap().containsKey(654));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: asMap=3 ) - Predicate: containsKey - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMapKeySet_contains
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 20);
    fakeTicker.advance(500, TimeUnit.MILLISECONDS);
    cache.put(20, 22);
    cache.put(5, 10);

    fakeTicker.advance(501, TimeUnit.MILLISECONDS);

    assertTrue(cache.asMap().keySet().contains(20));
    assertTrue(cache.asMap().keySet().contains(5));
    assertFalse(cache.asMap().keySet().contains(10));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=3 ) - Predicate: contains - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testSizeConstraint
 Body: {
    final Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();

    cache.put(1, 10);
    cache.put(2, 20);
    cache.put(3, 30);
    cache.put(4, 40);
    cache.put(5, 50);

    assertEquals(null, cache.getIfPresent(10));
    // Order required to remove dependence on access order / write order constraint.
    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));

    cache.put(1, 10);
    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));
    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));
    assertEquals(null, cache.getIfPresent(2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getIfPresent=10 ) - Predicate: getIfPresent - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMapKeySet
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 20);
    fakeTicker.advance(500, TimeUnit.MILLISECONDS);
    cache.put(20, 22);
    cache.put(5, 10);

    fakeTicker.advance(501, TimeUnit.MILLISECONDS);

    Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());

    assertEquals(ImmutableSet.of(20, 5), foundKeys);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: advance (Alternative Action: put=3 ) - Predicate: of - Scenario: foundKeys (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testExpireAfterWrite
 Body: {
    final Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 100);
    cache.put(20, 200);
    cache.put(4, 2);

    fakeTicker.advance(999, TimeUnit.MILLISECONDS);
    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));

    fakeTicker.advance(2, TimeUnit.MILLISECONDS);
    assertEquals(null, cache.getIfPresent(10));
    assertEquals(null, cache.getIfPresent(20));
    assertEquals(null, cache.getIfPresent(4));

    cache.put(10, 20);
    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));

    fakeTicker.advance(1000, TimeUnit.MILLISECONDS);
    assertEquals(null, cache.getIfPresent(10));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getIfPresent=8 ) - Predicate: valueOf - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testExpireAfterWriteAndAccess
 Body: {
    final Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .expireAfterAccess(500, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 100);
    cache.put(20, 200);
    cache.put(4, 2);

    fakeTicker.advance(499, TimeUnit.MILLISECONDS);
    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));

    fakeTicker.advance(2, TimeUnit.MILLISECONDS);
    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
    assertEquals(null, cache.getIfPresent(4));

    fakeTicker.advance(499, TimeUnit.MILLISECONDS);
    assertEquals(null, cache.getIfPresent(10));
    assertEquals(null, cache.getIfPresent(20));

    cache.put(10, 20);
    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));

    fakeTicker.advance(500, TimeUnit.MILLISECONDS);
    assertEquals(null, cache.getIfPresent(10));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getIfPresent=9 ) - Predicate: valueOf - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMap_containsValue
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(20000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(654, 2675);
    fakeTicker.advance(10000, TimeUnit.MILLISECONDS);
    cache.put(2456, 56);
    cache.put(2, 15);

    fakeTicker.advance(10001, TimeUnit.MILLISECONDS);

    assertTrue(cache.asMap().containsValue(15));
    assertTrue(cache.asMap().containsValue(56));
    assertFalse(cache.asMap().containsValue(2675));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: asMap=3 ) - Predicate: containsValue - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testAsMapValues_iteratorRemove
 Body: {
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(10, 20);
    Iterator<Integer> iterator = cache.asMap().values().iterator();
    iterator.next();
    iterator.remove();

    assertEquals(0, cache.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: next=1 ) - Predicate: size - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testExpireAfterAccess
 Body: {
    final Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterAccess(1000, TimeUnit.MILLISECONDS)
            .ticker(fakeTicker)
            .build();

    cache.put(0, 10);
    cache.put(2, 30);

    fakeTicker.advance(999, TimeUnit.MILLISECONDS);
    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
    fakeTicker.advance(1, TimeUnit.MILLISECONDS);
    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
    fakeTicker.advance(1000, TimeUnit.MILLISECONDS);
    assertEquals(null, cache.getIfPresent(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getIfPresent=3 ) - Predicate: valueOf - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testInvalidate
 Body: {
    Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();

    cache.put(654, 2675);
    cache.put(2456, 56);
    cache.put(2, 15);

    cache.invalidate(654);

    assertFalse(cache.asMap().containsKey(654));
    assertTrue(cache.asMap().containsKey(2456));
    assertTrue(cache.asMap().containsKey(2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: asMap=3 ) - Predicate: containsKey - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheBuilderGwtTest
 Method: testPutAll
 Body: {
    Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();

    cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));

    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));
    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));

    cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));

    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));
    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));
    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: valueOf=7 ) - Predicate: valueOf - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: TestLogHandlerTest
 Method: test
 Body: {
    assertTrue(handler.getStoredLogRecords().isEmpty());
    ExampleClassUnderTest.foo();
    LogRecord record = handler.getStoredLogRecords().get(0);
    assertEquals(Level.INFO, record.getLevel());
    assertEquals("message", record.getMessage());
    assertSame(EXCEPTION, record.getThrown());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: foo (Alternative Action: getStoredLogRecords=2 ) - Predicate: isEmpty - Scenario: record (Alternative Scenario: record=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveMiddle
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.atMost(6));
    rangeSet.remove(Range.closedOpen(3, 4));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges())
        .containsExactly(Range.lessThan(3), Range.closed(4, 6))
        .inOrder();
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.closedOpen(3, 4), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closedOpen=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testExtendBothDirections
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 4));
    rangeSet.add(Range.closed(1, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveAllExtendingBothDirections
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(2, 7));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveEmpty
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 6));
    rangeSet.remove(Range.closedOpen(3, 3));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testIgnoresSmallerSharingNoBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 6));
    rangeSet.add(Range.open(2, 4));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testMergesConnectedWithOverlap
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 4));
    rangeSet.add(Range.open(2, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closedOpen(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.atLeast(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testAddEmpty
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closedOpen(3, 3));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).isEmpty();
    assertThat(rangeSet.complement().asRanges()).containsExactly(Range.<Integer>all());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: asRanges=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRangeContaining2
 Body: {
    RangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 10));
    rangeSet.remove(Range.open(5, 7));
    assertEquals(Range.closed(3, 5), rangeSet.rangeContaining(5));
    assertTrue(rangeSet.contains(5));
    assertEquals(Range.closed(7, 10), rangeSet.rangeContaining(8));
    assertTrue(rangeSet.contains(8));
    assertNull(rangeSet.rangeContaining(6));
    assertFalse(rangeSet.contains(6));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: contains=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testIgnoresEqual
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 6));
    rangeSet.add(Range.closed(1, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveExact
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(3, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveAllFromAboveUpperBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(3, 7));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testIgnoresSmallerSharingLowerBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 6));
    rangeSet.add(Range.closed(1, 4));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testExtendSameLowerBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 4));
    rangeSet.add(Range.closed(1, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveAll
 Body: {
    RangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 10));
    rangeSet.removeAll(Arrays.asList(Range.open(1, 3), Range.closed(5, 8), Range.closed(9, 11)));
    assertThat(rangeSet.asRanges())
        .containsExactly(Range.closedOpen(3, 5), Range.open(8, 9))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemovePartFromAboveUpperBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(6, 9));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).containsExactly(Range.closedOpen(3, 6));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemovePartSharingLowerBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 5));
    rangeSet.remove(Range.closedOpen(3, 5));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.singleton(5));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(5), Range.greaterThan(5))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: asRanges=2 ) - Predicate: singleton - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testAddAll
 Body: {
    RangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 10));
    rangeSet.addAll(Arrays.asList(Range.open(1, 3), Range.closed(5, 8), Range.closed(9, 11)));
    assertThat(rangeSet.asRanges()).containsExactly(Range.openClosed(1, 11)).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testFillHoleExactly
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closedOpen(1, 3));
    rangeSet.add(Range.closedOpen(4, 6));
    rangeSet.add(Range.closedOpen(3, 4));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closedOpen(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.atLeast(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closedOpen=4 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveAllFromBelowLowerBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(2, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testMergesConnectedDisjoint
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 4));
    rangeSet.add(Range.open(4, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closedOpen(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.atLeast(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRangeContaining1
 Body: {
    RangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 10));
    assertEquals(Range.closed(3, 10), rangeSet.rangeContaining(5));
    assertTrue(rangeSet.contains(5));
    assertNull(rangeSet.rangeContaining(1));
    assertFalse(rangeSet.contains(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: contains=2 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testIgnoresSmallerSharingUpperBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 6));
    rangeSet.add(Range.closed(3, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemoveNoOverlap
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closedOpen(1, 3));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).containsExactly(Range.closed(3, 6));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testExtendSameUpperBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.add(Range.closed(1, 6));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closed(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.greaterThan(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=3 ) - Predicate: closed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemovePartFromBelowLowerBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 6));
    rangeSet.remove(Range.closed(1, 3));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).containsExactly(Range.openClosed(3, 6));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closed=2 ) - Predicate: openClosed - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testSerialization
 Body: {
    RangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 10));
    rangeSet.remove(Range.open(5, 7));
    SerializableTester.reserializeAndAssert(rangeSet);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: N/A - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testFillHoleWithOverlap
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closedOpen(1, 3));
    rangeSet.add(Range.closedOpen(4, 6));
    rangeSet.add(Range.closedOpen(2, 5));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.closedOpen(1, 6));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(1), Range.atLeast(6))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closedOpen=4 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: TreeRangeSetTest
 Method: testRemovePartSharingUpperBound
 Body: {
    TreeRangeSet<Integer> rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(3, 5));
    rangeSet.remove(Range.openClosed(3, 5));
    testInvariants(rangeSet);
    assertThat(rangeSet.asRanges()).contains(Range.singleton(3));
    assertThat(rangeSet.complement().asRanges())
        .containsExactly(Range.lessThan(3), Range.greaterThan(3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: asRanges=2 ) - Predicate: singleton - Scenario: rangeSet (Alternative Scenario: rangeSet=1 )

Project: guava
 Class: MultimapRemoveAllTester
 Method: testRemoveAllPropagatesToGet
 Body: {
    Collection<V> getResult = multimap().get(k0());

    multimap().removeAll(k0());

    assertEmpty(getResult);
    expectMissing(e0());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: removeAll (Alternative Action: k0=2 ) - Predicate: N/A - Scenario: getResult (Alternative Scenario: getResult=1 )

Project: guava
 Class: FilesTest
 Method: testCopyFile
 Body: {
    File i18nFile = getTestFile("i18n.txt");
    File temp = createTempFile();
    Files.copy(i18nFile, temp);
    assertEquals(I18N, Files.toString(temp, Charsets.UTF_8));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: toString=1 ) - Predicate: toString - Scenario: temp (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testAppendString
 Body: {
    File temp = createTempFile();
    Files.append(I18N, temp, Charsets.UTF_16LE);
    assertEquals(I18N, Files.toString(temp, Charsets.UTF_16LE));
    Files.append(I18N, temp, Charsets.UTF_16LE);
    assertEquals(I18N + I18N, Files.toString(temp, Charsets.UTF_16LE));
    Files.append(I18N, temp, Charsets.UTF_16LE);
    assertEquals(I18N + I18N + I18N, Files.toString(temp, Charsets.UTF_16LE));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: append (Alternative Action: toString=3 ) - Predicate: toString - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: FilesTest
 Method: testCopyIdenticalFiles
 Body: {
    File temp1 = createTempFile();
    Files.write(ASCII, temp1, Charsets.UTF_8);
    File temp2 = createTempFile();
    Files.write(ASCII, temp2, Charsets.UTF_8);
    Files.copy(temp1, temp2);
    assertEquals(ASCII, Files.toString(temp1, Charsets.UTF_8));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: createTempFile=2 ) - Predicate: toString - Scenario: temp2 (Alternative Scenario: temp2=1 )

Project: guava
 Class: FilesTest
 Method: testCreateParentDirs_multipleParentsNeeded
 Body: {
    File file = file(getTempDir(), "grandparent", "parent", "nonexistent.file");
    File parent = file.getParentFile();
    File grandparent = parent.getParentFile();
    assertFalse(grandparent.exists());
    Files.createParentDirs(file);
    assertTrue(parent.exists());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirs (Alternative Action: getParentFile=2 ) - Predicate: exists - Scenario: file (Alternative Scenario: parent=1 )

Project: guava
 Class: FilesTest
 Method: testEqual
 Body: {
    File asciiFile = getTestFile("ascii.txt");
    File i18nFile = getTestFile("i18n.txt");
    assertFalse(Files.equal(asciiFile, i18nFile));
    assertTrue(Files.equal(asciiFile, asciiFile));

    File temp = createTempFile();
    Files.copy(asciiFile, temp);
    assertTrue(Files.equal(asciiFile, temp));

    Files.copy(i18nFile, temp);
    assertTrue(Files.equal(i18nFile, temp));

    Files.copy(asciiFile, temp);
    RandomAccessFile rf = new RandomAccessFile(temp, "rw");
    rf.writeByte(0);
    rf.close();
    assertEquals(asciiFile.length(), temp.length());
    assertFalse(Files.equal(asciiFile, temp));

    assertTrue(Files.asByteSource(asciiFile).contentEquals(Files.asByteSource(asciiFile)));

    // 0-length files have special treatment (/proc, etc.)
    assertTrue(Files.equal(asciiFile, new BadLengthFile(asciiFile, 0)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: equal=6 ) - Predicate: equal - Scenario: asciiFile (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testMap_readWrite_creates
 Body: {
    // Test data
    int size = 1024;
    byte[] expectedBytes = newPreFilledByteArray(1024);

    // Setup
    File file = createTempFile();
    boolean deleted = file.delete();
    assertTrue(deleted);
    assertFalse(file.exists());

    // Test
    MappedByteBuffer map = Files.map(file, MapMode.READ_WRITE, size);
    map.put(expectedBytes);

    // Verify
    assertTrue(file.exists());
    assertTrue(file.isFile());
    assertEquals(size, file.length());
    byte[] actualBytes = Files.toByteArray(file);
    assertTrue(Arrays.equals(expectedBytes, actualBytes));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: exists=2 ) - Predicate: N/A - Scenario: size (Alternative Scenario: actualBytes=1 )

Project: guava
 Class: FilesTest
 Method: testTouchTime
 Body: {
    File temp = createTempFile();
    assertTrue(temp.exists());
    temp.setLastModified(0);
    assertEquals(0, temp.lastModified());
    Files.touch(temp);
    assertThat(temp.lastModified()).isNotEqualTo(0);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setLastModified (Alternative Action: lastModified=2 ) - Predicate: exists - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: FilesTest
 Method: testMove
 Body: {
    File i18nFile = getTestFile("i18n.txt");
    File temp1 = createTempFile();
    File temp2 = createTempFile();

    Files.copy(i18nFile, temp1);
    moveHelper(true, temp1, temp2);
    assertTrue(Files.equal(temp2, i18nFile));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: createTempFile=2 ) - Predicate: equal - Scenario: temp2 (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testCreateParentDirs_root
 Body: {
    File file = root();
    assertNull(file.getParentFile());
    assertNull(file.getCanonicalFile().getParentFile());
    Files.createParentDirs(file);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirs (Alternative Action: getParentFile=2 ) - Predicate: getParentFile - Scenario: file (Alternative Scenario: file=1 )

Project: guava
 Class: FilesTest
 Method: testCopyToAppendable
 Body: {
    File i18nFile = getTestFile("i18n.txt");
    StringBuilder sb = new StringBuilder();
    Files.copy(i18nFile, Charsets.UTF_8, sb);
    assertEquals(I18N, sb.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: toString=1 ) - Predicate: toString - Scenario: sb (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testMoveViaCopy
 Body: {
    File i18nFile = getTestFile("i18n.txt");
    File temp1 = createTempFile();
    File temp2 = createTempFile();

    Files.copy(i18nFile, temp1);
    moveHelper(true, new UnmovableFile(temp1, false, true), temp2);
    assertTrue(Files.equal(temp2, i18nFile));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: createTempFile=2 ) - Predicate: equal - Scenario: temp2 (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testMap
 Body: {
    // Test data
    int size = 1024;
    byte[] bytes = newPreFilledByteArray(size);

    // Setup
    File file = createTempFile();
    Files.write(bytes, file);

    // Test
    MappedByteBuffer actual = Files.map(file);

    // Verify
    ByteBuffer expected = ByteBuffer.wrap(bytes);
    assertTrue("ByteBuffers should be equal.", expected.equals(actual));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: equals=1 ) - Predicate: equals - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: FilesTest
 Method: testReadLines_withLineProcessor
 Body: {
    File temp = createTempFile();
    LineProcessor<List<String>> collect =
        new LineProcessor<List<String>>() {
          List<String> collector = new ArrayList<>();

          @Override
          public boolean processLine(String line) {
            collector.add(line);
            return true;
          }

          @Override
          public List<String> getResult() {
            return collector;
          }
        };
    assertThat(Files.readLines(temp, Charsets.UTF_8, collect)).isEmpty();

    PrintWriter w = new PrintWriter(Files.newWriter(temp, Charsets.UTF_8));
    w.println("hello");
    w.println("");
    w.println(" world  ");
    w.println("");
    w.close();
    Files.readLines(temp, Charsets.UTF_8, collect);
    assertThat(collect.getResult()).containsExactly("hello", "", " world  ", "").inOrder();

    LineProcessor<List<String>> collectNonEmptyLines =
        new LineProcessor<List<String>>() {
          List<String> collector = new ArrayList<>();

          @Override
          public boolean processLine(String line) {
            if (line.length() > 0) {
              collector.add(line);
            }
            return true;
          }

          @Override
          public List<String> getResult() {
            return collector;
          }
        };
    Files.readLines(temp, Charsets.UTF_8, collectNonEmptyLines);
    assertThat(collectNonEmptyLines.getResult()).containsExactly("hello", " world  ").inOrder();

    assertTrue(temp.delete());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: println (Alternative Action: println=4 ) - Predicate: N/A - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: FilesTest
 Method: testCopyToOutputStream
 Body: {
    File i18nFile = getTestFile("i18n.txt");
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    Files.copy(i18nFile, out);
    assertEquals(I18N, out.toString("UTF-8"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: toString=1 ) - Predicate: toString - Scenario: out (Alternative Scenario: i18nFile=1 )

Project: guava
 Class: FilesTest
 Method: testMap_readWrite
 Body: {
    // Test data
    int size = 1024;
    byte[] expectedBytes = new byte[size];
    byte[] bytes = newPreFilledByteArray(1024);

    // Setup
    File file = createTempFile();
    Files.write(bytes, file);

    Random random = new Random();
    random.nextBytes(expectedBytes);

    // Test
    MappedByteBuffer map = Files.map(file, MapMode.READ_WRITE);
    map.put(expectedBytes);

    // Verify
    byte[] actualBytes = Files.toByteArray(file);
    assertTrue(Arrays.equals(expectedBytes, actualBytes));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: equals=1 ) - Predicate: equals - Scenario: actualBytes (Alternative Scenario: actualBytes=1 )

Project: guava
 Class: FilesTest
 Method: testCreateParentDirs_relativePath
 Body: {
    File file = file("nonexistent.file");
    assertNull(file.getParentFile());
    assertNotNull(file.getCanonicalFile().getParentFile());
    Files.createParentDirs(file);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirs (Alternative Action: getParentFile=2 ) - Predicate: getParentFile - Scenario: file (Alternative Scenario: file=1 )

Project: guava
 Class: FilesTest
 Method: testLineReading
 Body: {
    File temp = createTempFile();
    assertNull(Files.readFirstLine(temp, Charsets.UTF_8));
    assertTrue(Files.readLines(temp, Charsets.UTF_8).isEmpty());

    PrintWriter w = new PrintWriter(Files.newWriter(temp, Charsets.UTF_8));
    w.println("hello");
    w.println("");
    w.println(" world  ");
    w.println("");
    w.close();

    assertEquals("hello", Files.readFirstLine(temp, Charsets.UTF_8));
    assertEquals(
        ImmutableList.of("hello", "", " world  ", ""), Files.readLines(temp, Charsets.UTF_8));

    assertTrue(temp.delete());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: println (Alternative Action: println=4 ) - Predicate: readFirstLine - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: SimpleAbstractMultisetTest
 Method: testFastAddAllMultiset
 Body: {
    final AtomicInteger addCalls = new AtomicInteger();
    Multiset<String> multiset =
        new NoRemoveMultiset<String>() {
          @Override
          public int add(String element, int occurrences) {
            addCalls.incrementAndGet();
            return super.add(element, occurrences);
          }
        };
    ImmutableMultiset<String> adds =
        new ImmutableMultiset.Builder<String>().addCopies("x", 10).build();
    multiset.addAll(adds);
    assertEquals(1, addCalls.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: add=1 ) - Predicate: get - Scenario: adds (Alternative Scenario: multiset=1 )

Project: guava
 Class: MultimapReplaceValuesTester
 Method: testReplaceEmptyValues
 Body: {
    int size = multimap().size();
    @SuppressWarnings("unchecked")
    List<V> values = Arrays.asList(v0(), v2(), v3());
    multimap().replaceValues(k3(), values);
    assertGet(k3(), values);
    assertEquals(size + values.size(), multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: replaceValues (Alternative Action: size=3 ) - Predicate: k3 - Scenario: values (Alternative Scenario: size=1 )

Project: guava
 Class: MultimapReplaceValuesTester
 Method: testReplaceValuesPropagatesToGet
 Body: {
    Collection<V> getCollection = multimap().get(k0());
    @SuppressWarnings("unchecked")
    List<V> values = Arrays.asList(v0(), v2(), v3());
    multimap().replaceValues(k0(), values);
    assertContentsAnyOrder(getCollection, v0(), v2(), v3());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: replaceValues (Alternative Action: k0=2 ) - Predicate: v0 - Scenario: values (Alternative Scenario: getCollection=1 )

Project: guava
 Class: MapEqualsTester
 Method: testEquals_otherContainsNullValue
 Body: {
    Collection<Entry<K, V>> entries = getSampleEntries(getNumEntries() - 1);
    entries.add(entry(k3(), null));
    Map<K, V> other = newHashMap(entries);

    assertFalse(
        "Two Maps should not be equal if exactly one of them contains a null value.",
        getMap().equals(other));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: other (Alternative Scenario: other=1 )

Project: guava
 Class: MapEqualsTester
 Method: testEquals_otherContainsNullKey
 Body: {
    Collection<Entry<K, V>> entries = getSampleEntries(getNumEntries() - 1);
    entries.add(entry(null, v3()));
    Map<K, V> other = newHashMap(entries);

    assertFalse(
        "Two Maps should not be equal if exactly one of them contains a null key.",
        getMap().equals(other));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: other (Alternative Scenario: other=1 )

Project: guava
 Class: MapEqualsTester
 Method: testEquals_containingNullValue
 Body: {
    Collection<Entry<K, V>> entries = getSampleEntries(getNumEntries() - 1);
    entries.add(entry(k3(), null));

    resetContainer(getSubjectGenerator().create(entries.toArray()));
    assertTrue(
        "A Map should equal any other Map containing the same entries,"
            + " even if some values are null.",
        getMap().equals(newHashMap(entries)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: entries (Alternative Scenario: entries=1 )

Project: guava
 Class: MapEqualsTester
 Method: testEquals_containingNullKey
 Body: {
    Collection<Entry<K, V>> entries = getSampleEntries(getNumEntries() - 1);
    entries.add(entry(null, v3()));

    resetContainer(getSubjectGenerator().create(entries.toArray()));
    assertTrue(
        "A Map should equal any other Map containing the same entries,"
            + " even if some keys are null.",
        getMap().equals(newHashMap(entries)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: entries (Alternative Scenario: entries=1 )

Project: guava
 Class: ConfigurableDirectedNetworkTest
 Method: addEdge_existingSelfLoopEdgeBetweenSameNodes
 Body: {
    addEdge(N1, N1, E11);
    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
    assertThat(addEdge(N1, N1, E11)).isFalse();
    assertThat(network.edges()).containsExactlyElementsIn(edges);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edges=2 ) - Predicate: N/A - Scenario: edges (Alternative Scenario: edges=1 )

Project: guava
 Class: MapComputeTester
 Method: testCompute_presentNullToPresentNonnull
 Body: {
    initMapWithNullValue();
    V value = getValueForNullKey();
    assertEquals(
        "Map.compute(presentMappedToNull, functionReturningValue) should return new value",
        value,
        getMap()
            .compute(
                getKeyForNullValue(),
                (k, v) -> {
                  assertEquals(getKeyForNullValue(), k);
                  assertNull(v);
                  return value;
                }));
    expectReplacement(entry(getKeyForNullValue(), value));
    assertEquals(getNumElements(), getMap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initMapWithNullValue (Alternative Action: getKeyForNullValue=3 ) - Predicate: compute - Scenario: value (Alternative Scenario: value=1 )

Project: guava
 Class: CompactHashMapTest
 Method: testEntrySetValueAfterRemoved
 Body: {
    CompactHashMap<Integer, String> map = CompactHashMap.create();
    map.put(1, "1");
    Entry<Integer, String> entry = getOnlyElement(map.entrySet());
    map.remove(1);
    entry.setValue("one");
    assertThat(map).containsEntry(1, "one");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: entrySet=1 ) - Predicate: N/A - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: TearDownStackTest
 Method: testMultipleTearDownsHappenInOrder
 Body: {
    final TearDownStack stack = buildTearDownStack();

    final SimpleTearDown tearDownOne = new SimpleTearDown();
    stack.addTearDown(tearDownOne);

    final Callback callback =
        new Callback() {
          @Override
          public void run() {
            assertEquals(
                "tearDownTwo should have been run before tearDownOne", false, tearDownOne.ran);
          }
        };

    final SimpleTearDown tearDownTwo = new SimpleTearDown(callback);
    stack.addTearDown(tearDownTwo);

    assertEquals(false, tearDownOne.ran);
    assertEquals(false, tearDownTwo.ran);

    stack.runTearDown();

    assertEquals("tearDownOne should have run", true, tearDownOne.ran);
    assertEquals("tearDownTwo should have run", true, tearDownTwo.ran);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addTearDown (Alternative Action: addTearDown=2 ) - Predicate: N/A - Scenario: tearDownTwo (Alternative Scenario: tearDownOne=1 )

Project: guava
 Class: TearDownStackTest
 Method: testSingleTearDown
 Body: {
    final TearDownStack stack = buildTearDownStack();

    final SimpleTearDown tearDown = new SimpleTearDown();
    stack.addTearDown(tearDown);

    assertEquals(false, tearDown.ran);

    stack.runTearDown();

    assertEquals("tearDown should have run", true, tearDown.ran);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addTearDown (Alternative Action: buildTearDownStack=1 ) - Predicate: N/A - Scenario: tearDown (Alternative Scenario: stack=1 )

Project: guava
 Class: FileBackedOutputStreamTest
 Method: testFinalizeDeletesFile
 Body: {
    byte[] data = newPreFilledByteArray(100);
    FileBackedOutputStream out = new FileBackedOutputStream(0, true);

    write(out, data, 0, 100, true);
    final File file = out.getFile();
    assertEquals(100, file.length());
    assertTrue(file.exists());
    out.close();

    // Make sure that finalize deletes the file
    out = null;

    // times out and throws RuntimeException on failure
    GcFinalization.awaitDone(
        new GcFinalization.FinalizationPredicate() {
          @Override
          public boolean isDone() {
            return !file.exists();
          }
        });
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: exists=2 ) - Predicate: length - Scenario: file (Alternative Scenario: file=1 )

Project: guava
 Class: FileBackedOutputStreamTest
 Method: testReset
 Body: {
    byte[] data = newPreFilledByteArray(100);
    FileBackedOutputStream out = new FileBackedOutputStream(Integer.MAX_VALUE);
    ByteSource source = out.asByteSource();

    out.write(data);
    assertTrue(Arrays.equals(data, source.read()));

    out.reset();
    assertTrue(Arrays.equals(new byte[0], source.read()));

    out.write(data);
    assertTrue(Arrays.equals(data, source.read()));

    out.close();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: read=3 ) - Predicate: equals - Scenario: source (Alternative Scenario: data=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetSubsetRemove
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("a", 1);
    ms.add("b", 3);
    ms.add("c", 2);
    ms.add("d", 1);
    ms.add("e", 3);
    ms.add("f", 2);

    SortedSet<String> elementSet = ms.elementSet();
    assertThat(elementSet).containsExactly("a", "b", "c", "d", "e", "f").inOrder();
    SortedSet<String> subset = elementSet.subSet("b", "f");
    assertThat(subset).containsExactly("b", "c", "d", "e").inOrder();

    assertTrue(subset.remove("c"));
    assertThat(elementSet).containsExactly("a", "b", "d", "e", "f").inOrder();
    assertThat(subset).containsExactly("b", "d", "e").inOrder();
    assertEquals(10, ms.size());

    assertFalse(subset.remove("a"));
    assertThat(elementSet).containsExactly("a", "b", "d", "e", "f").inOrder();
    assertThat(subset).containsExactly("b", "d", "e").inOrder();
    assertEquals(10, ms.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=6 ) - Predicate: N/A - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetSubsetClear
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("a", 1);
    ms.add("b", 3);
    ms.add("c", 2);
    ms.add("d", 1);
    ms.add("e", 3);
    ms.add("f", 2);

    SortedSet<String> elementSet = ms.elementSet();
    assertThat(elementSet).containsExactly("a", "b", "c", "d", "e", "f").inOrder();
    SortedSet<String> subset = elementSet.subSet("b", "f");
    assertThat(subset).containsExactly("b", "c", "d", "e").inOrder();

    subset.clear();
    assertThat(elementSet).containsExactly("a", "f").inOrder();
    assertThat(subset).isEmpty();
    assertEquals(3, ms.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=6 ) - Predicate: N/A - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetSubsetRetainAll
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("a", 1);
    ms.add("b", 3);
    ms.add("c", 2);
    ms.add("d", 1);
    ms.add("e", 3);
    ms.add("f", 2);

    SortedSet<String> elementSet = ms.elementSet();
    assertThat(elementSet).containsExactly("a", "b", "c", "d", "e", "f").inOrder();
    SortedSet<String> subset = elementSet.subSet("b", "f");
    assertThat(subset).containsExactly("b", "c", "d", "e").inOrder();

    assertTrue(subset.retainAll(Arrays.asList("a", "c")));
    assertThat(elementSet).containsExactly("a", "c", "f").inOrder();
    assertThat(subset).containsExactly("c");
    assertEquals(5, ms.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=6 ) - Predicate: N/A - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testCreate
 Body: {
    TreeMultiset<String> multiset = TreeMultiset.create();
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals(Ordering.natural(), multiset.comparator());
    assertEquals("[bar, foo x 2]", multiset.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testSubMultisetSize
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("a", Integer.MAX_VALUE);
    ms.add("b", Integer.MAX_VALUE);
    ms.add("c", 3);

    assertEquals(Integer.MAX_VALUE, ms.count("a"));
    assertEquals(Integer.MAX_VALUE, ms.count("b"));
    assertEquals(3, ms.count("c"));

    assertEquals(Integer.MAX_VALUE, ms.headMultiset("c", CLOSED).size());
    assertEquals(Integer.MAX_VALUE, ms.headMultiset("b", CLOSED).size());
    assertEquals(Integer.MAX_VALUE, ms.headMultiset("a", CLOSED).size());

    assertEquals(3, ms.tailMultiset("c", CLOSED).size());
    assertEquals(Integer.MAX_VALUE, ms.tailMultiset("b", CLOSED).size());
    assertEquals(Integer.MAX_VALUE, ms.tailMultiset("a", CLOSED).size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: size=6 ) - Predicate: count - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetSubsetRemoveAll
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("a", 1);
    ms.add("b", 3);
    ms.add("c", 2);
    ms.add("d", 1);
    ms.add("e", 3);
    ms.add("f", 2);

    SortedSet<String> elementSet = ms.elementSet();
    assertThat(elementSet).containsExactly("a", "b", "c", "d", "e", "f").inOrder();
    SortedSet<String> subset = elementSet.subSet("b", "f");
    assertThat(subset).containsExactly("b", "c", "d", "e").inOrder();

    assertTrue(subset.removeAll(Arrays.asList("a", "c")));
    assertThat(elementSet).containsExactly("a", "b", "d", "e", "f").inOrder();
    assertThat(subset).containsExactly("b", "d", "e").inOrder();
    assertEquals(10, ms.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=6 ) - Predicate: N/A - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testCreateWithComparator
 Body: {
    Multiset<String> multiset = TreeMultiset.create(Collections.reverseOrder());
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals("[foo x 2, bar]", multiset.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testCustomComparator
 Body: {
    Comparator<String> comparator =
        new Comparator<String>() {
          @Override
          public int compare(String o1, String o2) {
            return o2.compareTo(o1);
          }
        };
    TreeMultiset<String> ms = TreeMultiset.create(comparator);

    ms.add("b");
    ms.add("c");
    ms.add("a");
    ms.add("b");
    ms.add("d");

    assertThat(ms).containsExactly("d", "c", "b", "b", "a").inOrder();

    SortedSet<String> elementSet = ms.elementSet();
    assertEquals("d", elementSet.first());
    assertEquals("a", elementSet.last());
    assertEquals(comparator, elementSet.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=5 ) - Predicate: N/A - Scenario: ms (Alternative Scenario: comparator=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testNullAcceptingComparator
 Body: {
    Comparator<String> comparator = Ordering.<String>natural().nullsFirst();
    TreeMultiset<String> ms = TreeMultiset.create(comparator);

    ms.add("b");
    ms.add(null);
    ms.add("a");
    ms.add("b");
    ms.add(null, 2);

    assertThat(ms).containsExactly(null, null, null, "a", "b", "b").inOrder();
    assertEquals(3, ms.count(null));

    SortedSet<String> elementSet = ms.elementSet();
    assertEquals(null, elementSet.first());
    assertEquals("b", elementSet.last());
    assertEquals(comparator, elementSet.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=5 ) - Predicate: N/A - Scenario: ms (Alternative Scenario: comparator=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testToString
 Body: {
    Multiset<String> ms = TreeMultiset.create();
    ms.add("a", 3);
    ms.add("c", 1);
    ms.add("b", 2);

    assertEquals("[a x 3, b x 2, c]", ms.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: toString - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testDegenerateComparator
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create(DEGENERATE_COMPARATOR);

    ms.add("foo");
    ms.add("a");
    ms.add("bar");
    ms.add("b");
    ms.add("c");

    assertEquals(2, ms.count("bar"));
    assertEquals(3, ms.count("b"));

    Multiset<String> ms2 = TreeMultiset.create(DEGENERATE_COMPARATOR);

    ms2.add("cat", 2);
    ms2.add("x", 3);

    assertEquals(ms, ms2);
    assertEquals(ms2, ms);

    SortedSet<String> elementSet = ms.elementSet();
    assertEquals("a", elementSet.first());
    assertEquals("foo", elementSet.last());
    assertEquals(DEGENERATE_COMPARATOR, elementSet.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=7 ) - Predicate: count - Scenario: ms (Alternative Scenario: elementSet=1 )

Project: guava
 Class: TreeMultisetTest
 Method: testElementSetSortedSetMethods
 Body: {
    TreeMultiset<String> ms = TreeMultiset.create();
    ms.add("c", 1);
    ms.add("a", 3);
    ms.add("b", 2);
    SortedSet<String> elementSet = ms.elementSet();

    assertEquals("a", elementSet.first());
    assertEquals("c", elementSet.last());
    assertEquals(Ordering.natural(), elementSet.comparator());

    assertThat(elementSet.headSet("b")).containsExactly("a");
    assertThat(elementSet.tailSet("b")).containsExactly("b", "c").inOrder();
    assertThat(elementSet.subSet("a", "c")).containsExactly("a", "b").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: first - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: CompactLinkedHashMapTest
 Method: testTrimToSize
 Body: {
    CompactLinkedHashMap<Integer, String> map = CompactLinkedHashMap.createWithExpectedSize(100);
    map.put(1, "a");
    map.put(4, "b");
    map.put(3, "d");
    map.put(2, "c");
    map.trimToSize();
    assertThat(map.entries).hasLength(4);
    assertThat(map.keys).hasLength(4);
    assertThat(map.values).hasLength(4);
    assertThat(map.links).hasLength(4);
    assertEquals(4, map.size());
    testHasMapEntriesInOrder(map, 1, "a", 4, "b", 3, "d", 2, "c");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: FeatureSpecificTestSuiteBuilderTest
 Method: testLifecycle
 Body: {
    final boolean setUp[] = {false};
    Runnable setUpRunnable =
        new Runnable() {
          @Override
          public void run() {
            setUp[0] = true;
          }
        };

    final boolean tearDown[] = {false};
    Runnable tearDownRunnable =
        new Runnable() {
          @Override
          public void run() {
            tearDown[0] = true;
          }
        };

    MyTestSuiteBuilder builder = new MyTestSuiteBuilder();
    Test test =
        builder
            .usingGenerator("yam")
            .named("yam")
            .withFeatures(CollectionFeature.NONE)
            .withSetUp(setUpRunnable)
            .withTearDown(tearDownRunnable)
            .createTestSuite();
    TestResult result = new TestResult();
    test.run(result);
    assertTrue(testWasRun);
    assertTrue(setUp[0]);
    assertTrue(tearDown[0]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: run (Alternative Action: withSetUp=1 ) - Predicate: N/A - Scenario: result (Alternative Scenario: result=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testInt
 Body: {
    Sink sink = new Sink(4);
    sink.putInt(0x04030201);
    HashCode unused = sink.hash();
    sink.assertInvariants(4);
    sink.assertBytes(new byte[] {1, 2, 3, 4});
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putInt (Alternative Action: putInt=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testBytes
 Body: {
    Sink sink = new Sink(4); // byte order insignificant here
    byte[] expected = {1, 2, 3, 4, 5, 6, 7, 8};
    sink.putByte((byte) 1);
    sink.putBytes(new byte[] {2, 3, 4, 5, 6});
    sink.putByte((byte) 7);
    sink.putBytes(new byte[] {});
    sink.putBytes(new byte[] {8});
    HashCode unused = sink.hash();
    sink.assertInvariants(8);
    sink.assertBytes(expected);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putBytes (Alternative Action: putBytes=3 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testShort
 Body: {
    Sink sink = new Sink(4);
    sink.putShort((short) 0x0201);
    HashCode unused = sink.hash();
    sink.assertInvariants(2);
    sink.assertBytes(new byte[] {1, 2, 0, 0}); // padded with zeros
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putShort (Alternative Action: putShort=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testLong
 Body: {
    Sink sink = new Sink(8);
    sink.putLong(0x0807060504030201L);
    HashCode unused = sink.hash();
    sink.assertInvariants(8);
    sink.assertBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putLong (Alternative Action: putLong=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testDouble
 Body: {
    Sink sink = new Sink(8);
    sink.putDouble(Double.longBitsToDouble(0x0807060504030201L));
    HashCode unused = sink.hash();
    sink.assertInvariants(8);
    sink.assertBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putDouble (Alternative Action: putDouble=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testChar
 Body: {
    Sink sink = new Sink(4);
    sink.putChar((char) 0x0201);
    HashCode unused = sink.hash();
    sink.assertInvariants(2);
    sink.assertBytes(new byte[] {1, 2, 0, 0}); // padded with zeros
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putChar (Alternative Action: putChar=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: AbstractStreamingHasherTest
 Method: testFloat
 Body: {
    Sink sink = new Sink(4);
    sink.putFloat(Float.intBitsToFloat(0x04030201));
    HashCode unused = sink.hash();
    sink.assertInvariants(4);
    sink.assertBytes(new byte[] {1, 2, 3, 4});
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putFloat (Alternative Action: putFloat=1 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: sink=1 )

Project: guava
 Class: SequentialExecutorTest
 Method: testRuntimeException_doesNotStopExecution
 Body: {

    final AtomicInteger numCalls = new AtomicInteger();

    Runnable runMe =
        new Runnable() {
          @Override
          public void run() {
            numCalls.incrementAndGet();
            throw new RuntimeException("FAKE EXCEPTION!");
          }
        };

    e.execute(runMe);
    e.execute(runMe);
    fakePool.runAll();

    assertEquals(2, numCalls.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: execute (Alternative Action: execute=2 ) - Predicate: get - Scenario: runMe (Alternative Scenario: numCalls=1 )

Project: guava
 Class: SequentialExecutorTest
 Method: testBasics
 Body: {
    final AtomicInteger totalCalls = new AtomicInteger();
    Runnable intCounter =
        new Runnable() {
          @Override
          public void run() {
            totalCalls.incrementAndGet();
            // Make sure that no other tasks are scheduled to run while this is running.
            assertFalse(fakePool.hasNext());
          }
        };

    assertFalse(fakePool.hasNext());
    e.execute(intCounter);
    // A task should have been scheduled
    assertTrue(fakePool.hasNext());
    e.execute(intCounter);
    // Our executor hasn't run any tasks yet.
    assertEquals(0, totalCalls.get());
    fakePool.runAll();
    assertEquals(2, totalCalls.get());
    // Queue is empty so no runner should be scheduled.
    assertFalse(fakePool.hasNext());

    // Check that execute can be safely repeated
    e.execute(intCounter);
    e.execute(intCounter);
    e.execute(intCounter);
    // No change yet.
    assertEquals(2, totalCalls.get());
    fakePool.runAll();
    assertEquals(5, totalCalls.get());
    assertFalse(fakePool.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: execute (Alternative Action: hasNext=5 ) - Predicate: hasNext - Scenario: totalCalls (Alternative Scenario: totalCalls=1 )

Project: guava
 Class: SequentialExecutorTest
 Method: testInterrupt_doesNotStopExecution
 Body: {

    final AtomicInteger numCalls = new AtomicInteger();

    Runnable runMe =
        new Runnable() {
          @Override
          public void run() {
            numCalls.incrementAndGet();
          }
        };

    Thread.currentThread().interrupt();

    e.execute(runMe);
    e.execute(runMe);
    fakePool.runAll();

    assertEquals(2, numCalls.get());

    assertTrue(Thread.interrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: interrupt (Alternative Action: execute=2 ) - Predicate: get - Scenario: runMe (Alternative Scenario: numCalls=1 )

Project: guava
 Class: FakeTickerTest
 Method: testAdvance
 Body: {
    FakeTicker ticker = new FakeTicker();
    assertEquals(0, ticker.read());
    assertSame(ticker, ticker.advance(10));
    assertEquals(10, ticker.read());
    ticker.advance(1, TimeUnit.MILLISECONDS);
    assertEquals(1000010L, ticker.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: advance (Alternative Action: read=3 ) - Predicate: read - Scenario: ticker (Alternative Scenario: ticker=1 )

Project: guava
 Class: FakeTickerTest
 Method: testConcurrentAutoIncrementStep
 Body: {
    int incrementByNanos = 3;
    final FakeTicker ticker =
        new FakeTicker().setAutoIncrementStep(incrementByNanos, TimeUnit.NANOSECONDS);

    int numberOfThreads = 64;
    runConcurrentTest(
        numberOfThreads,
        new Callable<Void>() {
          @Override
          public Void call() throws Exception {
            ticker.read();
            return null;
          }
        });

    assertEquals(incrementByNanos * numberOfThreads, ticker.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: runConcurrentTest (Alternative Action: read=2 ) - Predicate: read - Scenario: numberOfThreads (Alternative Scenario: incrementByNanos=1 )

Project: guava
 Class: FakeTickerTest
 Method: testConcurrentAdvance
 Body: {
    final FakeTicker ticker = new FakeTicker();

    int numberOfThreads = 64;
    runConcurrentTest(
        numberOfThreads,
        new Callable<Void>() {
          @Override
          public Void call() throws Exception {
            // adds two nanoseconds to the ticker
            ticker.advance(1L);
            Thread.sleep(10);
            ticker.advance(1L);
            return null;
          }
        });

    assertEquals(numberOfThreads * 2, ticker.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: runConcurrentTest (Alternative Action: advance=2 ) - Predicate: read - Scenario: numberOfThreads (Alternative Scenario: ticker=1 )

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_directedVsUndirected
 Body: {
    graph.putEdge(N1, N2);

    MutableGraph<Integer> g2 = createGraph(oppositeType(edgeType));
    g2.putEdge(N1, N2);

    assertThat(graph).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: putEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_nodeSetsDiffer
 Body: {
    graph.addNode(N1);

    MutableGraph<Integer> g2 = createGraph(edgeType);
    g2.addNode(N2);

    assertThat(graph).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_selfLoop_directedVsUndirected
 Body: {
    graph.putEdge(N1, N1);

    MutableGraph<Integer> g2 = createGraph(oppositeType(edgeType));
    g2.putEdge(N1, N1);

    assertThat(graph).isNotEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: putEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_propertiesDiffer
 Body: {
    graph.putEdge(N1, N2);

    MutableGraph<Integer> g2 =
        GraphBuilder.from(graph).allowsSelfLoops(!graph.allowsSelfLoops()).build();
    g2.putEdge(N1, N2);

    assertThat(graph).isEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: putEdge=2 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: g2=1 )

Project: guava
 Class: GraphEquivalenceTest
 Method: equivalent_edgeAddOrdersDiffer
 Body: {
    GraphBuilder<Integer> builder = GraphBuilder.from(graph);
    MutableGraph<Integer> g1 = builder.build();
    MutableGraph<Integer> g2 = builder.build();

    // for g1, add 1->2 first, then 3->1
    g1.putEdge(N1, N2);
    g1.putEdge(N3, N1);

    // for g2, add 3->1 first, then 1->2
    g2.putEdge(N3, N1);
    g2.putEdge(N1, N2);

    assertThat(g1).isEqualTo(g2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: putEdge=4 ) - Predicate: N/A - Scenario: g2 (Alternative Scenario: builder=1 )

Project: guava
 Class: ListenerCallQueueTest
 Method: testEnqueueAndDispatch_withExceptions
 Body: {
    Object listener = new Object();
    ListenerCallQueue<Object> queue = new ListenerCallQueue<>();
    queue.addListener(listener, directExecutor());

    Multiset<Object> counters = ConcurrentHashMultiset.create();
    queue.enqueue(incrementingEvent(counters, listener, 1));
    queue.enqueue(THROWING_EVENT);
    queue.enqueue(incrementingEvent(counters, listener, 2));
    queue.enqueue(THROWING_EVENT);
    queue.enqueue(incrementingEvent(counters, listener, 3));
    queue.enqueue(THROWING_EVENT);
    queue.enqueue(incrementingEvent(counters, listener, 4));
    queue.enqueue(THROWING_EVENT);
    assertEquals(0, counters.size());
    queue.dispatch();
    assertEquals(multiset(listener, 4), counters);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: enqueue (Alternative Action: enqueue=8 ) - Predicate: size - Scenario: counters (Alternative Scenario: counters=1 )

Project: guava
 Class: ListenerCallQueueTest
 Method: testEnqueueAndDispatch
 Body: {
    Object listener = new Object();
    ListenerCallQueue<Object> queue = new ListenerCallQueue<>();
    queue.addListener(listener, directExecutor());

    Multiset<Object> counters = ConcurrentHashMultiset.create();
    queue.enqueue(incrementingEvent(counters, listener, 1));
    queue.enqueue(incrementingEvent(counters, listener, 2));
    queue.enqueue(incrementingEvent(counters, listener, 3));
    queue.enqueue(incrementingEvent(counters, listener, 4));
    assertEquals(0, counters.size());
    queue.dispatch();
    assertEquals(multiset(listener, 4), counters);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: enqueue (Alternative Action: incrementingEvent=4 ) - Predicate: size - Scenario: counters (Alternative Scenario: counters=1 )

Project: guava
 Class: ListenerCallQueueTest
 Method: testEnqueueAndDispatch_multipleListeners
 Body: {
    Object listener1 = new Object();
    ListenerCallQueue<Object> queue = new ListenerCallQueue<>();
    queue.addListener(listener1, directExecutor());

    Multiset<Object> counters = ConcurrentHashMultiset.create();
    queue.enqueue(incrementingEvent(counters, listener1, 1));
    queue.enqueue(incrementingEvent(counters, listener1, 2));

    Object listener2 = new Object();
    queue.addListener(listener2, directExecutor());
    queue.enqueue(incrementingEvent(counters, multiset(listener1, 3, listener2, 1)));
    queue.enqueue(incrementingEvent(counters, multiset(listener1, 4, listener2, 2)));
    assertEquals(0, counters.size());
    queue.dispatch();
    assertEquals(multiset(listener1, 4, listener2, 2), counters);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: incrementingEvent=4 ) - Predicate: size - Scenario: listener2 (Alternative Scenario: counters=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testEntriesAfterMultimapUpdate
 Body: {
    ListMultimap<String, Integer> multimap = create();
    multimap.put("foo", 2);
    multimap.put("bar", 3);
    Collection<Entry<String, Integer>> entries = multimap.entries();
    Iterator<Entry<String, Integer>> iterator = entries.iterator();
    Entry<String, Integer> entrya = iterator.next();
    Entry<String, Integer> entryb = iterator.next();

    assertEquals(2, (int) multimap.get("foo").set(0, 4));
    assertFalse(multimap.containsEntry("foo", 2));
    assertTrue(multimap.containsEntry("foo", 4));
    assertTrue(multimap.containsEntry("bar", 3));
    assertEquals(4, (int) entrya.getValue());
    assertEquals(3, (int) entryb.getValue());

    assertTrue(multimap.put("foo", 5));
    assertTrue(multimap.containsEntry("foo", 5));
    assertTrue(multimap.containsEntry("foo", 4));
    assertTrue(multimap.containsEntry("bar", 3));
    assertEquals(4, (int) entrya.getValue());
    assertEquals(3, (int) entryb.getValue());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsEntry=6 ) - Predicate: N/A - Scenario: entries (Alternative Scenario: entrya=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testReplaceValuesRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertTrue(multimap.replaceValues("foo", Arrays.asList(2, 4)) instanceof RandomAccess);
    assertTrue(multimap.replaceValues("bar", Arrays.asList(2, 4)) instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: replaceValues=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedKeySet
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    map.put("bar", 4);
    assertEquals("[bar, foo]", map.keySet().toString());
    map.keySet().remove("bar");
    assertEquals("{foo=[2]}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedValues
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    map.put("bar", 4);
    assertEquals("[1, 2, 3, 4]", map.values().toString());
    map.values().remove(2);
    assertEquals("{bar=[1, 3, 4]}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedPutInOrder
 Body: {
    Multimap<String, Integer> map = create();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("bar", 3);
    assertEquals("{foo=[1], bar=[2, 3]}", map.toString());
    assertEquals("[foo=1, bar=2, bar=3]", map.entries().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedPutAllMultimap
 Body: {
    Multimap<String, Integer> src = create();
    src.put("bar", 1);
    src.put("foo", 2);
    src.put("bar", 3);
    Multimap<String, Integer> dst = create();
    dst.putAll(src);
    assertEquals("{bar=[1, 3], foo=[2]}", dst.toString());
    assertEquals("[bar=1, foo=2, bar=3]", src.entries().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: put=3 ) - Predicate: toString - Scenario: dst (Alternative Scenario: dst=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedReplaceValues
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    map.put("bar", 4);
    assertEquals("{bar=[1, 3, 4], foo=[2]}", map.toString());
    map.replaceValues("bar", asList(1, 2));
    assertEquals("[bar=1, foo=2, bar=2]", map.entries().toString());
    assertEquals("{bar=[1, 2], foo=[2]}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testCreateFromSize
 Body: {
    LinkedListMultimap<String, Integer> multimap = LinkedListMultimap.create(20);
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    assertEquals(ImmutableList.of(1, 3), multimap.get("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testCreateFromMultimap
 Body: {
    Multimap<String, Integer> multimap = LinkedListMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 3);
    multimap.put("foo", 2);
    LinkedListMultimap<String, Integer> copy = LinkedListMultimap.create(multimap);
    assertEquals(multimap, copy);
    assertThat(copy.entries()).containsExactlyElementsIn(multimap.entries()).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedEntries
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    Iterator<Entry<String, Integer>> entries = map.entries().iterator();
    Entry<String, Integer> entry = entries.next();
    assertEquals("bar", entry.getKey());
    assertEquals(1, (int) entry.getValue());
    entry = entries.next();
    assertEquals("foo", entry.getKey());
    assertEquals(2, (int) entry.getValue());
    entry.setValue(4);
    entry = entries.next();
    assertEquals("bar", entry.getKey());
    assertEquals(3, (int) entry.getValue());
    assertFalse(entries.hasNext());
    entries.remove();
    assertEquals("{bar=[1], foo=[4]}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: next=3 ) - Predicate: getKey - Scenario: entries (Alternative Scenario: entry=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testRemoveAllRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertTrue(multimap.removeAll("foo") instanceof RandomAccess);
    assertTrue(multimap.removeAll("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: removeAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedPutOutOfOrder
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    assertEquals("{bar=[1, 3], foo=[2]}", map.toString());
    assertEquals("[bar=1, foo=2, bar=3]", map.entries().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testGetRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertFalse(multimap.get("foo") instanceof RandomAccess);
    assertFalse(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedGetAdd
 Body: {
    LinkedListMultimap<String, Integer> map = create();
    map.put("bar", 1);
    Collection<Integer> foos = map.get("foo");
    foos.add(2);
    foos.add(3);
    map.put("bar", 4);
    map.put("foo", 5);
    assertEquals("{bar=[1, 4], foo=[2, 3, 5]}", map.toString());
    assertEquals("[bar=1, foo=2, foo=3, bar=4, foo=5]", map.entries().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: put=3 ) - Predicate: toString - Scenario: foos (Alternative Scenario: foos=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedKeys
 Body: {
    Multimap<String, Integer> map = create();
    map.put("bar", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    map.put("bar", 4);
    assertEquals("[bar=1, foo=2, bar=3, bar=4]", map.entries().toString());
    assertThat(map.keys()).containsExactly("bar", "foo", "bar", "bar").inOrder();
    map.keys().remove("bar"); // bar is no longer the first key!
    assertEquals("{foo=[2], bar=[3, 4]}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedGetInsert
 Body: {
    ListMultimap<String, Integer> map = create();
    map.put("bar", 1);
    List<Integer> foos = map.get("foo");
    foos.add(2);
    foos.add(0, 3);
    map.put("bar", 4);
    map.put("foo", 5);
    assertEquals("{bar=[1, 4], foo=[3, 2, 5]}", map.toString());
    assertEquals("[bar=1, foo=3, foo=2, bar=4, foo=5]", map.entries().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: put=3 ) - Predicate: toString - Scenario: foos (Alternative Scenario: foos=1 )

Project: guava
 Class: LinkedListMultimapTest
 Method: testLinkedClear
 Body: {
    ListMultimap<String, Integer> map = create();
    map.put("foo", 1);
    map.put("foo", 2);
    map.put("bar", 3);
    List<Integer> foos = map.get("foo");
    Collection<Integer> values = map.values();
    assertEquals(asList(1, 2), foos);
    assertThat(values).containsExactly(1, 2, 3).inOrder();
    map.clear();
    assertEquals(Collections.emptyList(), foos);
    assertThat(values).isEmpty();
    assertEquals("[]", map.entries().toString());
    assertEquals("{}", map.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: asList - Scenario: foos (Alternative Scenario: values=1 )

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testGenericArrayType
 Body: {
    @SuppressWarnings("unchecked") // Trying to test generic array
    ImmutableList<Integer>[] array = new ImmutableList[] {ImmutableList.of(1)};
    TypeToken<ImmutableList<Integer>[]> type = new TypeToken<ImmutableList<Integer>[]>() {};
    map.putInstance(type, array);
    assertEquals(1, map.size());
    assertThat(map.getInstance(type)).asList().containsExactly(array[0]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putInstance (Alternative Action: size=1 ) - Predicate: size - Scenario: type (Alternative Scenario: array=1 )

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testParameterizedType
 Body: {
    TypeToken<ImmutableList<Integer>> type = new TypeToken<ImmutableList<Integer>>() {};
    map.putInstance(type, ImmutableList.of(1));
    assertEquals(1, map.size());
    assertEquals(ImmutableList.of(1), map.getInstance(type));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putInstance (Alternative Action: of=2 ) - Predicate: size - Scenario: type (Alternative Scenario: type=1 )

Project: guava
 Class: MutableTypeToInstanceMapTest
 Method: testWildcardType
 Body: {
    TypeToken<ImmutableList<?>> type = new TypeToken<ImmutableList<?>>() {};
    map.putInstance(type, ImmutableList.of(1));
    assertEquals(1, map.size());
    assertEquals(ImmutableList.of(1), map.getInstance(type));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putInstance (Alternative Action: of=2 ) - Predicate: size - Scenario: type (Alternative Scenario: type=1 )

Project: guava
 Class: ForwardingNavigableMapTest
 Method: testStandardLastEntry
 Body: {
    NavigableMap<String, Integer> forwarding =
        new StandardLastEntryForwardingNavigableMap<>(new SafeTreeMap<String, Integer>());
    assertNull(forwarding.lastEntry());
    forwarding.put("b", 2);
    assertEquals(immutableEntry("b", 2), forwarding.lastEntry());
    forwarding.put("c", 3);
    assertEquals(immutableEntry("c", 3), forwarding.lastEntry());
    forwarding.put("a", 1);
    assertEquals(immutableEntry("c", 3), forwarding.lastEntry());
    forwarding.remove("c");
    assertEquals(immutableEntry("b", 2), forwarding.lastEntry());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: lastEntry=5 ) - Predicate: lastEntry - Scenario: forwarding (Alternative Scenario: forwarding=1 )

Project: guava
 Class: ExecutionListTest
 Method: testExecute_idempotent
 Body: {
    final AtomicInteger runCalled = new AtomicInteger();
    list.add(
        new Runnable() {
          @Override
          public void run() {
            runCalled.getAndIncrement();
          }
        },
        directExecutor());
    list.execute();
    assertEquals(1, runCalled.get());
    list.execute();
    assertEquals(1, runCalled.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: get=2 ) - Predicate: get - Scenario: runCalled (Alternative Scenario: runCalled=1 )

Project: guava
 Class: ExecutionListTest
 Method: testRunOnPopulatedList
 Body: {
    Executor exec = Executors.newCachedThreadPool();
    CountDownLatch countDownLatch = new CountDownLatch(3);
    list.add(new MockRunnable(countDownLatch), exec);
    list.add(new MockRunnable(countDownLatch), exec);
    list.add(new MockRunnable(countDownLatch), exec);
    assertEquals(3L, countDownLatch.getCount());

    list.execute();

    // Verify that all of the runnables execute in a reasonable amount of time.
    assertTrue(countDownLatch.await(1L, TimeUnit.SECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: getCount - Scenario: countDownLatch (Alternative Scenario: countDownLatch=1 )

Project: guava
 Class: ExecutionListTest
 Method: testExecute_idempotentConcurrently
 Body: {
    final CountDownLatch okayToRun = new CountDownLatch(1);
    final AtomicInteger runCalled = new AtomicInteger();
    list.add(
        new Runnable() {
          @Override
          public void run() {
            try {
              okayToRun.await();
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
              throw new RuntimeException(e);
            }
            runCalled.getAndIncrement();
          }
        },
        directExecutor());
    Runnable execute =
        new Runnable() {
          @Override
          public void run() {
            list.execute();
          }
        };
    Thread thread1 = new Thread(execute);
    Thread thread2 = new Thread(execute);
    thread1.start();
    thread2.start();
    assertEquals(0, runCalled.get());
    okayToRun.countDown();
    thread1.join();
    thread2.join();
    assertEquals(1, runCalled.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: get=2 ) - Predicate: get - Scenario: thread2 (Alternative Scenario: runCalled=1 )

Project: guava
 Class: ExecutionListTest
 Method: testAddAfterRun
 Body: {
    // Run the previous test
    testRunOnPopulatedList();

    // If it passed, then verify an Add will be executed without calling run
    CountDownLatch countDownLatch = new CountDownLatch(1);
    list.add(new MockRunnable(countDownLatch), Executors.newCachedThreadPool());
    assertTrue(countDownLatch.await(1L, TimeUnit.SECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: await - Scenario: countDownLatch (Alternative Scenario: countDownLatch=1 )

Project: guava
 Class: ListsTest
 Method: testAsList1
 Body: {
    List<String> list = Lists.asList("foo", new String[] {"bar", "baz"});
    checkFooBarBazList(list);
    SerializableTester.reserializeAndAssert(list);
    assertTrue(list instanceof RandomAccess);

    new IteratorTester<String>(
        5, UNMODIFIABLE, asList("foo", "bar", "baz"), IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator<String> newTargetIterator() {
        return Lists.asList("foo", new String[] {"bar", "baz"}).iterator();
      }
    }.test();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkFooBarBazList (Alternative Action: asList=3 ) - Predicate: N/A - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: ListsTest
 Method: testPartition_view
 Body: {
    List<Integer> list = asList(1, 2, 3);
    List<List<Integer>> partitions = Lists.partition(list, 3);

    // Changes before the partition is retrieved are reflected
    list.set(0, 3);

    Iterator<List<Integer>> iterator = partitions.iterator();

    // Changes before the partition is retrieved are reflected
    list.set(1, 4);

    List<Integer> first = iterator.next();

    // Changes after are too (unlike Iterables.partition)
    list.set(2, 5);

    assertEquals(asList(3, 4, 5), first);

    // Changes to a sublist also write through to the original list
    first.set(1, 6);
    assertEquals(asList(3, 6, 5), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=4 ) - Predicate: asList - Scenario: first (Alternative Scenario: partitions=1 )

Project: guava
 Class: ListsTest
 Method: testAsList1Small
 Body: {
    List<String> list = Lists.asList("foo", new String[0]);
    assertThat(list).contains("foo");
    assertEquals(1, list.size());
    assertIndexIsOutOfBounds(list, -1);
    assertEquals("foo", list.get(0));
    assertIndexIsOutOfBounds(list, 1);
    assertTrue(list instanceof RandomAccess);

    new IteratorTester<String>(
        3, UNMODIFIABLE, singletonList("foo"), IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator<String> newTargetIterator() {
        return Lists.asList("foo", new String[0]).iterator();
      }
    }.test();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: test (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: ListsTest
 Method: testAsList2
 Body: {
    List<String> list = Lists.asList("foo", "bar", new String[] {"baz"});
    checkFooBarBazList(list);
    assertTrue(list instanceof RandomAccess);

    new IteratorTester<String>(
        5, UNMODIFIABLE, asList("foo", "bar", "baz"), IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator<String> newTargetIterator() {
        return Lists.asList("foo", "bar", new String[] {"baz"}).iterator();
      }
    }.test();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkFooBarBazList (Alternative Action: asList=3 ) - Predicate: N/A - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: ListsTest
 Method: testAsList2Small
 Body: {
    List<String> list = Lists.asList("foo", "bar", new String[0]);
    assertThat(list).containsExactly("foo", "bar").inOrder();
    assertEquals(2, list.size());
    assertIndexIsOutOfBounds(list, -1);
    assertEquals("foo", list.get(0));
    assertEquals("bar", list.get(1));
    assertIndexIsOutOfBounds(list, 2);
    SerializableTester.reserializeAndAssert(list);
    assertTrue(list instanceof RandomAccess);

    new IteratorTester<String>(
        5, UNMODIFIABLE, asList("foo", "bar"), IteratorTester.KnownOrder.KNOWN_ORDER) {
      @Override
      protected Iterator<String> newTargetIterator() {
        return Lists.asList("foo", "bar", new String[0]).iterator();
      }
    }.test();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: test (Alternative Action: asList=3 ) - Predicate: N/A - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: ListsTest
 Method: testCharactersOfIsView
 Body: {
    StringBuilder builder = new StringBuilder("abc");
    List<Character> chars = Lists.charactersOf(builder);
    assertEquals(asList('a', 'b', 'c'), chars);
    builder.append("def");
    assertEquals(asList('a', 'b', 'c', 'd', 'e', 'f'), chars);
    builder.deleteCharAt(5);
    assertEquals(asList('a', 'b', 'c', 'd', 'e'), chars);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: append (Alternative Action: asList=3 ) - Predicate: asList - Scenario: builder (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableMapTest
 Method: testBuilderPutAllEntryList
 Body: {
    List<Entry<String, String>> entryList =
        Arrays.asList(
            new AbstractMap.SimpleEntry<>("a", "1"), new AbstractMap.SimpleEntry<>("b", "2"));
    ImmutableMap<String, String> map =
        ImmutableMap.<String, String>builder().putAll(entryList).build();
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
    entryList.get(0).setValue("3");
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: build=1 ) - Predicate: N/A - Scenario: entryList (Alternative Scenario: entryList=1 )

Project: guava
 Class: ImmutableMapTest
 Method: testBuilderPutAllEntryListJdkBacked
 Body: {
    List<Entry<String, String>> entryList =
        Arrays.asList(
            new AbstractMap.SimpleEntry<>("a", "1"), new AbstractMap.SimpleEntry<>("b", "2"));
    ImmutableMap<String, String> map =
        ImmutableMap.<String, String>builder().putAll(entryList).buildJdkBacked();
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
    entryList.get(0).setValue("3");
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: buildJdkBacked=1 ) - Predicate: N/A - Scenario: entryList (Alternative Scenario: entryList=1 )

Project: guava
 Class: ImmutableMapTest
 Method: testCopyOfMutableEntryList
 Body: {
    List<Entry<String, String>> entryList =
        Arrays.asList(
            new AbstractMap.SimpleEntry<>("a", "1"), new AbstractMap.SimpleEntry<>("b", "2"));
    ImmutableMap<String, String> map = ImmutableMap.copyOf(entryList);
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
    entryList.get(0).setValue("3");
    assertThat(map).containsExactly("a", "1", "b", "2").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: get=1 ) - Predicate: N/A - Scenario: entryList (Alternative Scenario: entryList=1 )

Project: guava
 Class: ImmutableMapTest
 Method: testCopyOfEnumMap
 Body: {
    EnumMap<AnEnum, String> map = new EnumMap<>(AnEnum.class);
    map.put(AnEnum.B, "foo");
    map.put(AnEnum.C, "bar");
    assertTrue(ImmutableMap.copyOf(map) instanceof ImmutableEnumMap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: N/A - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testSubRangeMapRemove
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.open(3, 7), 1);
    rangeMap.put(Range.closed(9, 10), 2);
    rangeMap.put(Range.closed(12, 16), 3);
    RangeMap<Integer, Integer> sub = rangeMap.subRangeMap(Range.closed(5, 11));
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.closed(9, 10), 2), sub.asMapOfRanges());
    sub.remove(Range.closed(7, 9));
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.openClosed(9, 10), 2),
        sub.asMapOfRanges());
    assertEquals(
        ImmutableMap.of(Range.open(3, 7), 1, Range.openClosed(9, 10), 2, Range.closed(12, 16), 3),
        rangeMap.asMapOfRanges());

    sub.remove(Range.closed(3, 9));
    assertEquals(ImmutableMap.of(Range.openClosed(9, 10), 2), sub.asMapOfRanges());
    assertEquals(
        ImmutableMap.of(Range.open(3, 5), 1, Range.openClosed(9, 10), 2, Range.closed(12, 16), 3),
        rangeMap.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: closed=8 ) - Predicate: of - Scenario: sub (Alternative Scenario: sub=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testSubRangeMapClear
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.open(3, 7), 1);
    rangeMap.put(Range.closed(9, 10), 2);
    rangeMap.put(Range.closed(12, 16), 3);
    RangeMap<Integer, Integer> sub = rangeMap.subRangeMap(Range.closed(5, 11));
    sub.clear();
    assertEquals(
        ImmutableMap.of(Range.open(3, 5), 1, Range.closed(12, 16), 3), rangeMap.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: closed=4 ) - Predicate: of - Scenario: sub (Alternative Scenario: sub=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testSubSubRangeMap
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.open(3, 7), 1);
    rangeMap.put(Range.closed(9, 10), 2);
    rangeMap.put(Range.closed(12, 16), 3);
    RangeMap<Integer, Integer> sub1 = rangeMap.subRangeMap(Range.closed(5, 11));
    assertEquals(
        ImmutableMap.of(Range.closedOpen(5, 7), 1, Range.closed(9, 10), 2), sub1.asMapOfRanges());
    RangeMap<Integer, Integer> sub2 = sub1.subRangeMap(Range.open(6, 15));
    assertEquals(
        ImmutableMap.of(Range.open(6, 7), 1, Range.closed(9, 10), 2), sub2.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: closed=5 ) - Predicate: of - Scenario: sub1 (Alternative Scenario: sub2=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testPutCoalescing
 Body: {
    // {[0..1): 1, [1..2): 1, [2..3): 2} -> {[0..2): 1, [2..3): 2}
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.putCoalescing(Range.closedOpen(0, 1), 1);
    rangeMap.putCoalescing(Range.closedOpen(1, 2), 1);
    rangeMap.putCoalescing(Range.closedOpen(2, 3), 2);
    assertEquals(
        ImmutableMap.of(Range.closedOpen(0, 2), 1, Range.closedOpen(2, 3), 2),
        rangeMap.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putCoalescing (Alternative Action: closedOpen=5 ) - Predicate: of - Scenario: rangeMap (Alternative Scenario: rangeMap=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testPutCoalescingComplex
 Body: {
    // {[0..1): 1, [1..3): 1, [3..5): 1, [7..10): 2, [12..15): 2, [18..19): 3}
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.closedOpen(0, 1), 1);
    rangeMap.put(Range.closedOpen(1, 3), 1);
    rangeMap.put(Range.closedOpen(3, 5), 1);
    rangeMap.put(Range.closedOpen(7, 10), 2);
    rangeMap.put(Range.closedOpen(12, 15), 2);
    rangeMap.put(Range.closedOpen(18, 19), 3);

    rangeMap.putCoalescing(Range.closedOpen(-5, -4), 0); // disconnected
    rangeMap.putCoalescing(Range.closedOpen(-6, -5), 0); // lower than minimum

    rangeMap.putCoalescing(Range.closedOpen(2, 4), 1); // between
    rangeMap.putCoalescing(Range.closedOpen(9, 14), 0); // different value
    rangeMap.putCoalescing(Range.closedOpen(17, 20), 3); // enclosing

    rangeMap.putCoalescing(Range.closedOpen(22, 23), 4); // disconnected
    rangeMap.putCoalescing(Range.closedOpen(23, 25), 4); // greater than minimum

    // {[-6..-4): 0, [0..1): 1, [1..5): 1, [7..9): 2,
    //  [9..14): 0, [14..15): 2, [17..20): 3, [22..25): 4}
    assertEquals(
        new ImmutableMap.Builder<>()
            .put(Range.closedOpen(-6, -4), 0)
            .put(Range.closedOpen(0, 1), 1) // not coalesced
            .put(Range.closedOpen(1, 5), 1)
            .put(Range.closedOpen(7, 9), 2)
            .put(Range.closedOpen(9, 14), 0)
            .put(Range.closedOpen(14, 15), 2)
            .put(Range.closedOpen(17, 20), 3)
            .put(Range.closedOpen(22, 25), 4)
            .build(),
        rangeMap.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: closedOpen=21 ) - Predicate: build - Scenario: rangeMap (Alternative Scenario: rangeMap=1 )

Project: guava
 Class: TreeRangeMapTest
 Method: testPutCoalescingEmpty
 Body: {
    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
    rangeMap.put(Range.closedOpen(0, 1), 1);
    rangeMap.put(Range.closedOpen(1, 2), 1);
    assertEquals(
        ImmutableMap.of(Range.closedOpen(0, 1), 1, Range.closedOpen(1, 2), 1),
        rangeMap.asMapOfRanges());

    rangeMap.putCoalescing(Range.closedOpen(1, 1), 1); // empty range coalesces connected ranges
    assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), rangeMap.asMapOfRanges());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: closedOpen=6 ) - Predicate: of - Scenario: rangeMap (Alternative Scenario: rangeMap=1 )

Project: guava
 Class: AbstractByteHasherTest
 Method: testBytes
 Body: {
    TestHasher hasher = new TestHasher(); // byte order insignificant here
    byte[] expected = {1, 2, 3, 4, 5, 6, 7, 8};
    hasher.putByte((byte) 1);
    hasher.putBytes(new byte[] {2, 3, 4, 5, 6});
    hasher.putByte((byte) 7);
    hasher.putBytes(new byte[] {});
    hasher.putBytes(new byte[] {8});
    hasher.assertBytes(expected);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putByte (Alternative Action: putBytes=3 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: CharSourceTest
 Method: testForEachLine
 Body: {
    source = new TestCharSource(LINES);

    ImmutableList.Builder<String> builder = ImmutableList.builder();
    source.forEachLine(builder::add);

    assertEquals(SPLIT_LINES, builder.build());
    assertTrue(source.wasStreamOpened());
    assertTrue(source.wasStreamClosed());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachLine (Alternative Action: wasStreamClosed=1 ) - Predicate: build - Scenario: builder (Alternative Scenario: builder=1 )

Project: guava
 Class: CharSourceTest
 Method: testCopyToAppendable_doesNotCloseIfWriter
 Body: {
    TestWriter writer = new TestWriter();
    assertFalse(writer.closed());
    source.copyTo(writer);
    assertFalse(writer.closed());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copyTo (Alternative Action: closed=2 ) - Predicate: closed - Scenario: writer (Alternative Scenario: writer=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinMultiInterrupt
 Body: {
    TimedThread thread = TimedThread.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    thread.joinSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinTimeoutMultiInterruptNoExpire
 Body: {
    TimedThread thread = TimedThread.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    thread.joinSuccessfully(LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutSingleInterruptNoExpire
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(50);
    requestInterruptIn(10);
    semaphore.tryAcquireSuccessfully(LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: tryAcquireSuccessfully=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinTimeoutSingleInterruptExpired
 Body: {
    TimedThread thread = TimedThread.createWithDelay(LONG_DELAY_MS);
    requestInterruptIn(10);
    thread.joinUnsuccessfully(50);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: joinUnsuccessfully=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testConditionAwaitInterruptedTimeoutExceeded
 Body: {
    Stopwatch stopwatch = Stopwatch.createStarted();
    Condition condition = TestCondition.create();
    requestInterruptIn(500);

    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 1000, MILLISECONDS);

    assertFalse(signaledBeforeTimeout);
    assertAtLeastTimePassed(stopwatch, 1000);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: createStarted=1 ) - Predicate: N/A - Scenario: signaledBeforeTimeout (Alternative Scenario: signaledBeforeTimeout=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testPutWithNoWait
 Body: {
    Stopwatch stopwatch = Stopwatch.createStarted();
    BlockingQueue<String> queue = new ArrayBlockingQueue<>(999);
    putUninterruptibly(queue, "");
    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
    assertEquals("", queue.peek());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putUninterruptibly (Alternative Action: createStarted=1 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutSingleInterruptNoExpireMultiPermit
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(50);
    requestInterruptIn(10);
    semaphore.tryAcquireSuccessfully(10, LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: tryAcquireSuccessfully=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTakeMultiInterrupt
 Body: {
    TimedTakeQueue queue = TimedTakeQueue.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    queue.takeSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinWithNoWait
 Body: {
    Stopwatch stopwatch = Stopwatch.createStarted();
    Thread thread = new Thread(new JoinTarget(15));
    thread.start();
    thread.join();
    assertFalse(thread.isAlive());

    joinUninterruptibly(thread);
    joinUninterruptibly(thread, 0, MILLISECONDS);
    joinUninterruptibly(thread, -42, MILLISECONDS);
    joinUninterruptibly(thread, LONG_DELAY_MS, MILLISECONDS);
    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: joinUninterruptibly=4 ) - Predicate: isAlive - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutSingleInterruptExpired
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(LONG_DELAY_MS);
    requestInterruptIn(10);
    semaphore.tryAcquireUnsuccessfully(50);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: requestInterruptIn=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutMultiInterruptExpiredMultiPermit
 Body: {
    /*
     * We don't "need" to schedule a release() call at all here, but by doing
     * so, we come the closest we can to testing that the wait time is
     * appropriately decreased on each progressive tryAcquire() call.
     */
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(LONG_DELAY_MS);
    repeatedlyInterruptTestThread(20, tearDownStack);
    semaphore.tryAcquireUnsuccessfully(10, 70);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutMultiInterruptExpired
 Body: {
    /*
     * We don't "need" to schedule a release() call at all here, but by doing
     * so, we come the closest we can to testing that the wait time is
     * appropriately decreased on each progressive tryAcquire() call.
     */
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(LONG_DELAY_MS);
    repeatedlyInterruptTestThread(20, tearDownStack);
    semaphore.tryAcquireUnsuccessfully(70);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testConditionAwaitInterruptedTimeoutNotExceeded
 Body: {
    Stopwatch stopwatch = Stopwatch.createStarted();
    Condition condition = TestCondition.createAndSignalAfter(1000, MILLISECONDS);
    requestInterruptIn(500);

    boolean signaledBeforeTimeout = awaitUninterruptibly(condition, 1500, MILLISECONDS);

    assertTrue(signaledBeforeTimeout);
    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: createStarted=1 ) - Predicate: N/A - Scenario: signaledBeforeTimeout (Alternative Scenario: signaledBeforeTimeout=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinTimeoutSingleInterruptNoExpire
 Body: {
    TimedThread thread = TimedThread.createWithDelay(50);
    requestInterruptIn(10);
    thread.joinSuccessfully(LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: requestInterruptIn=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutSingleInterruptExpiredMultiPermit
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(LONG_DELAY_MS);
    requestInterruptIn(10);
    semaphore.tryAcquireUnsuccessfully(10, 50);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: requestInterruptIn=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinSingleInterrupt
 Body: {
    TimedThread thread = TimedThread.createWithDelay(50);
    requestInterruptIn(10);
    thread.joinSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: requestInterruptIn=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutMultiInterruptNoExpire
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    semaphore.tryAcquireSuccessfully(LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTryAcquireTimeoutMultiInterruptNoExpireMultiPermit
 Body: {
    TimedSemaphore semaphore = TimedSemaphore.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    semaphore.tryAcquireSuccessfully(10, LONG_DELAY_MS);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: semaphore (Alternative Scenario: semaphore=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testPutMultiInterrupt
 Body: {
    TimedPutQueue queue = TimedPutQueue.createWithDelay(100);
    repeatedlyInterruptTestThread(20, tearDownStack);
    queue.putSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testJoinTimeoutMultiInterruptExpired
 Body: {
    /*
     * We don't "need" to schedule a thread completion at all here, but by doing
     * so, we come the closest we can to testing that the wait time is
     * appropriately decreased on each progressive join() call.
     */
    TimedThread thread = TimedThread.createWithDelay(LONG_DELAY_MS);
    repeatedlyInterruptTestThread(20, tearDownStack);
    thread.joinUnsuccessfully(70);
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: repeatedlyInterruptTestThread (Alternative Action: repeatedlyInterruptTestThread=1 ) - Predicate: N/A - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testTakeSingleInterrupt
 Body: {
    TimedTakeQueue queue = TimedTakeQueue.createWithDelay(50);
    requestInterruptIn(10);
    queue.takeSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: requestInterruptIn=1 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: UninterruptiblesTest
 Method: testPutSingleInterrupt
 Body: {
    TimedPutQueue queue = TimedPutQueue.createWithDelay(50);
    requestInterruptIn(10);
    queue.putSuccessfully();
    assertInterrupted();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: requestInterruptIn (Alternative Action: putSuccessfully=1 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: TreeRowTest
 Method: testClearSubMapOfRowMap
 Body: {
      TreeBasedTable<String, String, String> table = TreeBasedTable.create();
      table.put("a", "b", "c");
      table.put("c", "b", "a");
      table.put("b", "b", "x");
      table.put("b", "c", "y");
      table.put("b", "x", "n");
      table.put("a", "a", "d");
      table.row("b").subMap("c", "x").clear();
      assertEquals(table.row("b"), ImmutableMap.of("b", "x", "x", "n"));
      table.row("b").subMap("b", "y").clear();
      assertEquals(table.row("b"), ImmutableMap.of());
      assertFalse(table.backingMap.containsKey("b"));
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: row - Scenario: table (Alternative Scenario: table=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testMultipleUpdates
 Body: {
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(SHA1_KEY);
    mac.update("hello".getBytes(UTF_8));
    mac.update("world".getBytes(UTF_8));

    assertEquals(
        HashCode.fromBytes(mac.doFinal()),
        Hashing.hmacSha1(SHA1_KEY)
            .newHasher()
            .putString("hello", UTF_8)
            .putString("world", UTF_8)
            .hash());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: putString=2 ) - Predicate: fromBytes - Scenario: mac (Alternative Scenario: mac=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testMultipleUpdatesDoFinal
 Body: {
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(SHA1_KEY);
    mac.update("hello".getBytes(UTF_8));
    mac.update("world".getBytes(UTF_8));

    assertEquals(
        HashCode.fromBytes(mac.doFinal("!!!".getBytes(UTF_8))),
        Hashing.hmacSha1(SHA1_KEY)
            .newHasher()
            .putString("hello", UTF_8)
            .putString("world", UTF_8)
            .putString("!!!", UTF_8)
            .hash());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: putString=3 ) - Predicate: fromBytes - Scenario: mac (Alternative Scenario: mac=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testEmptyInputs
 Body: {
    String knownOutput = "8cbf764cbe2e4623d99a41354adfd390";

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(MD5_KEY);
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal()).toString());
    assertEquals(knownOutput, Hashing.hmacMd5(MD5_KEY).newHasher().hash().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: toString=2 ) - Predicate: toString - Scenario: mac (Alternative Scenario: knownOutput=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testKnownInputs_mixedAlgorithms
 Body: {
    String knownOutput = "9753980fe94daa8ecaa82216519393a9";
    String input = "The quick brown fox jumps over the lazy dog";

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(SHA1_KEY);
    mac.update(input.getBytes(UTF_8));
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal()).toString());
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal(input.getBytes(UTF_8))).toString());
    assertEquals(knownOutput, Hashing.hmacMd5(SHA1_KEY).hashString(input, UTF_8).toString());
    assertEquals(
        knownOutput, Hashing.hmacMd5(SHA1_KEY).hashBytes(input.getBytes(UTF_8)).toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: toString=4 ) - Predicate: toString - Scenario: mac (Alternative Scenario: input=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testEmptyInputs_mixedAlgorithms
 Body: {
    String knownOutput = "8cbf764cbe2e4623d99a41354adfd390";

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(SHA1_KEY);
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal()).toString());
    assertEquals(knownOutput, Hashing.hmacMd5(SHA1_KEY).newHasher().hash().toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: toString=2 ) - Predicate: toString - Scenario: mac (Alternative Scenario: knownOutput=1 )

Project: guava
 Class: MacHashFunctionTest
 Method: testKnownInputs
 Body: {
    String knownOutput = "9753980fe94daa8ecaa82216519393a9";
    String input = "The quick brown fox jumps over the lazy dog";

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(MD5_KEY);
    mac.update(input.getBytes(UTF_8));
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal()).toString());
    assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal(input.getBytes(UTF_8))).toString());
    assertEquals(knownOutput, Hashing.hmacMd5(MD5_KEY).hashString(input, UTF_8).toString());
    assertEquals(knownOutput, Hashing.hmacMd5(MD5_KEY).hashBytes(input.getBytes(UTF_8)).toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: init (Alternative Action: toString=4 ) - Predicate: toString - Scenario: mac (Alternative Scenario: input=1 )

Project: guava
 Class: FreshValueGeneratorTest
 Method: testAddSampleInstances_twoInstances
 Body: {
    FreshValueGenerator generator = new FreshValueGenerator();
    generator.addSampleInstances(String.class, ImmutableList.of("a", "b"));
    assertEquals("a", generator.generateFresh(String.class));
    assertEquals("b", generator.generateFresh(String.class));
    assertEquals("a", generator.generateFresh(String.class));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addSampleInstances (Alternative Action: generateFresh=3 ) - Predicate: generateFresh - Scenario: generator (Alternative Scenario: generator=1 )

Project: guava
 Class: FreshValueGeneratorTest
 Method: testAddSampleInstances_oneInstance
 Body: {
    FreshValueGenerator generator = new FreshValueGenerator();
    generator.addSampleInstances(String.class, ImmutableList.of("a"));
    assertEquals("a", generator.generateFresh(String.class));
    assertEquals("a", generator.generateFresh(String.class));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addSampleInstances (Alternative Action: generateFresh=2 ) - Predicate: generateFresh - Scenario: generator (Alternative Scenario: generator=1 )

Project: guava
 Class: BasicTests
 Method: testBuilderAddAll_iterable
 Body: {
      List<String> a = asList("a", "b");
      List<String> b = asList("c", "d");
      ImmutableList<String> list = new ImmutableList.Builder<String>().addAll(a).addAll(b).build();
      assertEquals(asList("a", "b", "c", "d"), list);
      b.set(0, "f");
      assertEquals(asList("a", "b", "c", "d"), list);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=4 ) - Predicate: asList - Scenario: a (Alternative Scenario: a=1 )

Project: guava
 Class: BasicTests
 Method: testBuilderAddAll_iterator
 Body: {
      List<String> a = asList("a", "b");
      List<String> b = asList("c", "d");
      ImmutableList<String> list =
          new ImmutableList.Builder<String>().addAll(a.iterator()).addAll(b.iterator()).build();
      assertEquals(asList("a", "b", "c", "d"), list);
      b.set(0, "f");
      assertEquals(asList("a", "b", "c", "d"), list);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=4 ) - Predicate: asList - Scenario: a (Alternative Scenario: a=1 )

Project: guava
 Class: CharSequenceReaderTest
 Method: testMarkAndReset
 Body: {
    String string = "abcdefghijklmnopqrstuvwxyz";
    CharSequenceReader reader = new CharSequenceReader(string);
    assertTrue(reader.markSupported());

    assertEquals(string, readFully(reader));
    assertFullyRead(reader);

    // reset and read again
    reader.reset();
    assertEquals(string, readFully(reader));
    assertFullyRead(reader);

    // reset, skip, mark, then read the rest
    reader.reset();
    assertEquals(5, reader.skip(5));
    reader.mark(Integer.MAX_VALUE);
    assertEquals(string.substring(5), readFully(reader));
    assertFullyRead(reader);

    // reset to the mark and then read the rest
    reader.reset();
    assertEquals(string.substring(5), readFully(reader));
    assertFullyRead(reader);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: reset (Alternative Action: readFully=4 ) - Predicate: markSupported - Scenario: string (Alternative Scenario: string=1 )

Project: guava
 Class: EndpointPairTest
 Method: endpointPair_containment
 Body: {
    MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(true).build();
    undirectedGraph.putEdge(N1, N1);
    undirectedGraph.putEdge(N1, N2);
    Set<EndpointPair<Integer>> edges = undirectedGraph.edges();

    assertThat(edges).hasSize(2);
    assertThat(edges).contains(EndpointPair.unordered(N1, N1));
    assertThat(edges).contains(EndpointPair.unordered(N1, N2));
    assertThat(edges).contains(EndpointPair.unordered(N2, N1)); // equal to unordered(N1, N2)

    assertThat(edges).doesNotContain(EndpointPair.unordered(N2, N2));
    assertThat(edges).doesNotContain(EndpointPair.ordered(N1, N2)); // graph not directed
    assertThat(edges).doesNotContain(EndpointPair.unordered(N3, N4)); // nodes not in graph
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: unordered=5 ) - Predicate: N/A - Scenario: edges (Alternative Scenario: edges=1 )

Project: guava
 Class: AtomicDoubleTest
 Method: testCompareAndSetInMultipleThreads
 Body: {
    final AtomicDouble at = new AtomicDouble(1.0);
    Thread t =
        newStartedThread(
            new CheckedRunnable() {
              public void realRun() {
                while (!at.compareAndSet(2.0, 3.0)) {
                  Thread.yield();
                }
              }
            });

    assertTrue(at.compareAndSet(1.0, 2.0));
    awaitTermination(t);
    assertBitEquals(3.0, at.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitTermination (Alternative Action: compareAndSet=2 ) - Predicate: compareAndSet - Scenario: at (Alternative Scenario: at=1 )

Project: guava
 Class: AtomicDoubleArrayTest
 Method: testCompareAndSetInMultipleThreads
 Body: {
    final AtomicDoubleArray a = new AtomicDoubleArray(1);
    a.set(0, 1.0);
    Thread t =
        newStartedThread(
            new CheckedRunnable() {
              public void realRun() {
                while (!a.compareAndSet(0, 2.0, 3.0)) {
                  Thread.yield();
                }
              }
            });

    assertTrue(a.compareAndSet(0, 1.0, 2.0));
    awaitTermination(t);
    assertBitEquals(3.0, a.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: compareAndSet=2 ) - Predicate: compareAndSet - Scenario: t (Alternative Scenario: a=1 )

Project: guava
 Class: BytesTest
 Method: testAsList_isAView
 Body: {
    byte[] array = {(byte) 0, (byte) 1};
    List<Byte> list = Bytes.asList(array);
    list.set(0, (byte) 2);
    assertTrue(Arrays.equals(new byte[] {(byte) 2, (byte) 1}, array));
    array[1] = (byte) 3;
    assertEquals(Arrays.asList((byte) 2, (byte) 3), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: BytesTest
 Method: testAsList_toArray_roundTrip
 Body: {
    byte[] array = {(byte) 0, (byte) 1, (byte) 2};
    List<Byte> list = Bytes.asList(array);
    byte[] newArray = Bytes.toArray(list);

    // Make sure it returned a copy
    list.set(0, (byte) 4);
    assertTrue(Arrays.equals(new byte[] {(byte) 0, (byte) 1, (byte) 2}, newArray));
    newArray[1] = (byte) 5;
    assertEquals((byte) 1, (byte) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: BloomFilterTest
 Method: testCollector
 Body: {
    BloomFilter<String> bf1 = BloomFilter.create(Funnels.unencodedCharsFunnel(), 100);
    bf1.put("1");
    bf1.put("2");

    assertEquals(
        bf1,
        Stream.of("1", "2")
            .collect(BloomFilter.toBloomFilter(Funnels.unencodedCharsFunnel(), 100)));
    assertEquals(
        bf1,
        Stream.of("2", "1")
            .collect(BloomFilter.toBloomFilter(Funnels.unencodedCharsFunnel(), 100)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: unencodedCharsFunnel=3 ) - Predicate: collect - Scenario: bf1 (Alternative Scenario: bf1=1 )

Project: guava
 Class: BloomFilterTest
 Method: testPutAll
 Body: {
    int element1 = 1;
    int element2 = 2;

    BloomFilter<Integer> bf1 = BloomFilter.create(Funnels.integerFunnel(), 100);
    bf1.put(element1);
    assertTrue(bf1.mightContain(element1));
    assertFalse(bf1.mightContain(element2));

    BloomFilter<Integer> bf2 = BloomFilter.create(Funnels.integerFunnel(), 100);
    bf2.put(element2);
    assertFalse(bf2.mightContain(element1));
    assertTrue(bf2.mightContain(element2));

    assertTrue(bf1.isCompatible(bf2));
    bf1.putAll(bf2);
    assertTrue(bf1.mightContain(element1));
    assertTrue(bf1.mightContain(element2));
    assertFalse(bf2.mightContain(element1));
    assertTrue(bf2.mightContain(element2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: mightContain=8 ) - Predicate: mightContain - Scenario: bf1 (Alternative Scenario: element1=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceFailWhileStarting
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyFailed(EXCEPTION);
    assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: of=1 ) - Predicate: of - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceFailWhileStopping
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyStarted();
    service.stopAsync();
    service.notifyFailed(EXCEPTION);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: notifyStarted=1 ) - Predicate: of - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStopIdempotenceDoubleWait
 Body: {
    NoOpService service = new NoOpService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.stopAsync().awaitTerminated();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: awaitTerminated=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testAwaitTerminated
 Body: {
    final NoOpService service = new NoOpService();
    Thread waiter =
        new Thread() {
          @Override
          public void run() {
            service.awaitTerminated();
          }
        };
    waiter.start();
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());
    service.stopAsync();
    waiter.join(LONG_TIMEOUT_MILLIS); // ensure that the await in the other thread is triggered
    assertFalse(waiter.isAlive());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: isAlive=1 ) - Predicate: state - Scenario: waiter (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testThreadedServiceStopIdempotenceDoubleWait
 Body: {
    ThreadedService service = new ThreadedService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.awaitRunChecks();

    service.stopAsync().awaitTerminated();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());

    throwIfSet(thrownByExecutionThread);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: awaitTerminated=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testAddListenerAfterFailureDoesntCauseDeadlock
 Body: {
    final StartFailingService service = new StartFailingService();
    service.startAsync();
    assertEquals(State.FAILED, service.state());
    service.addListener(new RecordingListener(service), directExecutor());
    Thread thread =
        new Thread() {
          @Override
          public void run() {
            // Internally stopAsync() grabs a lock, this could be any such method on
            // AbstractService.
            service.stopAsync();
          }
        };
    thread.start();
    thread.join(LONG_TIMEOUT_MILLIS);
    assertFalse(thread + " is deadlocked", thread.isAlive());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: isAlive=1 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceStopWhileNew
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);

    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStartCalled);
    assertFalse(service.doStopCalled);
    assertEquals(ImmutableList.of(State.TERMINATED), listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: stopAsync (Alternative Action: isRunning=1 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testListenerDoesntDeadlockOnStopAndWaitFromTerminated
 Body: {
    final NoOpThreadedService service = new NoOpThreadedService();
    service.addListener(
        new Listener() {
          @Override
          public void terminated(State from) {
            service.stopAsync().awaitTerminated();
          }
        },
        directExecutor());
    service.startAsync().awaitRunning();

    Thread thread =
        new Thread() {
          @Override
          public void run() {
            service.stopAsync().awaitTerminated();
          }
        };
    thread.start();
    thread.join(LONG_TIMEOUT_MILLIS);
    assertFalse(thread + " is deadlocked", thread.isAlive());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: awaitTerminated=2 ) - Predicate: isAlive - Scenario: thread (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceStopMultipleTimesWhileStarting
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    final AtomicInteger stopppingCount = new AtomicInteger();
    service.addListener(
        new Listener() {
          @Override
          public void stopping(State from) {
            stopppingCount.incrementAndGet();
          }
        },
        directExecutor());

    service.startAsync();
    service.stopAsync();
    assertEquals(1, stopppingCount.get());
    service.stopAsync();
    assertEquals(1, stopppingCount.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: get=2 ) - Predicate: get - Scenario: stopppingCount (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceUnrequestedStop
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();

    service.startAsync();

    service.notifyStarted();
    assertEquals(State.RUNNING, service.state());
    assertTrue(service.isRunning());
    assertFalse(service.doStopCalled);

    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: isRunning=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStartAndWaitStopAndWait
 Body: {
    NoOpService service = new NoOpService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStartStop
 Body: {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record(service);

    assertEquals(State.NEW, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.running);

    service.startAsync();
    assertEquals(State.RUNNING, service.state());
    assertTrue(service.isRunning());
    assertTrue(service.running);

    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.running);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: isRunning=3 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceStopWhileStarting
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync();
    assertEquals(State.STARTING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStartCalled);

    service.stopAsync();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);

    service.notifyStarted();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStopCalled);

    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertEquals(
        ImmutableList.of(State.STARTING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: isRunning=4 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceStartStop
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync();
    assertEquals(State.STARTING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStartCalled);

    service.notifyStarted(); // usually this would be invoked by another thread
    assertEquals(State.RUNNING, service.state());
    assertTrue(service.isRunning());

    service.stopAsync();
    assertEquals(State.STOPPING, service.state());
    assertFalse(service.isRunning());
    assertTrue(service.doStopCalled);

    service.notifyStopped(); // usually this would be invoked by another thread
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: isRunning=4 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testThreadedServiceStopIdempotence
 Body: {
    ThreadedService service = new ThreadedService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.awaitRunChecks();

    service.stopAsync();
    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());

    throwIfSet(thrownByExecutionThread);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: stopAsync=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStartAsyncAndAwaitStopAsyncAndAwait
 Body: {
    NoOpService service = new NoOpService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStopIdempotence
 Body: {
    NoOpService service = new NoOpService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.stopAsync();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: stopAsync=2 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testNoOpServiceStopIdempotenceAfterWait
 Body: {
    NoOpService service = new NoOpService();

    service.startAsync().awaitRunning();

    service.stopAsync().awaitTerminated();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: stopAsync=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceNotifyStoppedWhileRunning
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);

    service.startAsync();
    service.notifyStarted();
    service.notifyStopped();
    assertEquals(State.TERMINATED, service.state());
    assertFalse(service.isRunning());
    assertFalse(service.doStopCalled);

    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: notifyStarted=1 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testThreadedServiceStopIdempotenceAfterWait
 Body: {
    ThreadedService service = new ThreadedService();

    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.awaitRunChecks();

    service.stopAsync().awaitTerminated();
    service.stopAsync();
    assertEquals(State.TERMINATED, service.state());

    executionThread.join();

    throwIfSet(thrownByExecutionThread);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: stopAsync=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testManualServiceFailWhileRunning
 Body: {
    ManualSwitchedService service = new ManualSwitchedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync();
    service.notifyStarted();
    service.notifyFailed(EXCEPTION);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: notifyStarted=1 ) - Predicate: of - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testAwaitTerminated_FailedService
 Body: {
    final ManualSwitchedService service = new ManualSwitchedService();
    final AtomicReference<Throwable> exception = Atomics.newReference();
    Thread waiter =
        new Thread() {
          @Override
          public void run() {
            try {
              service.awaitTerminated();
              fail("Expected an IllegalStateException");
            } catch (Throwable t) {
              exception.set(t);
            }
          }
        };
    waiter.start();
    service.startAsync();
    service.notifyStarted();
    assertEquals(State.RUNNING, service.state());
    service.notifyFailed(EXCEPTION);
    assertEquals(State.FAILED, service.state());
    waiter.join(LONG_TIMEOUT_MILLIS);
    assertFalse(waiter.isAlive());
    assertThat(exception.get()).isInstanceOf(IllegalStateException.class);
    assertEquals(EXCEPTION, exception.get().getCause());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: get=2 ) - Predicate: state - Scenario: waiter (Alternative Scenario: exception=1 )

Project: guava
 Class: AbstractServiceTest
 Method: testThreadedServiceStartAndWaitStopAndWait
 Body: {
    ThreadedService service = new ThreadedService();
    RecordingListener listener = RecordingListener.record(service);
    service.startAsync().awaitRunning();
    assertEquals(State.RUNNING, service.state());

    service.awaitRunChecks();

    service.stopAsync().awaitTerminated();
    assertEquals(State.TERMINATED, service.state());

    throwIfSet(thrownByExecutionThread);
    assertEquals(
        ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.TERMINATED),
        listener.getStateHistory());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: state - Scenario: listener (Alternative Scenario: service=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@NullableDecl Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MultisetNavigationTester
 Method: testDescendingNavigation
 Body: {
    List<Entry<E>> ascending = new ArrayList<>();
    Iterators.addAll(ascending, sortedMultiset.entrySet().iterator());
    List<Entry<E>> descending = new ArrayList<>();
    Iterators.addAll(descending, sortedMultiset.descendingMultiset().entrySet().iterator());
    Collections.reverse(descending);
    assertEquals(ascending, descending);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: iterator=2 ) - Predicate: N/A - Scenario: descending (Alternative Scenario: ascending=1 )

Project: guava
 Class: BiMapRemoveTester
 Method: testKeySetIteratorRemove
 Body: {
    int initialSize = getNumElements();
    Iterator<K> iterator = getMap().keySet().iterator();
    iterator.next();
    iterator.remove();
    assertEquals(initialSize - 1, getMap().size());
    assertEquals(initialSize - 1, getMap().inverse().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: getMap=3 ) - Predicate: size - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: SetEqualsTester
 Method: testEquals_containingNull
 Body: {
    Collection<E> elements = getSampleElements(getNumElements() - 1);
    elements.add(null);

    collection = getSubjectGenerator().create(elements.toArray());
    assertTrue(
        "A Set should equal any other Set containing the same elements,"
            + " even if some elements are null.",
        getSet().equals(MinimalSet.from(elements)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: elements (Alternative Scenario: elements=1 )

Project: guava
 Class: SetEqualsTester
 Method: testEquals_otherContainsNull
 Body: {
    Collection<E> elements = getSampleElements(getNumElements() - 1);
    elements.add(null);
    Set<E> other = MinimalSet.from(elements);

    assertFalse(
        "Two Sets should not be equal if exactly one of them contains null.",
        getSet().equals(other));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: equals - Scenario: other (Alternative Scenario: other=1 )

Project: guava
 Class: TreeRowTest
 Method: testClearSubMapOfRowMap
 Body: {
      TreeBasedTable<String, String, String> table = TreeBasedTable.create();
      table.put("a", "b", "c");
      table.put("c", "b", "a");
      table.put("b", "b", "x");
      table.put("b", "c", "y");
      table.put("b", "x", "n");
      table.put("a", "a", "d");
      table.row("b").subMap("c", "x").clear();
      assertEquals(table.row("b"), ImmutableMap.of("b", "x", "x", "n"));
      table.row("b").subMap("b", "y").clear();
      assertEquals(table.row("b"), ImmutableMap.of());
      assertFalse(table.backingMap.containsKey("b"));
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: row - Scenario: table (Alternative Scenario: table=1 )

Project: guava
 Class: MapPutTester
 Method: testPut_nullKeySupportedPresent
 Body: {
    Entry<K, V> newEntry = entry(null, v3());
    initMapWithNullKey();
    assertEquals(
        "put(present, value) should return the associated value",
        getValueForNullKey(),
        put(newEntry));

    Entry<K, V>[] expected = createArrayWithNullKey();
    expected[getNullLocation()] = newEntry;
    expectContents(expected);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initMapWithNullKey (Alternative Action: entry=1 ) - Predicate: getValueForNullKey - Scenario: newEntry (Alternative Scenario: newEntry=1 )

Project: guava
 Class: MapPutTester
 Method: testPut_replaceNullValueWithNonNullSupported
 Body: {
    Entry<K, V> newEntry = entry(getKeyForNullValue(), v3());
    initMapWithNullValue();
    assertNull("put(present, value) should return the associated value (null)", put(newEntry));

    Entry<K, V>[] expected = createArrayWithNullValue();
    expected[getNullLocation()] = newEntry;
    expectContents(expected);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initMapWithNullValue (Alternative Action: entry=1 ) - Predicate: put - Scenario: newEntry (Alternative Scenario: newEntry=1 )

Project: guava
 Class: JdkFutureAdaptersTest
 Method: testListenInPoolThreadCustomExecutorInterrupted
 Body: {
    final CountDownLatch submitSuccessful = new CountDownLatch(1);
    ExecutorService executorService =
        new ThreadPoolExecutor(
            0,
            Integer.MAX_VALUE,
            60L,
            TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>(),
            new ThreadFactoryBuilder().setDaemon(true).build()) {
          @Override
          protected void beforeExecute(Thread t, Runnable r) {
            submitSuccessful.countDown();
          }
        };
    NonListenableSettableFuture<String> abstractFuture = NonListenableSettableFuture.create();
    ListenableFuture<String> listenableFuture = listenInPoolThread(abstractFuture, executorService);

    SingleCallListener singleCallListener = new SingleCallListener();
    singleCallListener.expectCall();

    assertFalse(singleCallListener.wasCalled());
    assertFalse(listenableFuture.isDone());

    listenableFuture.addListener(singleCallListener, directExecutor());
    /*
     * Don't shut down until the listenInPoolThread task has been accepted to
     * run. We want to see what happens when it's interrupted, not when it's
     * rejected.
     */
    submitSuccessful.await();
    executorService.shutdownNow();
    abstractFuture.set(DATA1);
    assertEquals(DATA1, listenableFuture.get());
    singleCallListener.waitForCall();

    assertTrue(singleCallListener.wasCalled());
    assertTrue(listenableFuture.isDone());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectCall (Alternative Action: wasCalled=2 ) - Predicate: wasCalled - Scenario: singleCallListener (Alternative Scenario: abstractFuture=1 )

Project: guava
 Class: JdkFutureAdaptersTest
 Method: testListenInPoolThreadUsesGivenExecutor
 Body: {
    ExecutorService executorService =
        newCachedThreadPool(new ThreadFactoryBuilder().setDaemon(true).build());
    NonListenableSettableFuture<String> abstractFuture = NonListenableSettableFuture.create();
    ExecutorSpy spy = new ExecutorSpy(executorService);
    ListenableFuture<String> listenableFuture = listenInPoolThread(abstractFuture, spy);

    SingleCallListener singleCallListener = new SingleCallListener();
    singleCallListener.expectCall();

    assertFalse(spy.wasExecuted);
    assertFalse(singleCallListener.wasCalled());
    assertFalse(listenableFuture.isDone());

    listenableFuture.addListener(singleCallListener, executorService);
    abstractFuture.set(DATA1);
    assertEquals(DATA1, listenableFuture.get());
    singleCallListener.waitForCall();

    assertTrue(spy.wasExecuted);
    assertTrue(singleCallListener.wasCalled());
    assertTrue(listenableFuture.isDone());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectCall (Alternative Action: wasCalled=2 ) - Predicate: N/A - Scenario: singleCallListener (Alternative Scenario: abstractFuture=1 )

Project: guava
 Class: JdkFutureAdaptersTest
 Method: testListenInPoolThreadIgnoresExecutorWhenDelegateIsDone
 Body: {
    NonListenableSettableFuture<String> abstractFuture = NonListenableSettableFuture.create();
    abstractFuture.set(DATA1);
    ExecutorSpy spy = new ExecutorSpy(directExecutor());
    ListenableFuture<String> listenableFuture = listenInPoolThread(abstractFuture, spy);

    SingleCallListener singleCallListener = new SingleCallListener();
    singleCallListener.expectCall();

    assertFalse(spy.wasExecuted);
    assertFalse(singleCallListener.wasCalled());
    assertTrue(listenableFuture.isDone()); // We call AbstractFuture#set above.

    // #addListener() will run the listener immediately because the Future is
    // already finished (we explicitly set the result of it above).
    listenableFuture.addListener(singleCallListener, directExecutor());
    assertEquals(DATA1, listenableFuture.get());

    // 'spy' should have been ignored since 'abstractFuture' was done before
    // a listener was added.
    assertFalse(spy.wasExecuted);
    assertTrue(singleCallListener.wasCalled());
    assertTrue(listenableFuture.isDone());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectCall (Alternative Action: directExecutor=2 ) - Predicate: N/A - Scenario: singleCallListener (Alternative Scenario: abstractFuture=1 )

Project: guava
 Class: JdkFutureAdaptersTest
 Method: testListenInPoolThreadRunsListenerAfterRuntimeException
 Body: {
    RuntimeExceptionThrowingFuture<String> input = new RuntimeExceptionThrowingFuture<>();
    /*
     * The compiler recognizes that "input instanceof ListenableFuture" is
     * impossible. We want the test, though, in case that changes in the future,
     * so we use isInstance instead.
     */
    assertFalse(
        "Can't test the main listenInPoolThread path "
            + "if the input is already a ListenableFuture",
        ListenableFuture.class.isInstance(input));
    ListenableFuture<String> listenable = listenInPoolThread(input);
    /*
     * This will occur before the waiting get() in the
     * listenInPoolThread-spawned thread completes:
     */
    RecordingRunnable earlyListener = new RecordingRunnable();
    listenable.addListener(earlyListener, directExecutor());

    input.allowGetToComplete.countDown();
    // Now give the get() thread time to finish:
    assertTrue(earlyListener.wasRun.await(1, SECONDS));

    // Now test an additional addListener call, which will be run in-thread:
    RecordingRunnable lateListener = new RecordingRunnable();
    listenable.addListener(lateListener, directExecutor());
    assertTrue(lateListener.wasRun.await(1, SECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: directExecutor=2 ) - Predicate: isInstance - Scenario: input (Alternative Scenario: input=1 )

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testThreadFactory
 Body: {
    final String THREAD_NAME = "ludicrous speed";
    final int THREAD_PRIORITY = 1;
    final boolean THREAD_DAEMON = false;
    ThreadFactory backingThreadFactory =
        new ThreadFactory() {
          @Override
          public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setName(THREAD_NAME);
            thread.setPriority(THREAD_PRIORITY);
            thread.setDaemon(THREAD_DAEMON);
            thread.setUncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER);
            return thread;
          }
        };

    Thread thread =
        builder.setThreadFactory(backingThreadFactory).build().newThread(monitoredRunnable);

    assertEquals(THREAD_NAME, thread.getName());
    assertEquals(THREAD_PRIORITY, thread.getPriority());
    assertEquals(THREAD_DAEMON, thread.isDaemon());
    assertSame(UNCAUGHT_EXCEPTION_HANDLER, thread.getUncaughtExceptionHandler());
    assertSame(Thread.State.NEW, thread.getState());

    assertFalse(completed);
    thread.start();
    thread.join();
    assertTrue(completed);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: setName=1 ) - Predicate: getName - Scenario: THREAD_NAME (Alternative Scenario: thread=2 )

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testBuildMutate
 Body: {
    ThreadFactory factory1 = builder.setPriority(1).build();
    assertEquals(1, factory1.newThread(monitoredRunnable).getPriority());

    builder.setPriority(2); // change the state of the builder
    assertEquals(1, factory1.newThread(monitoredRunnable).getPriority());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setPriority (Alternative Action: newThread=2 ) - Predicate: getPriority - Scenario: factory1 (Alternative Scenario: factory1=1 )

Project: guava
 Class: ThreadFactoryBuilderTest
 Method: testThreadFactoryBuilder_defaults
 Body: {
    ThreadFactory threadFactory = builder.build();
    Thread thread = threadFactory.newThread(monitoredRunnable);
    checkThreadPoolName(thread, 1);

    Thread defaultThread = Executors.defaultThreadFactory().newThread(monitoredRunnable);
    assertEquals(defaultThread.isDaemon(), thread.isDaemon());
    assertEquals(defaultThread.getPriority(), thread.getPriority());
    assertSame(defaultThread.getThreadGroup(), thread.getThreadGroup());
    assertSame(defaultThread.getUncaughtExceptionHandler(), thread.getUncaughtExceptionHandler());

    assertFalse(completed);
    thread.start();
    thread.join();
    assertTrue(completed);

    // Creating a new thread from the same ThreadFactory will have the same
    // pool ID but a thread ID of 2.
    Thread thread2 = threadFactory.newThread(monitoredRunnable);
    checkThreadPoolName(thread2, 2);
    assertEquals(
        thread.getName().substring(0, thread.getName().lastIndexOf('-')),
        thread2.getName().substring(0, thread.getName().lastIndexOf('-')));

    // Building again should give us a different pool ID.
    ThreadFactory threadFactory2 = builder.build();
    Thread thread3 = threadFactory2.newThread(monitoredRunnable);
    checkThreadPoolName(thread3, 1);
    assertThat(thread2.getName().substring(0, thread.getName().lastIndexOf('-')))
        .isNotEqualTo(thread3.getName().substring(0, thread.getName().lastIndexOf('-')));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkThreadPoolName (Alternative Action: getName=8 ) - Predicate: isDaemon - Scenario: defaultThread (Alternative Scenario: threadFactory=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_readFully
 Body: {
    ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
    byte[] actual = new byte[bytes.length];
    in.readFully(actual);
    assertEquals(bytes, actual);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: newDataInput=1 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeInt
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.writeInt(0x12345678);
    out.writeInt(0x76543210);
    assertEquals(bytes, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeInt (Alternative Action: writeInt=2 ) - Predicate: toByteArray - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeFloat
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.writeFloat(Float.intBitsToFloat(0x12345678));
    out.writeFloat(Float.intBitsToFloat(0x76543210));
    assertEquals(bytes, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeFloat (Alternative Action: intBitsToFloat=2 ) - Predicate: toByteArray - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeChars
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.writeChars("r\u00C9sum\u00C9");
    // need to remove byte order mark before comparing
    byte[] expected = Arrays.copyOfRange(utf16ExpectedWithBom, 2, 14);
    assertEquals(expected, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeChars (Alternative Action: copyOfRange=1 ) - Predicate: toByteArray - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_BAOS
 Body: {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ByteArrayDataOutput out = ByteStreams.newDataOutput(baos);
    out.writeInt(0x12345678);
    assertEquals(4, baos.size());
    assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeInt (Alternative Action: writeInt=1 ) - Predicate: size - Scenario: out (Alternative Scenario: baos=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_sized
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput(4);
    out.writeInt(0x12345678);
    out.writeInt(0x76543210);
    assertEquals(bytes, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeInt (Alternative Action: writeInt=2 ) - Predicate: toByteArray - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeByteOffset
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.write(bytes, 4, 2);
    byte[] expected = {bytes[4], bytes[5]};
    assertEquals(expected, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: newDataOutput=1 ) - Predicate: toByteArray - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeByte
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.write(0x12);
    out.writeByte(0x34);
    assertEquals(new byte[] {0x12, 0x34}, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: writeByte=1 ) - Predicate: toByteArray - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_readFullyWithOffset
 Body: {
    ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
    byte[] actual = new byte[4];
    in.readFully(actual, 2, 2);
    assertEquals(0, actual[0]);
    assertEquals(0, actual[1]);
    assertEquals(bytes[0], actual[2]);
    assertEquals(bytes[1], actual[3]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: newDataInput=1 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeBoolean
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.writeBoolean(true);
    out.writeBoolean(false);
    byte[] expected = {(byte) 1, (byte) 0};
    assertEquals(expected, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeBoolean (Alternative Action: writeBoolean=2 ) - Predicate: toByteArray - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataInput_readUTF
 Body: {
    byte[] data = new byte[17];
    data[1] = 15;
    System.arraycopy("Kilroy was here".getBytes(Charsets.UTF_8), 0, data, 2, 15);
    ByteArrayDataInput in = ByteStreams.newDataInput(data);
    assertEquals("Kilroy was here", in.readUTF());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: arraycopy (Alternative Action: newDataInput=1 ) - Predicate: readUTF - Scenario: in (Alternative Scenario: data=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testLimit_mark
 Body: {
    byte[] big = newPreFilledByteArray(5);
    InputStream bin = new ByteArrayInputStream(big);
    InputStream lin = ByteStreams.limit(bin, 2);

    int read = lin.read();
    assertEquals(big[0], read);
    lin.mark(2);

    read = lin.read();
    assertEquals(big[1], read);
    read = lin.read();
    assertEquals(-1, read);

    lin.reset();
    read = lin.read();
    assertEquals(big[1], read);
    read = lin.read();
    assertEquals(-1, read);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: mark (Alternative Action: read=5 ) - Predicate: N/A - Scenario: big (Alternative Scenario: lin=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testLimit
 Body: {
    byte[] big = newPreFilledByteArray(5);
    InputStream bin = new ByteArrayInputStream(big);
    InputStream lin = ByteStreams.limit(bin, 2);

    // also test available
    lin.mark(2);
    assertEquals(2, lin.available());
    int read = lin.read();
    assertEquals(big[0], read);
    assertEquals(1, lin.available());
    read = lin.read();
    assertEquals(big[1], read);
    assertEquals(0, lin.available());
    read = lin.read();
    assertEquals(-1, read);

    lin.reset();
    byte[] small = new byte[5];
    read = lin.read(small);
    assertEquals(2, read);
    assertEquals(big[0], small[0]);
    assertEquals(big[1], small[1]);

    lin.reset();
    read = lin.read(small, 2, 3);
    assertEquals(2, read);
    assertEquals(big[0], small[2]);
    assertEquals(big[1], small[3]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: mark (Alternative Action: read=5 ) - Predicate: available - Scenario: lin (Alternative Scenario: small=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testCopyChannel
 Body: {
    byte[] expected = newPreFilledByteArray(100);
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    WritableByteChannel outChannel = Channels.newChannel(out);

    ReadableByteChannel inChannel = Channels.newChannel(new ByteArrayInputStream(expected));
    ByteStreams.copy(inChannel, outChannel);
    assertEquals(expected, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: newChannel=2 ) - Predicate: toByteArray - Scenario: inChannel (Alternative Scenario: expected=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNewDataOutput_writeUTF
 Body: {
    ByteArrayDataOutput out = ByteStreams.newDataOutput();
    out.writeUTF("r\u00C9sum\u00C9");
    byte[] expected = "r\u00C9sum\u00C9".getBytes(Charsets.UTF_8);
    byte[] actual = out.toByteArray();
    // writeUTF writes the length of the string in 2 bytes
    assertEquals(0, actual[0]);
    assertEquals(expected.length, actual[1]);
    assertEquals(expected, Arrays.copyOfRange(actual, 2, actual.length));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeUTF (Alternative Action: copyOfRange=1 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: actual=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testLimit_skip
 Body: {
    byte[] big = newPreFilledByteArray(5);
    InputStream bin = new ByteArrayInputStream(big);
    InputStream lin = ByteStreams.limit(bin, 2);

    // also test available
    lin.mark(2);
    assertEquals(2, lin.available());
    lin.skip(1);
    assertEquals(1, lin.available());

    lin.reset();
    assertEquals(2, lin.available());
    lin.skip(3);
    assertEquals(0, lin.available());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: mark (Alternative Action: available=4 ) - Predicate: available - Scenario: lin (Alternative Scenario: lin=1 )

Project: guava
 Class: ByteStreamsTest
 Method: testNullOutputStream
 Body: {
    // create a null output stream
    OutputStream nos = ByteStreams.nullOutputStream();
    // write to the output stream
    nos.write('n');
    String test = "Test string for NullOutputStream";
    nos.write(test.getBytes());
    nos.write(test.getBytes(), 2, 10);
    // nothing really to assert?
    assertSame(ByteStreams.nullOutputStream(), ByteStreams.nullOutputStream());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: nullOutputStream=3 ) - Predicate: nullOutputStream - Scenario: test (Alternative Scenario: nos=1 )

Project: guava
 Class: HashingOutputStreamTest
 Method: testHash_hashesCorrectly
 Body: {
    byte[] buf = new byte[] {'y', 'a', 'm', 's'};
    HashCode expectedHash = Hashing.md5().hashBytes(buf);
    HashingOutputStream out = new HashingOutputStream(Hashing.md5(), buffer);

    out.write(buf);

    assertEquals(expectedHash, out.hash());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: md5=2 ) - Predicate: hash - Scenario: out (Alternative Scenario: buf=1 )

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredKeysFilteredReflectsBackingChanges
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      assertEquals(ImmutableMap.of("two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("three", 3, "four", 4), filtered);

      unfiltered.remove("three");
      assertEquals(ImmutableMap.of("two", 2, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("four", 4), filtered);

      unfiltered.clear();
      assertEquals(ImmutableMap.of(), unfiltered);
      assertEquals(ImmutableMap.of(), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: of=6 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredValuesClear
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("one", 1);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      assertEquals(ImmutableMap.of("one", 1, "two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("two", 2, "four", 4), filtered);

      filtered.clear();
      assertEquals(ImmutableMap.of("one", 1, "three", 3), unfiltered);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredEntriesObjectPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Object> predicate = Predicates.alwaysFalse();
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: isEmpty - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: FilteredBiMapTest
 Method: testFilteredEntriesWildCardEntryPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Entry<?, ?>> predicate =
          new Predicate<Entry<?, ?>>() {
            @Override
            public boolean apply(Entry<?, ?> input) {
              return "cat".equals(input.getKey()) || Integer.valueOf(2) == input.getValue();
            }
          };
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertEquals(ImmutableMap.of("cat", 3, "dog", 2), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: MapRemoveTester
 Method: testRemove_nullPresent
 Body: {
    initMapWithNullKey();

    int initialSize = getMap().size();
    assertEquals(
        "remove(null) should return the associated value",
        getValueForNullKey(),
        getMap().remove(null));
    assertEquals(
        "remove(present) should decrease a map's size by one.", initialSize - 1, getMap().size());
    expectMissing(entry(null, getValueForNullKey()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initMapWithNullKey (Alternative Action: getMap=3 ) - Predicate: getValueForNullKey - Scenario: initialSize (Alternative Scenario: initialSize=1 )

Project: guava
 Class: MapRemoveTester
 Method: testRemove_present
 Body: {
    int initialSize = getMap().size();
    assertEquals("remove(present) should return the associated value", v0(), getMap().remove(k0()));
    assertEquals(
        "remove(present) should decrease a map's size by one.", initialSize - 1, getMap().size());
    expectMissing(e0());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectMissing (Alternative Action: getMap=3 ) - Predicate: v0 - Scenario: initialSize (Alternative Scenario: initialSize=1 )

Project: guava
 Class: ConfigurableDirectedMultiNetworkTest
 Method: addEdge_existingSelfLoopEdgeBetweenSameNodes
 Body: {
    addEdge(N1, N1, E11);
    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
    assertThat(addEdge(N1, N1, E11)).isFalse();
    assertThat(network.edges()).containsExactlyElementsIn(edges);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edges=2 ) - Predicate: N/A - Scenario: edges (Alternative Scenario: edges=1 )

Project: guava
 Class: ResourcesTest
 Method: testCopyToOutputStream
 Body: {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    URL resource = getClass().getResource("testdata/i18n.txt");
    Resources.copy(resource, out);
    assertEquals(I18N, out.toString("UTF-8"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: getClass=1 ) - Predicate: toString - Scenario: resource (Alternative Scenario: resource=1 )

Project: guava
 Class: SuppliersTest
 Method: testMemoizeSerializable
 Body: {
    SerializableCountingSupplier countingSupplier = new SerializableCountingSupplier();
    Supplier<Integer> memoizedSupplier = Suppliers.memoize(countingSupplier);
    assertThat(memoizedSupplier.toString()).isEqualTo("Suppliers.memoize(CountingSupplier)");
    checkMemoize(countingSupplier, memoizedSupplier);
    // Calls to the original memoized supplier shouldn't affect its copy.
    memoizedSupplier.get();
    assertThat(memoizedSupplier.toString())
        .isEqualTo("Suppliers.memoize(<supplier that returned 10>)");

    Supplier<Integer> copy = reserialize(memoizedSupplier);
    memoizedSupplier.get();

    CountingSupplier countingCopy =
        (CountingSupplier) ((Suppliers.MemoizingSupplier<Integer>) copy).delegate;
    checkMemoize(countingCopy, copy);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkMemoize (Alternative Action: checkMemoize=2 ) - Predicate: N/A - Scenario: countingSupplier (Alternative Scenario: countingSupplier=1 )

Project: guava
 Class: GraphsTest
 Method: inducedSubgraph_valueGraph
 Body: {
    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);

    MutableValueGraph<Integer, String> directedGraph =
        ValueGraphBuilder.directed().allowsSelfLoops(true).build();
    directedGraph.putEdgeValue(N1, N2, E12);
    directedGraph.putEdgeValue(N2, N1, E21);
    directedGraph.putEdgeValue(N1, N3, E13); // only incident to one node in nodeSubset
    directedGraph.putEdgeValue(N4, N4, E44);
    directedGraph.putEdgeValue(5, 6, "5-6"); // not incident to any node in nodeSubset

    MutableValueGraph<Integer, String> expectedSubgraph =
        ValueGraphBuilder.directed().allowsSelfLoops(true).build();
    expectedSubgraph.putEdgeValue(N1, N2, E12);
    expectedSubgraph.putEdgeValue(N2, N1, E21);
    expectedSubgraph.putEdgeValue(N4, N4, E44);

    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdgeValue (Alternative Action: putEdgeValue=8 ) - Predicate: N/A - Scenario: expectedSubgraph (Alternative Scenario: nodeSubset=1 )

Project: guava
 Class: GraphsTest
 Method: inducedSubgraph_graph
 Body: {
    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);

    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
    directedGraph.putEdge(N1, N2);
    directedGraph.putEdge(N2, N1);
    directedGraph.putEdge(N1, N3); // only incident to one node in nodeSubset
    directedGraph.putEdge(N4, N4);
    directedGraph.putEdge(5, 6); // not incident to any node in nodeSubset

    MutableGraph<Integer> expectedSubgraph = GraphBuilder.directed().allowsSelfLoops(true).build();
    expectedSubgraph.putEdge(N1, N2);
    expectedSubgraph.putEdge(N2, N1);
    expectedSubgraph.putEdge(N4, N4);

    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdge (Alternative Action: putEdge=8 ) - Predicate: N/A - Scenario: expectedSubgraph (Alternative Scenario: nodeSubset=1 )

Project: guava
 Class: GraphsTest
 Method: inducedSubgraph_network
 Body: {
    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);

    MutableNetwork<Integer, String> directedGraph =
        NetworkBuilder.directed().allowsSelfLoops(true).build();
    directedGraph.addEdge(N1, N2, E12);
    directedGraph.addEdge(N2, N1, E21);
    directedGraph.addEdge(N1, N3, E13); // only incident to one node in nodeSubset
    directedGraph.addEdge(N4, N4, E44);
    directedGraph.addEdge(5, 6, "5-6"); // not incident to any node in nodeSubset

    MutableNetwork<Integer, String> expectedSubgraph =
        NetworkBuilder.directed().allowsSelfLoops(true).build();
    expectedSubgraph.addEdge(N1, N2, E12);
    expectedSubgraph.addEdge(N2, N1, E21);
    expectedSubgraph.addEdge(N4, N4, E44);

    assertThat(inducedSubgraph(directedGraph, nodeSubset)).isEqualTo(expectedSubgraph);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: addEdge=8 ) - Predicate: N/A - Scenario: expectedSubgraph (Alternative Scenario: nodeSubset=1 )

Project: guava
 Class: ImmutableMultimapTest
 Method: testBuilder_withMutableEntry
 Body: {
    ImmutableMultimap.Builder<String, Integer> builder = new Builder<>();
    final StringHolder holder = new StringHolder();
    holder.string = "one";
    Entry<String, Integer> entry =
        new AbstractMapEntry<String, Integer>() {
          @Override
          public String getKey() {
            return holder.string;
          }

          @Override
          public Integer getValue() {
            return 1;
          }
        };

    builder.put(entry);
    holder.string = "two";
    assertEquals(Arrays.asList(1), builder.build().get("one"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: build=1 ) - Predicate: asList - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: ForwardingConcurrentMapTest
 Method: testReplaceConditional
 Body: {
    TestMap map = new TestMap();
    map.put("foo", 1);
    assertFalse(map.replace("foo", 2, 3));
    assertFalse(map.replace("bar", 1, 2));
    assertEquals(Integer.valueOf(1), map.get("foo"));
    assertFalse(map.containsKey("bar"));
    assertTrue(map.replace("foo", 1, 4));
    assertEquals(Integer.valueOf(4), map.get("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: replace=3 ) - Predicate: replace - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: ForwardingConcurrentMapTest
 Method: testRemove
 Body: {
    TestMap map = new TestMap();
    map.put("foo", 1);
    assertFalse(map.remove("foo", 2));
    assertFalse(map.remove("bar", 1));
    assertEquals(Integer.valueOf(1), map.get("foo"));
    assertTrue(map.remove("foo", 1));
    assertTrue(map.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=3 ) - Predicate: remove - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: ForwardingConcurrentMapTest
 Method: testPutIfAbsent
 Body: {
    TestMap map = new TestMap();
    map.put("foo", 1);
    assertEquals(Integer.valueOf(1), map.putIfAbsent("foo", 2));
    assertEquals(Integer.valueOf(1), map.get("foo"));
    assertNull(map.putIfAbsent("bar", 3));
    assertEquals(Integer.valueOf(3), map.get("bar"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: valueOf=3 ) - Predicate: valueOf - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: ForwardingConcurrentMapTest
 Method: testReplace
 Body: {
    TestMap map = new TestMap();
    map.put("foo", 1);
    assertEquals(Integer.valueOf(1), map.replace("foo", 2));
    assertNull(map.replace("bar", 3));
    assertEquals(Integer.valueOf(2), map.get("foo"));
    assertFalse(map.containsKey("bar"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: valueOf=2 ) - Predicate: valueOf - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: InternetDomainNameTest
 Method: testParentChild
 Body: {
    InternetDomainName origin = InternetDomainName.from("foo.com");
    InternetDomainName parent = origin.parent();
    assertEquals("com", parent.toString());

    // These would throw an exception if leniency were not preserved during parent() and child()
    // calls.
    InternetDomainName child = parent.child(LOTS_OF_DELTAS);
    child.child(LOTS_OF_DELTAS);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: child (Alternative Action: child=2 ) - Predicate: toString - Scenario: origin (Alternative Scenario: parent=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@Nullable Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@Nullable String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsTransformValuesUnmodifiableIteratorTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MultiReaderTest
 Method: testSkip
 Body: {
    String begin = "abcde";
    String end = "fghij";
    Reader joinedReader = CharSource.concat(newCharSource(begin), newCharSource(end)).openStream();

    String expected = begin + end;
    assertEquals(expected.charAt(0), joinedReader.read());
    CharStreams.skipFully(joinedReader, 1);
    assertEquals(expected.charAt(2), joinedReader.read());
    CharStreams.skipFully(joinedReader, 4);
    assertEquals(expected.charAt(7), joinedReader.read());
    CharStreams.skipFully(joinedReader, 1);
    assertEquals(expected.charAt(9), joinedReader.read());
    assertEquals(-1, joinedReader.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: skipFully (Alternative Action: read=5 ) - Predicate: charAt - Scenario: begin (Alternative Scenario: joinedReader=1 )

Project: guava
 Class: CollectionToArrayTester
 Method: testToArray_emptyArrayOfObject
 Body: {
    Object[] in = new Object[0];
    Object[] array = collection.toArray(in);
    assertEquals(
        "toArray(emptyObject[]) should return an array of type Object",
        Object[].class,
        array.getClass());
    assertEquals("toArray(emptyObject[]).length", getNumElements(), array.length);
    expectArrayContentsAnyOrder(createSamplesArray(), array);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectArrayContentsAnyOrder (Alternative Action: getClass=1 ) - Predicate: getClass - Scenario: in (Alternative Scenario: array=1 )

Project: guava
 Class: CollectionToArrayTester
 Method: testToArray_emptyArray
 Body: {
    E[] empty = getSubjectGenerator().createArray(0);
    E[] array = collection.toArray(empty);
    assertEquals(
        "toArray(emptyT[]) should return an array of type T", empty.getClass(), array.getClass());
    assertEquals("toArray(emptyT[]).length:", getNumElements(), array.length);
    expectArrayContentsAnyOrder(createSamplesArray(), array);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectArrayContentsAnyOrder (Alternative Action: getClass=2 ) - Predicate: getClass - Scenario: empty (Alternative Scenario: array=1 )

Project: guava
 Class: CollectionToArrayTester
 Method: testToArray_emptyArray_ordered
 Body: {
    E[] empty = getSubjectGenerator().createArray(0);
    E[] array = collection.toArray(empty);
    assertEquals(
        "toArray(emptyT[]) should return an array of type T", empty.getClass(), array.getClass());
    assertEquals("toArray(emptyT[]).length:", getNumElements(), array.length);
    expectArrayContentsInOrder(getOrderedElements(), array);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectArrayContentsInOrder (Alternative Action: getClass=2 ) - Predicate: getClass - Scenario: empty (Alternative Scenario: array=1 )

Project: guava
 Class: NullCacheTest
 Method: testGet
 Body: {
    Object computed = new Object();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .maximumSize(0)
            .removalListener(listener)
            .build(constantLoader(computed));

    Object key = new Object();
    assertSame(computed, cache.getUnchecked(key));
    RemovalNotification<Object, Object> notification = listener.remove();
    assertSame(key, notification.getKey());
    assertSame(computed, notification.getValue());
    assertSame(RemovalCause.SIZE, notification.getCause());
    assertTrue(listener.isEmpty());
    checkEmpty(cache);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkEmpty (Alternative Action: getValue=1 ) - Predicate: getUnchecked - Scenario: computed (Alternative Scenario: notification=1 )

Project: guava
 Class: NullCacheTest
 Method: testGet_expireAfterAccess
 Body: {
    Object computed = new Object();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .expireAfterAccess(0, SECONDS)
            .removalListener(listener)
            .build(constantLoader(computed));

    Object key = new Object();
    assertSame(computed, cache.getUnchecked(key));
    RemovalNotification<Object, Object> notification = listener.remove();
    assertSame(key, notification.getKey());
    assertSame(computed, notification.getValue());
    assertSame(RemovalCause.SIZE, notification.getCause());
    assertTrue(listener.isEmpty());
    checkEmpty(cache);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkEmpty (Alternative Action: getValue=1 ) - Predicate: getUnchecked - Scenario: computed (Alternative Scenario: notification=1 )

Project: guava
 Class: NullCacheTest
 Method: testGet_expireAfterWrite
 Body: {
    Object computed = new Object();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder()
            .expireAfterWrite(0, SECONDS)
            .removalListener(listener)
            .build(constantLoader(computed));

    Object key = new Object();
    assertSame(computed, cache.getUnchecked(key));
    RemovalNotification<Object, Object> notification = listener.remove();
    assertSame(key, notification.getKey());
    assertSame(computed, notification.getValue());
    assertSame(RemovalCause.SIZE, notification.getCause());
    assertTrue(listener.isEmpty());
    checkEmpty(cache);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkEmpty (Alternative Action: getValue=1 ) - Predicate: getUnchecked - Scenario: computed (Alternative Scenario: notification=1 )

Project: guava
 Class: ImmutableClassToInstanceMapTest
 Method: testCopyOf_map_valid
 Body: {
    Map<Class<? extends Number>, Number> in = Maps.newHashMap();
    in.put(Number.class, 0);
    in.put(Double.class, Math.PI);
    ClassToInstanceMap<Number> map = ImmutableClassToInstanceMap.copyOf(in);
    assertEquals(2, map.size());

    Number zero = map.getInstance(Number.class);
    assertEquals(0, zero);

    Double pi = map.getInstance(Double.class);
    assertEquals(Math.PI, pi, 0.0);

    assertSame(map, ImmutableClassToInstanceMap.copyOf(map));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: getInstance=2 ) - Predicate: size - Scenario: map (Alternative Scenario: zero=1 )

Project: guava
 Class: FloatsTest
 Method: testAsList_isAView
 Body: {
    float[] array = {(float) 0, (float) 1};
    List<Float> list = Floats.asList(array);
    list.set(0, (float) 2);
    assertTrue(Arrays.equals(new float[] {(float) 2, (float) 1}, array));
    array[1] = (float) 3;
    assertThat(list).containsExactly((float) 2, (float) 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: FloatsTest
 Method: testAsList_toArray_roundTrip
 Body: {
    float[] array = {(float) 0, (float) 1, (float) 2};
    List<Float> list = Floats.asList(array);
    float[] newArray = Floats.toArray(list);

    // Make sure it returned a copy
    list.set(0, (float) 4);
    assertTrue(Arrays.equals(new float[] {(float) 0, (float) 1, (float) 2}, newArray));
    newArray[1] = (float) 5;
    assertEquals((float) 1, (float) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: ClassSanityTesterTest
 Method: testInstantiate_setDistinctValues
 Body: {
    NotInstantiable x = new NotInstantiable();
    NotInstantiable y = new NotInstantiable();
    tester.setDistinctValues(NotInstantiable.class, x, y);
    assertNotNull(tester.instantiate(ConstructorParameterNotInstantiable.class));
    tester.testEquals(ConstructorParameterMapOfNotInstantiable.class);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setDistinctValues (Alternative Action: setDistinctValues=1 ) - Predicate: instantiate - Scenario: y (Alternative Scenario: x=1 )

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_multipleParentsNeeded
 Body: {
    Path path = tempDir.resolve("grandparent/parent/nonexistent.file");
    Path parent = path.getParent();
    Path grandparent = parent.getParent();
    assertFalse(Files.exists(grandparent));
    assertFalse(Files.exists(parent));

    MoreFiles.createParentDirectories(path);
    assertTrue(Files.exists(parent));
    assertTrue(Files.exists(grandparent));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirectories (Alternative Action: exists=4 ) - Predicate: exists - Scenario: path (Alternative Scenario: parent=1 )

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_root
 Body: {
    Path root = root();
    assertNull(root.getParent());
    assertNull(root.toRealPath().getParent());
    MoreFiles.createParentDirectories(root); // test that there's no exception
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirectories (Alternative Action: getParent=2 ) - Predicate: getParent - Scenario: root (Alternative Scenario: root=1 )

Project: guava
 Class: MoreFilesTest
 Method: testPredicates
 Body: {
    Path file = createTempFile();
    Path dir = tempDir.resolve("dir");
    Files.createDirectory(dir);

    assertTrue(MoreFiles.isDirectory().apply(dir));
    assertFalse(MoreFiles.isRegularFile().apply(dir));

    assertFalse(MoreFiles.isDirectory().apply(file));
    assertTrue(MoreFiles.isRegularFile().apply(file));

    Path symlinkToDir = tempDir.resolve("symlinkToDir");
    Path symlinkToFile = tempDir.resolve("symlinkToFile");

    Files.createSymbolicLink(symlinkToDir, dir);
    Files.createSymbolicLink(symlinkToFile, file);

    assertTrue(MoreFiles.isDirectory().apply(symlinkToDir));
    assertFalse(MoreFiles.isRegularFile().apply(symlinkToDir));

    assertFalse(MoreFiles.isDirectory().apply(symlinkToFile));
    assertTrue(MoreFiles.isRegularFile().apply(symlinkToFile));

    assertFalse(MoreFiles.isDirectory(NOFOLLOW_LINKS).apply(symlinkToDir));
    assertFalse(MoreFiles.isRegularFile(NOFOLLOW_LINKS).apply(symlinkToFile));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createDirectory (Alternative Action: apply=10 ) - Predicate: apply - Scenario: dir (Alternative Scenario: file=1 )

Project: guava
 Class: MoreFilesTest
 Method: testTouchTime
 Body: {
    Path temp = createTempFile();
    assertTrue(Files.exists(temp));
    Files.setLastModifiedTime(temp, FileTime.fromMillis(0));
    assertEquals(0, Files.getLastModifiedTime(temp).toMillis());
    MoreFiles.touch(temp);
    assertThat(Files.getLastModifiedTime(temp).toMillis()).isNotEqualTo(0);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setLastModifiedTime (Alternative Action: getLastModifiedTime=2 ) - Predicate: exists - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: MoreFilesTest
 Method: testTouch
 Body: {
    Path temp = createTempFile();
    assertTrue(Files.exists(temp));
    Files.delete(temp);
    assertFalse(Files.exists(temp));
    MoreFiles.touch(temp);
    assertTrue(Files.exists(temp));
    MoreFiles.touch(temp);
    assertTrue(Files.exists(temp));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: delete (Alternative Action: exists=4 ) - Predicate: exists - Scenario: temp (Alternative Scenario: temp=1 )

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_relativePath
 Body: {
    Path path = FS.getPath("nonexistent.file");
    assertNull(path.getParent());
    assertNotNull(path.toAbsolutePath().getParent());
    MoreFiles.createParentDirectories(path); // test that there's no exception
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirectories (Alternative Action: getParent=2 ) - Predicate: getParent - Scenario: path (Alternative Scenario: path=1 )

Project: guava
 Class: MoreFilesTest
 Method: testCreateParentDirectories_oneParentNeeded
 Body: {
    Path path = tempDir.resolve("parent/nonexistent.file");
    Path parent = path.getParent();
    assertFalse(Files.exists(parent));
    MoreFiles.createParentDirectories(path);
    assertTrue(Files.exists(parent));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: createParentDirectories (Alternative Action: exists=2 ) - Predicate: exists - Scenario: path (Alternative Scenario: parent=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOf
 Body: {
      Map<String, Integer> original = new LinkedHashMap<>();
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableBiMap<String, Integer> copy = ImmutableBiMap.copyOf(original);
      assertMapEquals(copy, "one", 1, "two", 2, "three", 3);
      assertSame(copy, ImmutableBiMap.copyOf(copy));
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: CreationTests
 Method: testFromHashMap
 Body: {
      Map<String, Integer> hashMap = Maps.newLinkedHashMap();
      hashMap.put("one", 1);
      hashMap.put("two", 2);
      ImmutableBiMap<String, Integer> bimap =
          ImmutableBiMap.copyOf(ImmutableMap.of("one", 1, "two", 2));
      assertMapEquals(bimap, "one", 1, "two", 2);
      assertMapEquals(bimap.inverse(), 1, "one", 2, "two");
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: N/A - Scenario: bimap (Alternative Scenario: bimap=1 )

Project: guava
 Class: CreationTests
 Method: testBuilderPutAll
 Body: {
      Map<String, Integer> toPut = new LinkedHashMap<>();
      toPut.put("one", 1);
      toPut.put("two", 2);
      toPut.put("three", 3);
      Map<String, Integer> moreToPut = new LinkedHashMap<>();
      moreToPut.put("four", 4);
      moreToPut.put("five", 5);

      ImmutableBiMap<String, Integer> map =
          new Builder<String, Integer>().putAll(toPut).putAll(moreToPut).build();
      assertMapEquals(map, "one", 1, "two", 2, "three", 3, "four", 4, "five", 5);
      assertMapEquals(map.inverse(), 1, "one", 2, "two", 3, "three", 4, "four", 5, "five");
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: map (Alternative Scenario: toPut=1 )

Project: guava
 Class: EscapersTest
 Method: testBuilderRetainsState
 Body: {
    // Setting a safe range and unsafe replacement works as expected.
    Escapers.Builder builder = Escapers.builder();
    builder.setSafeRange('a', 'z');
    builder.setUnsafeReplacement("X");
    assertEquals("XheXXuickXXrownXXoxX", builder.build().escape("The Quick Brown Fox!"));
    // Explicit replacements take priority over unsafe characters.
    builder.addEscape(' ', "_");
    builder.addEscape('!', "_");
    assertEquals("Xhe_Xuick_Xrown_Xox_", builder.build().escape("The Quick Brown Fox!"));
    // Explicit replacements take priority over safe characters.
    builder.setSafeRange(' ', '~');
    assertEquals("The_Quick_Brown_Fox_", builder.build().escape("The Quick Brown Fox!"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setSafeRange (Alternative Action: build=3 ) - Predicate: escape - Scenario: builder (Alternative Scenario: builder=1 )

Project: guava
 Class: EscapersTest
 Method: testBuilderCreatesIndependentEscapers
 Body: {
    // Setup a simple builder and create the first escaper.
    Escapers.Builder builder = Escapers.builder();
    builder.setSafeRange('a', 'z');
    builder.setUnsafeReplacement("X");
    builder.addEscape(' ', "_");
    Escaper first = builder.build();
    // Modify one of the existing mappings before creating a new escaper.
    builder.addEscape(' ', "-");
    builder.addEscape('!', "$");
    Escaper second = builder.build();
    // This should have no effect on existing escapers.
    builder.addEscape(' ', "*");

    // Test both escapers after modifying the builder.
    assertEquals("Xhe_Xuick_Xrown_XoxX", first.escape("The Quick Brown Fox!"));
    assertEquals("Xhe-Xuick-Xrown-Xox$", second.escape("The Quick Brown Fox!"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEscape (Alternative Action: addEscape=4 ) - Predicate: escape - Scenario: second (Alternative Scenario: builder=1 )

Project: guava
 Class: ClassPathTest
 Method: testScanFromFile_fileNotExists
 Body: {
    ClassLoader classLoader = ClassPathTest.class.getClassLoader();
    ClassPath.DefaultScanner scanner = new ClassPath.DefaultScanner();
    scanner.scan(new File("no/such/file/anywhere"), classLoader);
    assertThat(scanner.getResources()).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: scan (Alternative Action: getResources=1 ) - Predicate: N/A - Scenario: scanner (Alternative Scenario: classLoader=1 )

Project: guava
 Class: MultisetElementSetTester
 Method: testElementSetReflectsAddAbsent
 Body: {
    Set<E> elementSet = getMultiset().elementSet();
    assertFalse(elementSet.contains(e3()));
    getMultiset().add(e3(), 4);
    assertTrue(elementSet.contains(e3()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: e3=3 ) - Predicate: contains - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: MultisetElementSetTester
 Method: testElementSetReflectsRemove
 Body: {
    Set<E> elementSet = getMultiset().elementSet();
    assertTrue(elementSet.contains(e0()));
    getMultiset().removeAll(Collections.singleton(e0()));
    assertFalse(elementSet.contains(e0()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: removeAll (Alternative Action: e0=3 ) - Predicate: contains - Scenario: elementSet (Alternative Scenario: elementSet=1 )

Project: guava
 Class: MultisetElementSetTester
 Method: testElementSetRemoveDuplicatePropagatesToMultiset
 Body: {
    initThreeCopies();
    int size = getNumElements();
    int expectedSize = size - getMultiset().count(e0());
    Set<E> elementSet = getMultiset().elementSet();
    assertTrue(elementSet.remove(e0()));
    assertEmpty(getMultiset());
    assertEquals(expectedSize, getMultiset().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=4 ) - Predicate: remove - Scenario: size (Alternative Scenario: size=1 )

Project: guava
 Class: StreamsTest
 Method: testConcat_refStream_closeIsPropagated
 Body: {
    AtomicInteger closeCountB = new AtomicInteger(0);
    Stream<String> streamB = Stream.of("b").onClose(closeCountB::incrementAndGet);
    Stream<String> concatenated =
        Streams.concat(Stream.of("a"), streamB, Stream.empty(), Stream.of("c", "d"));
    assertThat(concatenated).containsExactly("a", "b", "c", "d").inOrder();
    concatenated.close();
    Truth.assertThat(closeCountB.get()).isEqualTo(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: close (Alternative Action: of=3 ) - Predicate: N/A - Scenario: closeCountB (Alternative Scenario: concatenated=1 )

Project: guava
 Class: StreamsTest
 Method: testConcat_refStream_closeIsPropagated_Stream_flatMap
 Body: {
    // Just to demonstrate behavior of Stream::flatMap in the standard library
    AtomicInteger closeCountB = new AtomicInteger(0);
    Stream<String> streamB = Stream.of("b").onClose(closeCountB::incrementAndGet);
    Stream<String> concatenated =
        Stream.<Stream<String>>of(Stream.of("a"), streamB, Stream.empty(), Stream.of("c", "d"))
            .flatMap(x -> x);
    assertThat(concatenated).containsExactly("a", "b", "c", "d").inOrder();
    concatenated.close();
    // even without close, see doc for flatMap
    Truth.assertThat(closeCountB.get()).isEqualTo(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: close (Alternative Action: of=4 ) - Predicate: N/A - Scenario: closeCountB (Alternative Scenario: concatenated=1 )

Project: guava
 Class: StreamsTest
 Method: testConcat_refStream_closeIsPropagated_Stream_concat
 Body: {
    // Just to demonstrate behavior of Stream::concat in the standard library
    AtomicInteger closeCountB = new AtomicInteger(0);
    Stream<String> streamB = Stream.of("b").onClose(closeCountB::incrementAndGet);
    Stream<String> concatenated =
        Stream.<Stream<String>>of(Stream.of("a"), streamB, Stream.empty(), Stream.of("c", "d"))
            .reduce(Stream.empty(), Stream::concat);
    assertThat(concatenated).containsExactly("a", "b", "c", "d").inOrder();
    concatenated.close();
    Truth.assertThat(closeCountB.get()).isEqualTo(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: close (Alternative Action: of=4 ) - Predicate: N/A - Scenario: closeCountB (Alternative Scenario: concatenated=1 )

Project: guava
 Class: StreamsTest
 Method: testZip_closeIsPropagated
 Body: {
    AtomicInteger lettersCloseCount = new AtomicInteger();
    Stream<String> letters = Stream.of("a", "b", "c").onClose(lettersCloseCount::incrementAndGet);
    AtomicInteger numbersCloseCount = new AtomicInteger();
    Stream<Integer> numbers = Stream.of(1, 2, 3).onClose(numbersCloseCount::incrementAndGet);

    Stream<String> zipped = Streams.zip(letters, numbers, (a, b) -> a + ":" + b);

    zipped.close();

    Truth.assertThat(lettersCloseCount.get()).isEqualTo(1);
    Truth.assertThat(numbersCloseCount.get()).isEqualTo(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: close (Alternative Action: onClose=2 ) - Predicate: N/A - Scenario: zipped (Alternative Scenario: zipped=1 )

Project: guava
 Class: FluentFutureTest
 Method: testAddCallback
 Body: {
    FluentFuture<String> f = FluentFuture.from(immediateFuture("a"));
    final boolean[] called = new boolean[1];
    f.addCallback(
        new FutureCallback<String>() {
          @Override
          public void onSuccess(String result) {
            called[0] = true;
          }

          @Override
          public void onFailure(Throwable t) {}
        },
        directExecutor());
    assertThat(called[0]).isTrue();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addCallback (Alternative Action: directExecutor=1 ) - Predicate: N/A - Scenario: called (Alternative Scenario: called=1 )

Project: guava
 Class: TopKSelectorTest
 Method: testOfferedFewerThanK
 Body: {
    TopKSelector<Integer> top = TopKSelector.least(10);
    top.offer(3);
    top.offer(5);
    top.offer(2);
    assertThat(top.topK()).containsExactly(2, 3, 5).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: offer (Alternative Action: offer=3 ) - Predicate: N/A - Scenario: top (Alternative Scenario: top=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList_resultInterrupted
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2);

    future2.set(DATA2);
    assertFalse(compound.isDone());
    assertTrue(compound.cancel(true));
    assertTrue(compound.isCancelled());
    assertTrue(future1.isCancelled());
    assertTrue(future1.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: isCancelled=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testCompletionOrderFutureInterruption
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<Long> future2 = SettableFuture.create();
    SettableFuture<Long> future3 = SettableFuture.create();

    ImmutableList<ListenableFuture<Long>> futures =
        inCompletionOrder(ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));
    future2.set(1L);

    futures.get(1).cancel(true);
    futures.get(2).cancel(false);

    assertTrue(future1.isCancelled());
    assertFalse(future1.wasInterrupted());
    assertTrue(future3.isCancelled());
    assertFalse(future3.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: create=3 ) - Predicate: isCancelled - Scenario: futures (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testCatching_resultCancelledBeforeFallback
 Body: {
    SettableFuture<Integer> primary = SettableFuture.create();
    Function<Throwable, Integer> fallback = unexpectedFunction();
    ListenableFuture<Integer> derived =
        catching(primary, Throwable.class, fallback, directExecutor());
    derived.cancel(false);
    assertTrue(primary.isCancelled());
    assertFalse(primary.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: derived (Alternative Scenario: derived=1 )

Project: guava
 Class: FuturesTest
 Method: testSubmitAsync_asyncCallable_returnsInterruptedFuture
 Body: {
    assertThat(Thread.interrupted()).isFalse();
    SettableFuture<Integer> cancelledFuture = SettableFuture.create();
    cancelledFuture.cancel(true);
    assertThat(Thread.interrupted()).isFalse();
    ListenableFuture<Integer> future =
        submitAsync(constantAsyncCallable(cancelledFuture), directExecutor());
    assertThat(future.isDone()).isTrue();
    assertThat(Thread.interrupted()).isFalse();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: interrupted=3 ) - Predicate: N/A - Scenario: cancelledFuture (Alternative Scenario: future=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_partialFailure
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);
    compound.addListener(listener, directExecutor());

    assertFalse(compound.isDone());
    future1.setException(new Throwable("failed1"));
    assertFalse(compound.isDone());
    listener.expectCall();
    future2.set(DATA2);
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(null, DATA2).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: create=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_totalFailure
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);
    compound.addListener(listener, directExecutor());

    assertFalse(compound.isDone());
    future1.setException(new Throwable("failed1"));
    assertFalse(compound.isDone());
    listener.expectCall();
    future2.setException(new Throwable("failed2"));
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(null, null).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: create=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testCancellingADelegatePropagates
 Body: {
    SettableFuture<Long> future1 = SettableFuture.create();
    SettableFuture<Long> future2 = SettableFuture.create();
    SettableFuture<Long> future3 = SettableFuture.create();

    ImmutableList<ListenableFuture<Long>> delegates =
        inCompletionOrder(ImmutableList.<ListenableFuture<Long>>of(future1, future2, future3));

    future1.set(1L);
    // Cannot cancel a complete delegate
    assertFalse(delegates.get(0).cancel(true));
    // Cancel the delegate before the input future is done
    assertTrue(delegates.get(1).cancel(true));
    // Setting the future still works since cancellation didn't propagate
    assertTrue(future2.set(2L));
    // Second check to ensure the input future was not cancelled
    assertEquals((Long) 2L, getDone(future2));

    // All futures are now complete; outstanding inputs are cancelled
    assertTrue(future3.isCancelled());
    assertTrue(future3.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: create=3 ) - Predicate: cancel - Scenario: delegates (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testCatching_resultInterruptedBeforeFallback
 Body: {
    SettableFuture<Integer> primary = SettableFuture.create();
    Function<Throwable, Integer> fallback = unexpectedFunction();
    ListenableFuture<Integer> derived =
        catching(primary, Throwable.class, fallback, directExecutor());
    derived.cancel(true);
    assertTrue(primary.isCancelled());
    assertTrue(primary.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: derived (Alternative Scenario: derived=1 )

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_runnableResult
 Body: {
    final SettableFuture<Integer> futureInteger = SettableFuture.create();
    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
    final String[] result = new String[1];
    Runnable combiner =
        new Runnable() {
          @Override
          public void run() {
            assertTrue(futureInteger.isDone());
            assertTrue(futureBoolean.isDone());
            result[0] =
                createCombinedResult(
                    Futures.getUnchecked(futureInteger), Futures.getUnchecked(futureBoolean));
          }
        };

    ListenableFuture<?> futureResult =
        whenAllComplete(futureInteger, futureBoolean).run(combiner, directExecutor());
    Integer integerPartial = 1;
    futureInteger.set(integerPartial);
    Boolean booleanPartial = true;
    futureBoolean.set(booleanPartial);
    futureResult.get();
    assertEquals(createCombinedResult(integerPartial, booleanPartial), result[0]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=2 ) - Predicate: createCombinedResult - Scenario: booleanPartial (Alternative Scenario: result=1 )

Project: guava
 Class: FuturesTest
 Method: testLazyTransform
 Body: {
    FunctionSpy<Object, String> spy = new FunctionSpy<>(constant("bar"));
    Future<String> input = immediateFuture("foo");
    Future<String> transformed = lazyTransform(input, spy);
    spy.verifyCallCount(0);
    assertEquals("bar", getDone(transformed));
    spy.verifyCallCount(1);
    assertEquals("bar", getDone(transformed));
    spy.verifyCallCount(2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: verifyCallCount (Alternative Action: verifyCallCount=3 ) - Predicate: getDone - Scenario: transformed (Alternative Scenario: input=1 )

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_resultCancelledAfterFallback
 Body: {
    final SettableFuture<Integer> secondary = SettableFuture.create();
    final RuntimeException raisedException = new RuntimeException();
    AsyncFunctionSpy<Throwable, Integer> fallback =
        spy(
            new AsyncFunction<Throwable, Integer>() {
              @Override
              public ListenableFuture<Integer> apply(Throwable t) throws Exception {
                assertThat(t).isSameAs(raisedException);
                return secondary;
              }
            });

    ListenableFuture<Integer> failingFuture = immediateFailedFuture(raisedException);

    ListenableFuture<Integer> derived =
        catchingAsync(failingFuture, Throwable.class, fallback, directExecutor());
    derived.cancel(false);
    assertTrue(secondary.isCancelled());
    assertFalse(secondary.wasInterrupted());
    fallback.verifyCallCount(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: derived (Alternative Scenario: secondary=1 )

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_inputCancelButNotInterruptPropagatesToOutput
 Body: {
    SettableFuture<Foo> f1 = SettableFuture.create();
    final SettableFuture<Bar> secondary = SettableFuture.create();
    AsyncFunction<Foo, Bar> function =
        new AsyncFunction<Foo, Bar>() {
          @Override
          public ListenableFuture<Bar> apply(Foo unused) {
            return secondary;
          }
        };
    ListenableFuture<Bar> f2 = transformAsync(f1, function, directExecutor());
    f1.cancel(true);
    assertTrue(f2.isCancelled());
    /*
     * We might like to propagate interruption, too, but it's not clear that it matters. For now, we
     * test for the behavior that we have today.
     */
    assertFalse(((AbstractFuture<?>) f2).wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: create=2 ) - Predicate: isCancelled - Scenario: f2 (Alternative Scenario: secondary=1 )

Project: guava
 Class: FuturesTest
 Method: testScheduleAsync_asyncCallable_cancelledBeforeCallingFunction
 Body: {
    final AtomicBoolean callableCalled = new AtomicBoolean();
    AsyncCallable<Integer> callable =
        new AsyncCallable<Integer>() {
          @Override
          public ListenableFuture<Integer> call() {
            callableCalled.set(true);
            return immediateFuture(1);
          }
        };
    ScheduledExecutorService executor = newSingleThreadScheduledExecutor();
    // Pause the executor.
    final CountDownLatch beforeFunction = new CountDownLatch(1);
    executor.execute(
        new Runnable() {
          @Override
          public void run() {
            awaitUninterruptibly(beforeFunction);
          }
        });
    ListenableFuture<Integer> future = scheduleAsync(callable, 1, TimeUnit.NANOSECONDS, executor);
    future.cancel(false);

    // Unpause the executor.
    beforeFunction.countDown();
    executor.shutdown();
    assertTrue(executor.awaitTermination(5, SECONDS));

    assertFalse(callableCalled.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: awaitTermination - Scenario: future (Alternative Scenario: callable=1 )

Project: guava
 Class: FuturesTest
 Method: testTransformAsync_asyncFunction_cancelledBeforeApplyingFunction
 Body: {
    final AtomicBoolean functionCalled = new AtomicBoolean();
    AsyncFunction<String, Integer> function =
        new AsyncFunction<String, Integer>() {
          @Override
          public ListenableFuture<Integer> apply(String input) throws Exception {
            functionCalled.set(true);
            return immediateFuture(1);
          }
        };
    SettableFuture<String> inputFuture = SettableFuture.create();
    ExecutorService executor = newSingleThreadExecutor();
    ListenableFuture<Integer> future = transformAsync(inputFuture, function, executor);

    // Pause the executor.
    final CountDownLatch beforeFunction = new CountDownLatch(1);
    executor.execute(
        new Runnable() {
          @Override
          public void run() {
            awaitUninterruptibly(beforeFunction);
          }
        });

    // Cancel the future after making input available.
    inputFuture.set("value");
    future.cancel(false);

    // Unpause the executor.
    beforeFunction.countDown();
    executor.shutdown();
    assertTrue(executor.awaitTermination(5, SECONDS));

    assertFalse(functionCalled.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: execute (Alternative Action: set=2 ) - Predicate: awaitTermination - Scenario: beforeFunction (Alternative Scenario: future=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList_doneFutures
 Body: {
    // Create input and output
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    SettableFuture<String> future3 = SettableFuture.create();

    // Satisfy each input prior to creating compound and check the output
    future1.set(DATA1);
    future2.set(DATA2);
    future3.set(DATA3);

    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);

    // Attach a listener
    SingleCallListener listener = new SingleCallListener();
    listener.expectCall();
    compound.addListener(listener, directExecutor());

    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectCall (Alternative Action: set=3 ) - Predicate: wasCalled - Scenario: listener (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList_emptyArray
 Body: {
    SingleCallListener listener = new SingleCallListener();
    listener.expectCall();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList();
    compound.addListener(listener, directExecutor());
    assertThat(getDone(compound)).isEmpty();
    assertTrue(listener.wasCalled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: allAsList=1 ) - Predicate: N/A - Scenario: compound (Alternative Scenario: listener=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList_emptyList
 Body: {
    SingleCallListener listener = new SingleCallListener();
    listener.expectCall();
    List<ListenableFuture<String>> futures = ImmutableList.of();
    ListenableFuture<List<String>> compound = allAsList(futures);
    compound.addListener(listener, directExecutor());
    assertThat(getDone(compound)).isEmpty();
    assertTrue(listener.wasCalled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: allAsList=1 ) - Predicate: N/A - Scenario: compound (Alternative Scenario: listener=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_resultCancelled
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);

    future2.set(DATA2);
    assertFalse(compound.isDone());
    assertTrue(compound.cancel(false));
    assertTrue(compound.isCancelled());
    assertTrue(future1.isCancelled());
    assertFalse(future1.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: isCancelled=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_resultInterrupted
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);

    future2.set(DATA2);
    assertFalse(compound.isDone());
    assertTrue(compound.cancel(true));
    assertTrue(compound.isCancelled());
    assertTrue(future1.isCancelled());
    assertTrue(future1.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: isCancelled=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList
 Body: {
    // Create input and output
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    SettableFuture<String> future3 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2, future3);

    // Attach a listener
    SingleCallListener listener = new SingleCallListener();
    compound.addListener(listener, directExecutor());

    // Satisfy each input and check the output
    assertFalse(compound.isDone());
    future1.set(DATA1);
    assertFalse(compound.isDone());
    future2.set(DATA2);
    assertFalse(compound.isDone());
    listener.expectCall();
    future3.set(DATA3);
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: set=3 ) - Predicate: isDone - Scenario: listener (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_emptyList
 Body: {
    SingleCallListener listener = new SingleCallListener();
    listener.expectCall();
    List<ListenableFuture<String>> futures = ImmutableList.of();
    ListenableFuture<List<String>> compound = successfulAsList(futures);
    compound.addListener(listener, directExecutor());
    assertThat(getDone(compound)).isEmpty();
    assertTrue(listener.wasCalled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: directExecutor=1 ) - Predicate: N/A - Scenario: compound (Alternative Scenario: listener=1 )

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_resultCancelledBeforeFallback
 Body: {
    SettableFuture<Integer> primary = SettableFuture.create();
    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();
    ListenableFuture<Integer> derived =
        catchingAsync(primary, Throwable.class, fallback, directExecutor());
    derived.cancel(false);
    assertTrue(primary.isCancelled());
    assertFalse(primary.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: derived (Alternative Scenario: derived=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_cancelled
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2);
    compound.addListener(listener, directExecutor());

    assertFalse(compound.isDone());
    future1.cancel(true);
    assertFalse(compound.isDone());
    listener.expectCall();
    future2.set(DATA2);
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(null, DATA2).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: create=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_resultInterruptedBeforeFallback
 Body: {
    SettableFuture<Integer> primary = SettableFuture.create();
    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();
    ListenableFuture<Integer> derived =
        catchingAsync(primary, Throwable.class, fallback, directExecutor());
    derived.cancel(true);
    assertTrue(primary.isCancelled());
    assertTrue(primary.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: derived (Alternative Scenario: derived=1 )

Project: guava
 Class: FuturesTest
 Method: testNonCancellationPropagating_successful
 Body: {
    SettableFuture<Foo> input = SettableFuture.create();
    ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);
    Foo foo = new Foo();

    assertFalse(wrapper.isDone());
    input.set(foo);
    assertTrue(wrapper.isDone());
    assertSame(foo, getDone(wrapper));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: isDone=2 ) - Predicate: isDone - Scenario: input (Alternative Scenario: input=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_mixed
 Body: {
    SingleCallListener listener = new SingleCallListener();
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    SettableFuture<String> future3 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList(future1, future2, future3);
    compound.addListener(listener, directExecutor());

    // First is cancelled, second fails, third succeeds
    assertFalse(compound.isDone());
    future1.cancel(true);
    assertFalse(compound.isDone());
    future2.setException(new Throwable("failed2"));
    assertFalse(compound.isDone());
    listener.expectCall();
    future3.set(DATA3);
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(null, null, DATA3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: create=3 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testSubmitAsync_asyncCallable_cancelledBeforeApplyingFunction
 Body: {
    final AtomicBoolean callableCalled = new AtomicBoolean();
    AsyncCallable<Integer> callable =
        new AsyncCallable<Integer>() {
          @Override
          public ListenableFuture<Integer> call() {
            callableCalled.set(true);
            return immediateFuture(1);
          }
        };
    ExecutorService executor = newSingleThreadExecutor();
    // Pause the executor.
    final CountDownLatch beforeFunction = new CountDownLatch(1);
    executor.execute(
        new Runnable() {
          @Override
          public void run() {
            awaitUninterruptibly(beforeFunction);
          }
        });
    ListenableFuture<Integer> future = submitAsync(callable, executor);
    future.cancel(false);

    // Unpause the executor.
    beforeFunction.countDown();
    executor.shutdown();
    assertTrue(executor.awaitTermination(5, SECONDS));

    assertFalse(callableCalled.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=1 ) - Predicate: awaitTermination - Scenario: future (Alternative Scenario: callable=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList
 Body: {
    // Create input and output
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    SettableFuture<String> future3 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);

    // Attach a listener
    SingleCallListener listener = new SingleCallListener();
    compound.addListener(listener, directExecutor());

    // Satisfy each input and check the output
    assertFalse(compound.isDone());
    future1.set(DATA1);
    assertFalse(compound.isDone());
    future2.set(DATA2);
    assertFalse(compound.isDone());
    listener.expectCall();
    future3.set(DATA3);
    assertTrue(listener.wasCalled());

    List<String> results = getDone(compound);
    assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: set=3 ) - Predicate: isDone - Scenario: listener (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_noLeakInterruption
 Body: {
    final SettableFuture<String> stringFuture = SettableFuture.create();
    AsyncCallable<String> combiner =
        new AsyncCallable<String>() {
          @Override
          public ListenableFuture<String> call() throws Exception {
            return stringFuture;
          }
        };

    ListenableFuture<String> futureResult = whenAllComplete().callAsync(combiner, directExecutor());

    assertThat(Thread.interrupted()).isFalse();
    futureResult.cancel(true);
    assertThat(Thread.interrupted()).isFalse();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: interrupted=2 ) - Predicate: N/A - Scenario: stringFuture (Alternative Scenario: stringFuture=1 )

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_inputRaisesException
 Body: {
    final RuntimeException raisedException = new RuntimeException();
    AsyncFunctionSpy<Throwable, Integer> fallback =
        spy(
            new AsyncFunction<Throwable, Integer>() {
              @Override
              public ListenableFuture<Integer> apply(Throwable t) throws Exception {
                assertThat(t).isSameAs(raisedException);
                return immediateFuture(20);
              }
            });
    ListenableFuture<Integer> failingFuture = immediateFailedFuture(raisedException);
    ListenableFuture<Integer> faultTolerantFuture =
        catchingAsync(failingFuture, Throwable.class, fallback, directExecutor());
    assertEquals(20, getDone(faultTolerantFuture).intValue());
    fallback.verifyCallCount(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: verifyCallCount (Alternative Action: verifyCallCount=1 ) - Predicate: intValue - Scenario: raisedException (Alternative Scenario: raisedException=1 )

Project: guava
 Class: FuturesTest
 Method: testSuccessfulAsList_emptyArray
 Body: {
    SingleCallListener listener = new SingleCallListener();
    listener.expectCall();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = successfulAsList();
    compound.addListener(listener, directExecutor());
    assertThat(getDone(compound)).isEmpty();
    assertTrue(listener.wasCalled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: directExecutor=1 ) - Predicate: N/A - Scenario: compound (Alternative Scenario: listener=1 )

Project: guava
 Class: FuturesTest
 Method: testCatching_inputRaisesException
 Body: {
    final RuntimeException raisedException = new RuntimeException();
    FunctionSpy<Throwable, Integer> fallback =
        spy(
            new Function<Throwable, Integer>() {
              @Override
              public Integer apply(Throwable t) {
                assertThat(t).isSameAs(raisedException);
                return 20;
              }
            });
    ListenableFuture<Integer> failingFuture = immediateFailedFuture(raisedException);
    ListenableFuture<Integer> faultTolerantFuture =
        catching(failingFuture, Throwable.class, fallback, directExecutor());
    assertEquals(20, getDone(faultTolerantFuture).intValue());
    fallback.verifyCallCount(1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: verifyCallCount (Alternative Action: catching=1 ) - Predicate: intValue - Scenario: raisedException (Alternative Scenario: raisedException=1 )

Project: guava
 Class: FuturesTest
 Method: testAllAsList_resultCancelled
 Body: {
    SettableFuture<String> future1 = SettableFuture.create();
    SettableFuture<String> future2 = SettableFuture.create();
    @SuppressWarnings("unchecked") // array is never modified
    ListenableFuture<List<String>> compound = allAsList(future1, future2);

    future2.set(DATA2);
    assertFalse(compound.isDone());
    assertTrue(compound.cancel(false));
    assertTrue(compound.isCancelled());
    assertTrue(future1.isCancelled());
    assertFalse(future1.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: isCancelled=2 ) - Predicate: isDone - Scenario: compound (Alternative Scenario: future1=1 )

Project: guava
 Class: FuturesTest
 Method: testWhenAllComplete_asyncResult
 Body: {
    final SettableFuture<Integer> futureInteger = SettableFuture.create();
    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
    AsyncCallable<String> combiner =
        new AsyncCallable<String>() {
          @Override
          public ListenableFuture<String> call() throws Exception {
            return immediateFuture(
                createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
          }
        };

    ListenableFuture<String> futureResult =
        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
    Integer integerPartial = 1;
    futureInteger.set(integerPartial);
    Boolean booleanPartial = true;
    futureBoolean.set(booleanPartial);
    assertEquals(createCombinedResult(integerPartial, booleanPartial), getDone(futureResult));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: getDone=3 ) - Predicate: createCombinedResult - Scenario: booleanPartial (Alternative Scenario: integerPartial=1 )

Project: guava
 Class: FuturesTest
 Method: testCatchingAsync_fallbackNotReady
 Body: {
    ListenableFuture<Integer> primary = immediateFailedFuture(new Exception());
    final SettableFuture<Integer> secondary = SettableFuture.create();
    AsyncFunction<Throwable, Integer> fallback =
        new AsyncFunction<Throwable, Integer>() {
          @Override
          public ListenableFuture<Integer> apply(Throwable t) {
            return secondary;
          }
        };
    ListenableFuture<Integer> derived =
        catchingAsync(primary, Throwable.class, fallback, directExecutor());
    secondary.set(1);
    assertEquals(1, (int) getDone(derived));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: N/A - Scenario: derived (Alternative Scenario: secondary=1 )

Project: guava
 Class: HashBasedTableTest
 Method: testCreateWithValidSizes
 Body: {
    Table<String, Integer, Character> table1 = HashBasedTable.create(100, 20);
    table1.put("foo", 1, 'a');
    assertEquals((Character) 'a', table1.get("foo", 1));

    Table<String, Integer, Character> table2 = HashBasedTable.create(100, 0);
    table2.put("foo", 1, 'a');
    assertEquals((Character) 'a', table2.get("foo", 1));

    Table<String, Integer, Character> table3 = HashBasedTable.create(0, 20);
    table3.put("foo", 1, 'a');
    assertEquals((Character) 'a', table3.get("foo", 1));

    Table<String, Integer, Character> table4 = HashBasedTable.create(0, 0);
    table4.put("foo", 1, 'a');
    assertEquals((Character) 'a', table4.get("foo", 1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=4 ) - Predicate: get - Scenario: table1 (Alternative Scenario: table4=1 )

Project: guava
 Class: ListMultimapRemoveTester
 Method: testMultimapRemoveDeletesFirstOccurrence
 Body: {
    resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), v1()), mapEntry(k0(), v0()));

    List<V> list = multimap().get(k0());
    multimap().remove(k0(), v0());
    assertContentsInOrder(list, v1(), v0());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: k0=5 ) - Predicate: v1 - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: CacheBuilderTest
 Method: testNullCache
 Body: {
    CountingRemovalListener<Object, Object> listener = countingRemovalListener();
    LoadingCache<Object, Object> nullCache =
        CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());
    assertEquals(0, nullCache.size());
    Object key = new Object();
    assertSame(key, nullCache.getUnchecked(key));
    assertEquals(1, listener.getCount());
    assertEquals(0, nullCache.size());
    CacheTesting.checkEmpty(nullCache.asMap());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkEmpty (Alternative Action: size=2 ) - Predicate: size - Scenario: listener (Alternative Scenario: nullCache=1 )

Project: guava
 Class: CacheBuilderTest
 Method: testRemovalNotification_clear
 Body: {
    // If a clear() happens while a computation is pending, we should not get a removal
    // notification.

    final AtomicBoolean shouldWait = new AtomicBoolean(false);
    final CountDownLatch computingLatch = new CountDownLatch(1);
    CacheLoader<String, String> computingFunction =
        new CacheLoader<String, String>() {
          @Override
          public String load(String key) throws InterruptedException {
            if (shouldWait.get()) {
              computingLatch.await();
            }
            return key;
          }
        };
    QueuingRemovalListener<String, String> listener = queuingRemovalListener();

    final LoadingCache<String, String> cache =
        CacheBuilder.newBuilder()
            .concurrencyLevel(1)
            .removalListener(listener)
            .build(computingFunction);

    // seed the map, so its segment's count > 0
    cache.getUnchecked("a");
    shouldWait.set(true);

    final CountDownLatch computationStarted = new CountDownLatch(1);
    final CountDownLatch computationComplete = new CountDownLatch(1);
    new Thread(
            new Runnable() {
              @Override
              public void run() {
                computationStarted.countDown();
                cache.getUnchecked("b");
                computationComplete.countDown();
              }
            })
        .start();

    // wait for the computingEntry to be created
    computationStarted.await();
    cache.invalidateAll();
    // let the computation proceed
    computingLatch.countDown();
    // don't check cache.size() until we know the get("b") call is complete
    computationComplete.await();

    // At this point, the listener should be holding the seed value (a -> a), and the map should
    // contain the computed value (b -> b), since the clear() happened before the computation
    // completed.
    assertEquals(1, listener.size());
    RemovalNotification<String, String> notification = listener.remove();
    assertEquals("a", notification.getKey());
    assertEquals("a", notification.getValue());
    assertEquals(1, cache.size());
    assertEquals("b", cache.getUnchecked("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: getUnchecked=3 ) - Predicate: size - Scenario: computationComplete (Alternative Scenario: notification=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderOrderValuesBy
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderValuesBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("b", "d", "a", "c").inOrder();
    assertThat(multimap.values()).containsExactly(6, 3, 2, 5, 2, 4).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(6, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutAllMultimap
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", 1);
    toPut.put("bar", 4);
    toPut.put("foo", 2);
    toPut.put("foo", 3);
    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();
    moreToPut.put("foo", 6);
    moreToPut.put("bar", 5);
    moreToPut.put("foo", 7);
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll(toPut);
    builder.putAll(moreToPut);
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: put=7 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: toPut=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutAllMultimapWithDuplicates
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", 1);
    toPut.put("bar", 4);
    toPut.put("foo", 2);
    toPut.put("foo", 1);
    toPut.put("bar", 5);
    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();
    moreToPut.put("foo", 6);
    moreToPut.put("bar", 4);
    moreToPut.put("foo", 7);
    moreToPut.put("foo", 2);
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll(toPut);
    builder.putAll(moreToPut);
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 1, 6, 7, 2), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5, 4), multimap.get("bar"));
    assertEquals(9, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: put=9 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: toPut=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutAllVarargs
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.putAll("foo", 6, 7);
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testCopyOfWithDuplicates
 Body: {
    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();
    input.put("foo", 1);
    input.put("bar", 2);
    input.put("foo", 3);
    input.put("foo", 1);
    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);
    assertEquals(multimap, input);
    assertEquals(input, multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutAllWithDuplicates
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.putAll("foo", 1, 6, 7);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 3, 1, 6, 7), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5), multimap.get("bar"));
    assertEquals(8, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderOrderKeysByDuplicates
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.put("bb", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(
        new Ordering<String>() {
          @Override
          public int compare(String left, String right) {
            return left.length() - right.length();
          }
        });
    builder.put("cc", 4);
    builder.put("a", 2);
    builder.put("bb", 6);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "a", "bb", "cc").inOrder();
    assertThat(multimap.values()).containsExactly(2, 5, 2, 3, 6, 4).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("bb")).containsExactly(3, 6).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testCopyOf
 Body: {
    ArrayListMultimap<String, Integer> input = ArrayListMultimap.create();
    input.put("foo", 1);
    input.put("bar", 2);
    input.put("foo", 3);
    Multimap<String, Integer> multimap = ImmutableListMultimap.copyOf(input);
    assertEquals(multimap, input);
    assertEquals(input, multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderOrderKeysAndValuesBy
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(Collections.reverseOrder());
    builder.orderValuesBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "c", "b", "a").inOrder();
    assertThat(multimap.values()).containsExactly(2, 4, 6, 3, 5, 2).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(6, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutWithDuplicates
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.put("foo", 1);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 3, 1), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5), multimap.get("bar"));
    assertEquals(6, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilder_withMutableEntry
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = new Builder<>();
    final StringHolder holder = new StringHolder();
    holder.string = "one";
    Entry<String, Integer> entry =
        new AbstractMapEntry<String, Integer>() {
          @Override
          public String getKey() {
            return holder.string;
          }

          @Override
          public Integer getValue() {
            return 1;
          }
        };

    builder.put(entry);
    holder.string = "two";
    assertEquals(Arrays.asList(1), builder.build().get("one"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: build=1 ) - Predicate: asList - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderPutAllIterable
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.putAll("foo", Arrays.asList(1, 2, 3));
    builder.putAll("bar", Arrays.asList(4, 5));
    builder.putAll("foo", Arrays.asList(6, 7));
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(Arrays.asList(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(Arrays.asList(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: asList=5 ) - Predicate: asList - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableListMultimapTest
 Method: testBuilderOrderKeysBy
 Body: {
    ImmutableListMultimap.Builder<String, Integer> builder = ImmutableListMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableListMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "c", "b", "a").inOrder();
    assertThat(multimap.values()).containsExactly(2, 4, 3, 6, 5, 2).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(3, 6).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: AbstractBiMapTest
 Method: testIdentityKeySetIteratorRemove
 Body: {
    BiMap<Integer, String> bimap =
        new AbstractBiMap<Integer, String>(
            new IdentityHashMap<Integer, String>(), new IdentityHashMap<String, Integer>()) {};
    bimap.put(1, "one");
    bimap.put(2, "two");
    bimap.put(3, "three");
    Iterator<Integer> iterator = bimap.keySet().iterator();
    iterator.next();
    iterator.next();
    iterator.remove();
    iterator.next();
    iterator.remove();
    assertEquals(1, bimap.size());
    assertEquals(1, bimap.inverse().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: next=3 ) - Predicate: size - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: AbstractBiMapTest
 Method: testIdentityEntrySetIteratorRemove
 Body: {
    BiMap<Integer, String> bimap =
        new AbstractBiMap<Integer, String>(
            new IdentityHashMap<Integer, String>(), new IdentityHashMap<String, Integer>()) {};
    bimap.put(1, "one");
    bimap.put(2, "two");
    bimap.put(3, "three");
    Iterator<Entry<Integer, String>> iterator = bimap.entrySet().iterator();
    iterator.next();
    iterator.next();
    iterator.remove();
    iterator.next();
    iterator.remove();
    assertEquals(1, bimap.size());
    assertEquals(1, bimap.inverse().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: next=3 ) - Predicate: size - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: Collections2Test
 Method: testToStringImplWithNullEntries
 Body: {
    List<String> list = Lists.newArrayList();
    list.add("foo");
    list.add(null);

    assertEquals(list.toString(), Collections2.toStringImpl(list));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: toString - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: FunctionsTest
 Method: testForPredicate
 Body: {
    Function<Object, Boolean> alwaysTrue = Functions.forPredicate(Predicates.alwaysTrue());
    Function<Object, Boolean> alwaysFalse = Functions.forPredicate(Predicates.alwaysFalse());

    assertTrue(alwaysTrue.apply(0));
    assertFalse(alwaysFalse.apply(0));

    new EqualsTester()
        .addEqualityGroup(alwaysTrue, Functions.forPredicate(Predicates.alwaysTrue()))
        .addEqualityGroup(alwaysFalse)
        .addEqualityGroup(Functions.identity())
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: forPredicate=3 ) - Predicate: apply - Scenario: alwaysTrue (Alternative Scenario: alwaysFalse=1 )

Project: guava
 Class: FunctionsTest
 Method: testForMapWithDefault
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("One", 1);
    map.put("Three", 3);
    map.put("Null", null);
    Function<String, Integer> function = Functions.forMap(map, 42);

    assertEquals(1, function.apply("One").intValue());
    assertEquals(42, function.apply("Two").intValue());
    assertEquals(3, function.apply("Three").intValue());
    assertNull(function.apply("Null"));

    new EqualsTester()
        .addEqualityGroup(function, Functions.forMap(map, 42))
        .addEqualityGroup(Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, null))
        .addEqualityGroup(Functions.forMap(map, 43))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: forMap=5 ) - Predicate: intValue - Scenario: function (Alternative Scenario: function=1 )

Project: guava
 Class: FunctionsTest
 Method: testForMapWithDefault_includeSerializable
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("One", 1);
    map.put("Three", 3);
    Function<String, Integer> function = Functions.forMap(map, 42);

    assertEquals(1, function.apply("One").intValue());
    assertEquals(42, function.apply("Two").intValue());
    assertEquals(3, function.apply("Three").intValue());

    new EqualsTester()
        .addEqualityGroup(
            function, Functions.forMap(map, 42), SerializableTester.reserialize(function))
        .addEqualityGroup(Functions.forMap(map))
        .addEqualityGroup(Functions.forMap(map, null))
        .addEqualityGroup(Functions.forMap(map, 43))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: forMap=5 ) - Predicate: intValue - Scenario: function (Alternative Scenario: function=1 )

Project: guava
 Class: FunctionsTest
 Method: testForMapWildCardWithDefault
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("One", 1);
    map.put("Three", 3);
    Number number = Double.valueOf(42);
    Function<String, Number> function = Functions.forMap(map, number);

    assertEquals(1, function.apply("One").intValue());
    assertEquals(number, function.apply("Two"));
    assertEquals(3L, function.apply("Three").longValue());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: apply=3 ) - Predicate: intValue - Scenario: number (Alternative Scenario: number=1 )

Project: guava
 Class: FunctionsTest
 Method: testForSupplier
 Body: {
    Supplier<Integer> supplier = new CountingSupplier();
    Function<Object, Integer> function = Functions.forSupplier(supplier);

    assertEquals(1, (int) function.apply(null));
    assertEquals(2, (int) function.apply("foo"));

    new EqualsTester()
        .addEqualityGroup(function, Functions.forSupplier(supplier))
        .addEqualityGroup(Functions.forSupplier(new CountingSupplier()))
        .addEqualityGroup(Functions.forSupplier(Suppliers.ofInstance(12)))
        .addEqualityGroup(Functions.toStringFunction())
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: forSupplier=4 ) - Predicate: N/A - Scenario: supplier (Alternative Scenario: function=1 )

Project: guava
 Class: FunctionsTest
 Method: testConstant
 Body: {
    Function<Object, Object> f = Functions.<Object>constant("correct");
    assertEquals("correct", f.apply(new Object()));
    assertEquals("correct", f.apply(null));

    Function<Object, String> g = Functions.constant(null);
    assertEquals(null, g.apply(2));
    assertEquals(null, g.apply(null));

    new EqualsTester()
        .addEqualityGroup(f, Functions.constant("correct"))
        .addEqualityGroup(Functions.constant("incorrect"))
        .addEqualityGroup(Functions.toStringFunction())
        .addEqualityGroup(g)
        .testEquals();

    new EqualsTester()
        .addEqualityGroup(g, Functions.constant(null))
        .addEqualityGroup(Functions.constant("incorrect"))
        .addEqualityGroup(Functions.toStringFunction())
        .addEqualityGroup(f)
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: addEqualityGroup=8 ) - Predicate: apply - Scenario: f (Alternative Scenario: f=1 )

Project: guava
 Class: FunctionsTest
 Method: testForMapWithDefault_null
 Body: {
    ImmutableMap<String, Integer> map = ImmutableMap.of("One", 1);
    Function<String, Integer> function = Functions.forMap(map, null);

    assertEquals((Integer) 1, function.apply("One"));
    assertNull(function.apply("Two"));

    // check basic sanity of equals and hashCode
    new EqualsTester()
        .addEqualityGroup(function)
        .addEqualityGroup(Functions.forMap(map, 1))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: addEqualityGroup=2 ) - Predicate: apply - Scenario: map (Alternative Scenario: function=1 )

Project: guava
 Class: FunctionsTest
 Method: testForMapWithDefault_null_compareWithSerializable
 Body: {
    ImmutableMap<String, Integer> map = ImmutableMap.of("One", 1);
    Function<String, Integer> function = Functions.forMap(map, null);

    assertEquals((Integer) 1, function.apply("One"));
    assertNull(function.apply("Two"));

    // check basic sanity of equals and hashCode
    new EqualsTester()
        .addEqualityGroup(function, SerializableTester.reserialize(function))
        .addEqualityGroup(Functions.forMap(map, 1))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: addEqualityGroup=2 ) - Predicate: apply - Scenario: map (Alternative Scenario: function=1 )

Project: guava
 Class: BiMapClearTester
 Method: testClearInverseClears
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    inv.clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: isEmpty=2 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: BiMapClearTester
 Method: testClearClearsInverse
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    getMap().clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: getMap=3 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: BiMapClearTester
 Method: testKeySetClearClearsInverse
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    getMap().keySet().clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: getMap=3 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: BiMapClearTester
 Method: testValuesClearClearsInverse
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    getMap().values().clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: getMap=3 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: BiMapClearTester
 Method: testClearInverseKeySetClears
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    inv.keySet().clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: isEmpty=2 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: BiMapClearTester
 Method: testClearInverseValuesClears
 Body: {
    BiMap<V, K> inv = getMap().inverse();
    inv.values().clear();
    assertTrue(getMap().isEmpty());
    assertTrue(inv.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: isEmpty=2 ) - Predicate: isEmpty - Scenario: inv (Alternative Scenario: inv=1 )

Project: guava
 Class: ShortsTest
 Method: testAsList_toArray_roundTrip
 Body: {
    short[] array = {(short) 0, (short) 1, (short) 2};
    List<Short> list = Shorts.asList(array);
    short[] newArray = Shorts.toArray(list);

    // Make sure it returned a copy
    list.set(0, (short) 4);
    assertTrue(Arrays.equals(new short[] {(short) 0, (short) 1, (short) 2}, newArray));
    newArray[1] = (short) 5;
    assertEquals((short) 1, (short) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: ShortsTest
 Method: testAsList_isAView
 Body: {
    short[] array = {(short) 0, (short) 1};
    List<Short> list = Shorts.asList(array);
    list.set(0, (short) 2);
    assertTrue(Arrays.equals(new short[] {(short) 2, (short) 1}, array));
    array[1] = (short) 3;
    assertEquals(Arrays.asList((short) 2, (short) 3), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: ReentrantEventsTest
 Method: testEventOrderingIsPredictable
 Body: {
    EventProcessor processor = new EventProcessor();
    bus.register(processor);

    EventRecorder recorder = new EventRecorder();
    bus.register(recorder);

    bus.post(FIRST);

    assertEquals(
        "EventRecorder expected events in order",
        Lists.<Object>newArrayList(FIRST, SECOND),
        recorder.eventsReceived);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: register (Alternative Action: register=2 ) - Predicate: newArrayList - Scenario: recorder (Alternative Scenario: recorder=1 )

Project: guava
 Class: ReentrantEventsTest
 Method: testNoReentrantEvents
 Body: {
    ReentrantEventsHater hater = new ReentrantEventsHater();
    bus.register(hater);

    bus.post(FIRST);

    assertEquals(
        "ReentrantEventHater expected 2 events",
        Lists.<Object>newArrayList(FIRST, SECOND),
        hater.eventsReceived);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: register (Alternative Action: newArrayList=1 ) - Predicate: newArrayList - Scenario: hater (Alternative Scenario: hater=1 )

Project: guava
 Class: DoublesTest
 Method: testAsList_toArray_roundTrip
 Body: {
    double[] array = {(double) 0, (double) 1, (double) 2};
    List<Double> list = Doubles.asList(array);
    double[] newArray = Doubles.toArray(list);

    // Make sure it returned a copy
    list.set(0, (double) 4);
    assertTrue(Arrays.equals(new double[] {(double) 0, (double) 1, (double) 2}, newArray));
    newArray[1] = (double) 5;
    assertEquals((double) 1, (double) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: DoublesTest
 Method: testAsList_isAView
 Body: {
    double[] array = {(double) 0, (double) 1};
    List<Double> list = Doubles.asList(array);
    list.set(0, (double) 2);
    assertTrue(Arrays.equals(new double[] {(double) 2, (double) 1}, array));
    array[1] = (double) 3;
    assertThat(list).containsExactly((double) 2, (double) 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: OutsideEventBusTest
 Method: testAnonymous
 Body: {
    final AtomicReference<String> holder = new AtomicReference<>();
    final AtomicInteger deliveries = new AtomicInteger();
    EventBus bus = new EventBus();
    bus.register(
        new Object() {
          @Subscribe
          public void accept(String str) {
            holder.set(str);
            deliveries.incrementAndGet();
          }
        });

    String EVENT = "Hello!";
    bus.post(EVENT);

    assertEquals("Only one event should be delivered.", 1, deliveries.get());
    assertEquals("Correct string should be delivered.", EVENT, holder.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: get=2 ) - Predicate: get - Scenario: EVENT (Alternative Scenario: bus=1 )

Project: guava
 Class: IterablesTest
 Method: testAll
 Body: {
    List<String> list = newArrayList();
    Predicate<String> predicate = Predicates.equalTo("cool");

    assertTrue(Iterables.all(list, predicate));
    list.add("cool");
    assertTrue(Iterables.all(list, predicate));
    list.add("pants");
    assertFalse(Iterables.all(list, predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: all=3 ) - Predicate: all - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: IterablesTest
 Method: testAny
 Body: {
    List<String> list = newArrayList();
    Predicate<String> predicate = Predicates.equalTo("pants");

    assertFalse(Iterables.any(list, predicate));
    list.add("cool");
    assertFalse(Iterables.any(list, predicate));
    list.add("pants");
    assertTrue(Iterables.any(list, predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: any=3 ) - Predicate: any - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: IterablesTest
 Method: testSkip_structurallyModifiedSkipAllList
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterable<String> tail = skip(list, 2);
    list.subList(0, 2).clear();
    assertTrue(Iterables.isEmpty(tail));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: subList=1 ) - Predicate: isEmpty - Scenario: tail (Alternative Scenario: tail=1 )

Project: guava
 Class: IterablesTest
 Method: testSkip_structurallyModifiedSkipSomeList
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterable<String> tail = skip(list, 1);
    list.subList(1, 3).clear();
    list.addAll(0, newArrayList("A", "B", "C"));
    assertThat(tail).containsExactly("B", "C", "a").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: newArrayList=2 ) - Predicate: N/A - Scenario: tail (Alternative Scenario: tail=1 )

Project: guava
 Class: IterablesTest
 Method: testPartition_view
 Body: {
    List<Integer> list = asList(1, 2);
    Iterable<List<Integer>> partitions = Iterables.partition(list, 2);

    // Changes before the partition is retrieved are reflected
    list.set(0, 3);

    Iterator<List<Integer>> iterator = partitions.iterator();

    // Changes before the partition is retrieved are reflected
    list.set(1, 4);

    List<Integer> first = iterator.next();

    // Changes after are not
    list.set(0, 5);

    assertEquals(ImmutableList.of(3, 4), first);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=3 ) - Predicate: of - Scenario: first (Alternative Scenario: partitions=1 )

Project: guava
 Class: IterablesTest
 Method: testSkip_nonStructurallyModifiedList
 Body: {
    List<String> list = newArrayList("a", "b", "c");
    Iterable<String> tail = skip(list, 1);
    Iterator<String> tailIterator = tail.iterator();
    list.set(2, "C");
    assertEquals("b", tailIterator.next());
    assertEquals("C", tailIterator.next());
    assertFalse(tailIterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: next=2 ) - Predicate: next - Scenario: tailIterator (Alternative Scenario: tailIterator=1 )

Project: guava
 Class: IterablesTest
 Method: testSkip_structurallyModifiedSkipAll
 Body: {
    Collection<String> set = newLinkedHashSet(asList("a", "b", "c"));
    Iterable<String> tail = skip(set, 2);
    set.remove("a");
    set.remove("b");
    assertFalse(tail.iterator().hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: remove=2 ) - Predicate: hasNext - Scenario: tail (Alternative Scenario: set=1 )

Project: guava
 Class: IterablesTest
 Method: testSkip_structurallyModifiedSkipSome
 Body: {
    Collection<String> set = newLinkedHashSet(asList("a", "b", "c"));
    Iterable<String> tail = skip(set, 1);
    set.remove("b");
    set.addAll(newArrayList("A", "B", "C"));
    assertThat(tail).containsExactly("c", "A", "B", "C").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: newArrayList=1 ) - Predicate: N/A - Scenario: tail (Alternative Scenario: set=1 )

Project: guava
 Class: IterablesTest
 Method: testConcatIterable
 Body: {
    List<Integer> list1 = newArrayList(1);
    List<Integer> list2 = newArrayList(4);

    @SuppressWarnings("unchecked")
    List<List<Integer>> input = newArrayList(list1, list2);

    Iterable<Integer> result = Iterables.concat(input);
    assertEquals(asList(1, 4), newArrayList(result));

    // Now change the inputs and see result dynamically change as well

    list1.add(2);
    List<Integer> list3 = newArrayList(3);
    input.add(1, list3);

    assertEquals(asList(1, 2, 3, 4), newArrayList(result));
    assertEquals("[1, 2, 3, 4]", result.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: newArrayList=6 ) - Predicate: asList - Scenario: list1 (Alternative Scenario: result=1 )

Project: guava
 Class: IterablesTest
 Method: testIndexOf_genericPredicate
 Body: {
    List<CharSequence> sequences = Lists.newArrayList();
    sequences.add("bob");
    sequences.add(new StringBuilder("charlie"));
    sequences.add(new StringBuffer("henry"));
    sequences.add(new StringBuilder("apple"));
    sequences.add("lemon");

    assertEquals(3, Iterables.indexOf(sequences, STARTSWITH_A));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=5 ) - Predicate: indexOf - Scenario: sequences (Alternative Scenario: sequences=1 )

Project: guava
 Class: ImmutableRangeSetTest
 Method: testSingleBoundedRange
 Body: {
    ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of(Range.closedOpen(1, 5));

    assertThat(rangeSet.asRanges()).contains(Range.closedOpen(1, 5));

    assertTrue(rangeSet.intersects(Range.closed(3, 4)));
    assertTrue(rangeSet.intersects(Range.closedOpen(0, 2)));
    assertTrue(rangeSet.intersects(Range.closedOpen(3, 7)));
    assertTrue(rangeSet.intersects(Range.greaterThan(2)));
    assertFalse(rangeSet.intersects(Range.greaterThan(7)));

    assertTrue(rangeSet.encloses(Range.closed(3, 4)));
    assertTrue(rangeSet.encloses(Range.closedOpen(1, 4)));
    assertTrue(rangeSet.encloses(Range.closedOpen(1, 5)));
    assertFalse(rangeSet.encloses(Range.greaterThan(2)));

    assertTrue(rangeSet.contains(3));
    assertFalse(rangeSet.contains(5));
    assertFalse(rangeSet.contains(0));

    RangeSet<Integer> expectedComplement = TreeRangeSet.create();
    expectedComplement.add(Range.lessThan(1));
    expectedComplement.add(Range.atLeast(5));

    assertEquals(expectedComplement, rangeSet.complement());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: closedOpen=6 ) - Predicate: closedOpen - Scenario: rangeSet (Alternative Scenario: expectedComplement=1 )

Project: guava
 Class: ArrayListMultimapTest
 Method: testRemoveAllRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertTrue(multimap.removeAll("foo") instanceof RandomAccess);
    assertTrue(multimap.removeAll("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: removeAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: ArrayListMultimapTest
 Method: testCreateFromMultimap
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    multimap.put("bar", 2);
    ArrayListMultimap<String, Integer> copy = ArrayListMultimap.create(multimap);
    assertEquals(multimap, copy);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: ArrayListMultimapTest
 Method: testGetRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertTrue(multimap.get("foo") instanceof RandomAccess);
    assertTrue(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: ArrayListMultimapTest
 Method: testReplaceValuesRandomAccess
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 1);
    multimap.put("foo", 3);
    assertTrue(multimap.replaceValues("foo", asList(2, 4)) instanceof RandomAccess);
    assertTrue(multimap.replaceValues("bar", asList(2, 4)) instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: replaceValues=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: ArrayListMultimapTest
 Method: testTrimToSize
 Body: {
    ArrayListMultimap<String, Integer> multimap = ArrayListMultimap.create();
    multimap.put("foo", 1);
    multimap.put("foo", 2);
    multimap.put("bar", 3);
    multimap.trimToSize();
    assertEquals(3, multimap.size());
    assertThat(multimap.get("foo")).containsExactly(1, 2).inOrder();
    assertThat(multimap.get("bar")).contains(3);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: size - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: MultiInputStreamTest
 Method: testSkip
 Body: {
    MultiInputStream multi =
        new MultiInputStream(
            Collections.singleton(
                    new ByteSource() {
                      @Override
                      public InputStream openStream() {
                        return new ByteArrayInputStream(newPreFilledByteArray(0, 50)) {
                          @Override
                          public long skip(long n) {
                            return 0;
                          }
                        };
                      }
                    })
                .iterator());
    assertEquals(0, multi.skip(-1));
    assertEquals(0, multi.skip(-1));
    assertEquals(0, multi.skip(0));
    ByteStreams.skipFully(multi, 20);
    assertEquals(20, multi.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: skipFully (Alternative Action: skip=3 ) - Predicate: skip - Scenario: multi (Alternative Scenario: multi=1 )

Project: guava
 Class: RateLimiterTest
 Method: testTryAcquire_overflow
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertTrue(limiter.tryAcquire(0, MICROSECONDS));
    stopwatch.sleepMillis(100);
    assertTrue(limiter.tryAcquire(Long.MAX_VALUE, MICROSECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=2 ) - Predicate: tryAcquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testTryAcquire_someWaitAllowed
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertTrue(limiter.tryAcquire(0, SECONDS));
    assertTrue(limiter.tryAcquire(200, MILLISECONDS));
    assertFalse(limiter.tryAcquire(100, MILLISECONDS));
    stopwatch.sleepMillis(100);
    assertTrue(limiter.tryAcquire(100, MILLISECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=4 ) - Predicate: tryAcquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testSimpleAcquireEarliestAvailableIsInPast
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertEquals(0.0, limiter.acquire(), EPSILON);
    stopwatch.sleepMillis(400);
    assertEquals(0.0, limiter.acquire(), EPSILON);
    assertEquals(0.0, limiter.acquire(), EPSILON);
    assertEquals(0.2, limiter.acquire(), EPSILON);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: acquire=4 ) - Predicate: acquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testSimpleWeights
 Body: {
    RateLimiter rateLimiter = RateLimiter.create(1.0, stopwatch);
    rateLimiter.acquire(1); // no wait
    rateLimiter.acquire(1); // R1.00, to repay previous
    rateLimiter.acquire(2); // R1.00, to repay previous
    rateLimiter.acquire(4); // R2.00, to repay previous
    rateLimiter.acquire(8); // R4.00, to repay previous
    rateLimiter.acquire(1); // R8.00, to repay previous
    assertEvents("R0.00", "R1.00", "R1.00", "R2.00", "R4.00", "R8.00");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=6 ) - Predicate: N/A - Scenario: rateLimiter (Alternative Scenario: rateLimiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testTryAcquire_noWaitAllowed
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertTrue(limiter.tryAcquire(0, SECONDS));
    assertFalse(limiter.tryAcquire(0, SECONDS));
    assertFalse(limiter.tryAcquire(0, SECONDS));
    stopwatch.sleepMillis(100);
    assertFalse(limiter.tryAcquire(0, SECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=4 ) - Predicate: tryAcquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testInfinity_Bursty
 Body: {
    RateLimiter limiter = RateLimiter.create(Double.POSITIVE_INFINITY, stopwatch);
    limiter.acquire(Integer.MAX_VALUE / 4);
    limiter.acquire(Integer.MAX_VALUE / 2);
    limiter.acquire(Integer.MAX_VALUE);
    assertEvents("R0.00", "R0.00", "R0.00"); // no wait, infinite rate!

    limiter.setRate(2.0);
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    assertEvents(
        "R0.00", // First comes the saved-up burst, which defaults to a 1-second burst (2 requests).
        "R0.00", "R0.00", // Now comes the free request.
        "R0.50", // Now it's 0.5 seconds per request.
        "R0.50");

    limiter.setRate(Double.POSITIVE_INFINITY);
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    assertEvents("R0.50", "R0.00", "R0.00"); // we repay the last request (.5sec), then back to +oo
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=11 ) - Predicate: N/A - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testVerySmallDoubleValues
 Body: {
    RateLimiter rateLimiter = RateLimiter.create(Double.MIN_VALUE, stopwatch);
    assertTrue("Should acquire initial permit", rateLimiter.tryAcquire());
    assertFalse("Should not acquire additional permit", rateLimiter.tryAcquire());
    stopwatch.sleepMillis(5000);
    assertFalse(
        "Should not acquire additional permit even after sleeping", rateLimiter.tryAcquire());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=3 ) - Predicate: tryAcquire - Scenario: rateLimiter (Alternative Scenario: rateLimiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testTryAcquire_negative
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertTrue(limiter.tryAcquire(5, 0, SECONDS));
    stopwatch.sleepMillis(900);
    assertFalse(limiter.tryAcquire(1, Long.MIN_VALUE, SECONDS));
    stopwatch.sleepMillis(100);
    assertTrue(limiter.tryAcquire(1, -1, SECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=3 ) - Predicate: tryAcquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testBurstyAndUpdate
 Body: {
    RateLimiter rateLimiter = RateLimiter.create(1.0, stopwatch);
    rateLimiter.acquire(1); // no wait
    rateLimiter.acquire(1); // R1.00, to repay previous

    rateLimiter.setRate(2.0); // update the rate!

    rateLimiter.acquire(1); // R1.00, to repay previous (the previous was under the old rate!)
    rateLimiter.acquire(2); // R0.50, to repay previous (now the rate takes effect)
    rateLimiter.acquire(4); // R1.00, to repay previous
    rateLimiter.acquire(1); // R2.00, to repay previous
    assertEvents("R0.00", "R1.00", "R1.00", "R0.50", "R1.00", "R2.00");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=6 ) - Predicate: N/A - Scenario: rateLimiter (Alternative Scenario: rateLimiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testSimpleAcquireReturnValues
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    assertEquals(0.0, limiter.acquire(), EPSILON); // R0.00
    stopwatch.sleepMillis(200); // U0.20, we are ready for the next request...
    assertEquals(0.0, limiter.acquire(), EPSILON); // R0.00, ...which is granted immediately
    assertEquals(0.2, limiter.acquire(), EPSILON); // R0.20
    assertEvents("R0.00", "U0.20", "R0.00", "R0.20");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: acquire=3 ) - Predicate: acquire - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testInfinity_WarmUp
 Body: {
    RateLimiter limiter = RateLimiter.create(Double.POSITIVE_INFINITY, 10, SECONDS, 3.0, stopwatch);
    limiter.acquire(Integer.MAX_VALUE / 4);
    limiter.acquire(Integer.MAX_VALUE / 2);
    limiter.acquire(Integer.MAX_VALUE);
    assertEvents("R0.00", "R0.00", "R0.00");

    limiter.setRate(1.0);
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    assertEvents("R0.00", "R1.00", "R1.00");

    limiter.setRate(Double.POSITIVE_INFINITY);
    limiter.acquire();
    limiter.acquire();
    limiter.acquire();
    assertEvents("R1.00", "R0.00", "R0.00");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=9 ) - Predicate: N/A - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testOneSecondBurst
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    stopwatch.sleepMillis(1000); // max capacity reached
    stopwatch.sleepMillis(1000); // this makes no difference
    limiter.acquire(1); // R0.00, since it's the first request

    limiter.acquire(1); // R0.00, from capacity
    limiter.acquire(3); // R0.00, from capacity
    limiter.acquire(1); // R0.00, concluding a burst of 5 permits

    limiter.acquire(); // R0.20, capacity exhausted
    assertEvents(
        "U1.00", "U1.00", "R0.00", "R0.00", "R0.00", "R0.00", // first request and burst
        "R0.20");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: acquire=5 ) - Predicate: N/A - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testDoubleMinValueCanAcquireExactlyOnce
 Body: {
    RateLimiter r = RateLimiter.create(Double.MIN_VALUE, stopwatch);
    assertTrue("Unable to acquire initial permit", r.tryAcquire());
    assertFalse("Capable of acquiring an additional permit", r.tryAcquire());
    stopwatch.sleepMillis(Integer.MAX_VALUE);
    assertFalse("Capable of acquiring an additional permit after sleeping", r.tryAcquire());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleepMillis (Alternative Action: tryAcquire=3 ) - Predicate: tryAcquire - Scenario: r (Alternative Scenario: r=1 )

Project: guava
 Class: RateLimiterTest
 Method: testSimple
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    limiter.acquire(); // R0.00, since it's the first request
    limiter.acquire(); // R0.20
    limiter.acquire(); // R0.20
    assertEvents("R0.00", "R0.20", "R0.20");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=3 ) - Predicate: N/A - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: RateLimiterTest
 Method: testSimpleWithWait
 Body: {
    RateLimiter limiter = RateLimiter.create(5.0, stopwatch);
    limiter.acquire(); // R0.00
    stopwatch.sleepMillis(200); // U0.20, we are ready for the next request...
    limiter.acquire(); // R0.00, ...which is granted immediately
    limiter.acquire(); // R0.20
    assertEvents("R0.00", "U0.20", "R0.00", "R0.20");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: acquire (Alternative Action: acquire=3 ) - Predicate: N/A - Scenario: limiter (Alternative Scenario: limiter=1 )

Project: guava
 Class: FilteredMapTest
 Method: testFilteredKeysFilteredReflectsBackingChanges
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      assertEquals(ImmutableMap.of("two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("three", 3, "four", 4), filtered);

      unfiltered.remove("three");
      assertEquals(ImmutableMap.of("two", 2, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("four", 4), filtered);

      unfiltered.clear();
      assertEquals(ImmutableMap.of(), unfiltered);
      assertEquals(ImmutableMap.of(), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: of=6 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredMapTest
 Method: testFilteredValuesClear
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("one", 1);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      assertEquals(ImmutableMap.of("one", 1, "two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("two", 2, "four", 4), filtered);

      filtered.clear();
      assertEquals(ImmutableMap.of("one", 1, "three", 3), unfiltered);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredMapTest
 Method: testFilteredEntriesObjectPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Object> predicate = Predicates.alwaysFalse();
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: isEmpty - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: FilteredMapTest
 Method: testFilteredEntriesWildCardEntryPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Entry<?, ?>> predicate =
          new Predicate<Entry<?, ?>>() {
            @Override
            public boolean apply(Entry<?, ?> input) {
              return "cat".equals(input.getKey()) || Integer.valueOf(2) == input.getValue();
            }
          };
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertEquals(ImmutableMap.of("cat", 3, "dog", 2), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: FilteredMultimapTest
 Method: testFilterValues
 Body: {
    Multimap<String, Integer> unfiltered = HashMultimap.create();
    unfiltered.put("foo", 55556);
    unfiltered.put("badkey", 1);
    Multimap<String, Integer> filtered = Multimaps.filterValues(unfiltered, VALUE_PREDICATE);
    assertEquals(1, filtered.size());
    assertFalse(filtered.containsEntry("foo", 55556));
    assertTrue(filtered.containsEntry("badkey", 1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsEntry=2 ) - Predicate: size - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredMultimapTest
 Method: testFilterFiltered
 Body: {
    Multimap<String, Integer> unfiltered = HashMultimap.create();
    unfiltered.put("foo", 55556);
    unfiltered.put("badkey", 1);
    unfiltered.put("foo", 1);
    Multimap<String, Integer> keyFiltered = Multimaps.filterKeys(unfiltered, KEY_PREDICATE);
    Multimap<String, Integer> filtered = Multimaps.filterValues(keyFiltered, VALUE_PREDICATE);
    assertEquals(1, filtered.size());
    assertTrue(filtered.containsEntry("foo", 1));
    assertTrue(filtered.keySet().retainAll(Arrays.asList("cat", "dog")));
    assertEquals(0, filtered.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: size - Scenario: keyFiltered (Alternative Scenario: keyFiltered=1 )

Project: guava
 Class: FilteredMultimapTest
 Method: testFilterKeys
 Body: {
    Multimap<String, Integer> unfiltered = HashMultimap.create();
    unfiltered.put("foo", 55556);
    unfiltered.put("badkey", 1);
    Multimap<String, Integer> filtered = Multimaps.filterKeys(unfiltered, KEY_PREDICATE);
    assertEquals(1, filtered.size());
    assertTrue(filtered.containsEntry("foo", 55556));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: size - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FarmHashFingerprint64Test
 Method: testHashFloatIsStable
 Body: {
    // Just a spot check.  Better than nothing.
    Hasher hasher = HASH_FN.newHasher();
    hasher.putFloat(0x01000101f).putFloat(0f);
    assertEquals(0x49f9d18ee8ae1b28L, hasher.hash().asLong());

    hasher = HASH_FN.newHasher();
    hasher.putDouble(0x0000000001000101d);
    assertEquals(0x388ee898bad75cbfL, hasher.hash().asLong());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putFloat (Alternative Action: asLong=2 ) - Predicate: asLong - Scenario: hasher (Alternative Scenario: hasher=1 )

Project: guava
 Class: ImmutableNetworkTest
 Method: edgesConnecting_undirected
 Body: {
    MutableNetwork<String, String> mutableNetwork =
        NetworkBuilder.undirected().allowsSelfLoops(true).build();
    mutableNetwork.addEdge("A", "A", "AA");
    mutableNetwork.addEdge("A", "B", "AB");
    Network<String, String> network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting("A", "A")).containsExactly("AA");
    assertThat(network.edgesConnecting("A", "B")).containsExactly("AB");
    assertThat(network.edgesConnecting("B", "A")).containsExactly("AB");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edgesConnecting=3 ) - Predicate: N/A - Scenario: network (Alternative Scenario: mutableNetwork=1 )

Project: guava
 Class: ImmutableNetworkTest
 Method: immutableNetwork
 Body: {
    MutableNetwork<String, Integer> mutableNetwork = NetworkBuilder.directed().build();
    mutableNetwork.addNode("A");
    ImmutableNetwork<String, Integer> immutableNetwork = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(immutableNetwork.asGraph()).isInstanceOf(ImmutableGraph.class);
    assertThat(immutableNetwork).isNotInstanceOf(MutableNetwork.class);
    assertThat(immutableNetwork).isEqualTo(mutableNetwork);

    mutableNetwork.addNode("B");
    assertThat(immutableNetwork).isNotEqualTo(mutableNetwork);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=2 ) - Predicate: N/A - Scenario: immutableNetwork (Alternative Scenario: immutableNetwork=1 )

Project: guava
 Class: ImmutableNetworkTest
 Method: edgesConnecting_directed
 Body: {
    MutableNetwork<String, String> mutableNetwork =
        NetworkBuilder.directed().allowsSelfLoops(true).build();
    mutableNetwork.addEdge("A", "A", "AA");
    mutableNetwork.addEdge("A", "B", "AB");
    Network<String, String> network = ImmutableNetwork.copyOf(mutableNetwork);

    assertThat(network.edgesConnecting("A", "A")).containsExactly("AA");
    assertThat(network.edgesConnecting("A", "B")).containsExactly("AB");
    assertThat(network.edgesConnecting("B", "A")).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edgesConnecting=3 ) - Predicate: N/A - Scenario: network (Alternative Scenario: mutableNetwork=1 )

Project: guava
 Class: EvictingQueueTest
 Method: testRemainingCapacity_maxSize1
 Body: {
    EvictingQueue<String> queue = EvictingQueue.create(1);
    assertEquals(1, queue.remainingCapacity());
    queue.add("hi");
    assertEquals(0, queue.remainingCapacity());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: remainingCapacity=2 ) - Predicate: remainingCapacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: EvictingQueueTest
 Method: testSerialization
 Body: {
    EvictingQueue<String> original = EvictingQueue.create(5);
    original.add("one");
    original.add("two");
    original.add("three");

    EvictingQueue<String> copy = SerializableTester.reserialize(original);
    assertEquals(copy.maxSize, original.maxSize);
    assertEquals("one", copy.remove());
    assertEquals("two", copy.remove());
    assertEquals("three", copy.remove());
    assertTrue(copy.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: EvictingQueueTest
 Method: testRemainingCapacity_maxSize3
 Body: {
    EvictingQueue<String> queue = EvictingQueue.create(3);
    assertEquals(3, queue.remainingCapacity());
    queue.add("hi");
    assertEquals(2, queue.remainingCapacity());
    queue.add("hi");
    assertEquals(1, queue.remainingCapacity());
    queue.add("hi");
    assertEquals(0, queue.remainingCapacity());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: remainingCapacity=4 ) - Predicate: remainingCapacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_ignoresTypeVariablesByDefault
 Body: {
    TypeToken<?>.TypeSet types = TypeToken.of(new TypeCapture<B>() {}.capture()).getTypes();
    makeUnmodifiable(types)
        .containsExactly(
            TypeToken.of(Interface1.class), TypeToken.of(Class1.class), TypeToken.of(Object.class));
    assertSubtypeFirst(types);
    makeUnmodifiable(types.interfaces()).containsExactly(TypeToken.of(Interface1.class));
    makeUnmodifiable(types.classes())
        .containsExactly(TypeToken.of(Class1.class), TypeToken.of(Object.class))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: containsExactly (Alternative Action: of=7 ) - Predicate: N/A - Scenario: types (Alternative Scenario: types=1 )

Project: guava
 Class: TypeTokenTest
 Method: testTypeResolutionAfterReserialized
 Body: {
    reserialize(new TypeToken<String>() {});
    reserialize(new TypeToken<Map<String, Integer>>() {});
    TypeToken<Map<String, Integer>> reserialized =
        reserialize(new TypeToken<Map<String, Integer>>() {});
    assertEquals(reserialized, substitute(reserialized, String.class));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: reserialize (Alternative Action: reserialize=3 ) - Predicate: substitute - Scenario: reserialized (Alternative Scenario: reserialized=1 )

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_withInterfacesAndSuperclasses
 Body: {
    abstract class Class2 extends Class1 implements Interface12 {}
    abstract class Class3<T> extends Class2 implements Interface3<T> {}
    TypeToken<Class3<String>>.TypeSet types = new TypeToken<Class3<String>>() {}.getTypes();
    makeUnmodifiable(types)
        .containsExactly(
            new TypeToken<Class3<String>>() {},
            new TypeToken<Interface3<String>>() {},
            new TypeToken<Iterable<String>>() {},
            TypeToken.of(Class2.class),
            TypeToken.of(Interface12.class),
            TypeToken.of(Interface1.class),
            TypeToken.of(Interface2.class),
            TypeToken.of(Class1.class),
            TypeToken.of(Object.class));
    makeUnmodifiable(types.interfaces())
        .containsExactly(
            new TypeToken<Interface3<String>>() {},
            TypeToken.of(Interface12.class),
            TypeToken.of(Interface1.class),
            TypeToken.of(Interface2.class),
            new TypeToken<Iterable<String>>() {});
    makeUnmodifiable(types.classes())
        .containsExactly(
            new TypeToken<Class3<String>>() {},
            TypeToken.of(Class2.class),
            TypeToken.of(Class1.class),
            TypeToken.of(Object.class));
    assertSubtypeFirst(types);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: containsExactly (Alternative Action: of=12 ) - Predicate: N/A - Scenario: types (Alternative Scenario: types=1 )

Project: guava
 Class: TypeTokenTest
 Method: testGetTypes_rawTypes_withInterfacesAndSuperclasses
 Body: {
    abstract class Class2 extends Class1 implements Interface12 {}
    abstract class Class3<T> extends Class2 implements Interface3<T> {}
    TypeToken<Class3<String>>.TypeSet types = new TypeToken<Class3<String>>() {}.getTypes();
    makeUnmodifiable(types.rawTypes())
        .containsExactly(
            Class3.class,
            Interface3.class,
            Iterable.class,
            Class2.class,
            Interface12.class,
            Interface1.class,
            Interface2.class,
            Class1.class,
            Object.class);
    makeUnmodifiable(types.interfaces().rawTypes())
        .containsExactly(
            Interface3.class,
            Interface12.class,
            Interface1.class,
            Interface2.class,
            Iterable.class);
    makeUnmodifiable(types.classes().rawTypes())
        .containsExactly(Class3.class, Class2.class, Class1.class, Object.class);
    assertSubtypeFirst(types);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: containsExactly (Alternative Action: containsExactly=3 ) - Predicate: N/A - Scenario: types (Alternative Scenario: types=1 )

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReentrantReadLock_tryLock
 Body: {
    LockingThread thread = new LockingThread(readLockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
    readLockA.unlock();

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: tryLock=4 ) - Predicate: tryLock - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReentrantWriteLock_tryLock
 Body: {
    LockingThread thread = new LockingThread(writeLockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(writeLockA.tryLock());
    assertFalse(readLockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(writeLockA.tryLock());
    assertTrue(readLockA.tryLock());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: tryLock=4 ) - Predicate: tryLock - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: CycleDetectingLockFactoryTest
 Method: testReentrantLock_tryLock
 Body: {
    LockingThread thread = new LockingThread(lockA);
    thread.start();

    thread.waitUntilHoldingLock();
    assertFalse(lockA.tryLock());

    thread.releaseLockAndFinish();
    assertTrue(lockA.tryLock());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: tryLock=2 ) - Predicate: tryLock - Scenario: thread (Alternative Scenario: thread=1 )

Project: guava
 Class: ElementOrderTest
 Method: nodeOrder_sorted
 Body: {
    MutableGraph<Integer> graph =
        GraphBuilder.directed()
            .nodeOrder(ElementOrder.sorted(Ordering.<Integer>natural().reverse()))
            .build();

    addNodes(graph);

    assertThat(graph.nodeOrder())
        .isEqualTo(ElementOrder.sorted(Ordering.<Integer>natural().reverse()));
    assertThat(graph.nodes()).containsExactly(4, 3, 1).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNodes (Alternative Action: sorted=2 ) - Predicate: sorted - Scenario: graph (Alternative Scenario: graph=1 )

Project: guava
 Class: ElementOrderTest
 Method: nodeOrderUnorderedandEdgesSorted
 Body: {
    MutableNetwork<Integer, String> network =
        NetworkBuilder.directed()
            .nodeOrder(unordered())
            .edgeOrder(ElementOrder.sorted(Ordering.<String>natural().reverse()))
            .build();

    addEdges(network);

    assertThat(network.edgeOrder())
        .isEqualTo(ElementOrder.sorted(Ordering.<String>natural().reverse()));
    assertThat(network.edges()).containsExactly("p", "i", "e").inOrder();
    assertThat(network.nodeOrder()).isEqualTo(unordered());
    assertThat(network.nodes()).containsExactly(4, 1, 3);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdges (Alternative Action: unordered=2 ) - Predicate: sorted - Scenario: network (Alternative Scenario: network=1 )

Project: guava
 Class: ElementOrderTest
 Method: edgeOrder_sorted
 Body: {
    MutableNetwork<Integer, String> network =
        NetworkBuilder.directed()
            .edgeOrder(ElementOrder.sorted(Ordering.<String>natural().reverse()))
            .build();

    addEdges(network);

    assertThat(network.edgeOrder())
        .isEqualTo(ElementOrder.sorted(Ordering.<String>natural().reverse()));
    assertThat(network.edges()).containsExactly("p", "i", "e").inOrder();
    assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdges (Alternative Action: sorted=2 ) - Predicate: sorted - Scenario: network (Alternative Scenario: network=1 )

Project: guava
 Class: ElementOrderTest
 Method: nodeOrder_insertion
 Body: {
    MutableGraph<Integer> graph = GraphBuilder.directed().nodeOrder(insertion()).build();

    addNodes(graph);

    assertThat(graph.nodeOrder()).isEqualTo(insertion());
    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNodes (Alternative Action: insertion=2 ) - Predicate: insertion - Scenario: graph (Alternative Scenario: graph=1 )

Project: guava
 Class: ElementOrderTest
 Method: customComparable
 Body: {
    MutableGraph<ComparableSubClass> graph =
        GraphBuilder.undirected().nodeOrder(ElementOrder.<ComparableSubClass>natural()).build();

    ComparableSubClass node2 = new ComparableSubClass(2);
    ComparableSubClass node4 = new ComparableSubClass(4);
    ComparableSubClass node6 = new ComparableSubClass(6);
    ComparableSubClass node8 = new ComparableSubClass(8);

    graph.addNode(node4);
    graph.addNode(node2);
    graph.addNode(node6);
    graph.addNode(node8);

    assertThat(graph.nodeOrder().comparator()).isEqualTo(Ordering.natural());
    assertThat(graph.nodes()).containsExactly(node2, node4, node6, node8).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=4 ) - Predicate: natural - Scenario: node8 (Alternative Scenario: node4=1 )

Project: guava
 Class: ElementOrderTest
 Method: edgeOrder_default
 Body: {
    MutableNetwork<Integer, String> network = NetworkBuilder.directed().build();

    addEdges(network);

    assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion());
    assertThat(network.edges()).containsExactly("i", "e", "p").inOrder();
    assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdges (Alternative Action: insertion=2 ) - Predicate: insertion - Scenario: network (Alternative Scenario: network=1 )

Project: guava
 Class: ElementOrderTest
 Method: customComparator
 Body: {
    Comparator<NonComparableSuperClass> comparator =
        new Comparator<NonComparableSuperClass>() {
          @Override
          public int compare(NonComparableSuperClass left, NonComparableSuperClass right) {
            return left.value.compareTo(right.value);
          }
        };

    MutableGraph<NonComparableSuperClass> graph =
        GraphBuilder.undirected().nodeOrder(ElementOrder.sorted(comparator)).build();

    NonComparableSuperClass node1 = new NonComparableSuperClass(1);
    NonComparableSuperClass node3 = new NonComparableSuperClass(3);
    NonComparableSuperClass node5 = new NonComparableSuperClass(5);
    NonComparableSuperClass node7 = new NonComparableSuperClass(7);

    graph.addNode(node1);
    graph.addNode(node7);
    graph.addNode(node5);
    graph.addNode(node3);

    assertThat(graph.nodeOrder().comparator()).isEqualTo(comparator);
    assertThat(graph.nodes()).containsExactly(node1, node3, node5, node7).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=4 ) - Predicate: N/A - Scenario: node7 (Alternative Scenario: node5=1 )

Project: guava
 Class: ElementOrderTest
 Method: edgeOrder_insertion
 Body: {
    MutableNetwork<Integer, String> network =
        NetworkBuilder.directed().edgeOrder(insertion()).build();

    addEdges(network);

    assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion());
    assertThat(network.edges()).containsExactly("i", "e", "p").inOrder();
    assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion()); // default
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdges (Alternative Action: insertion=3 ) - Predicate: insertion - Scenario: network (Alternative Scenario: network=1 )

Project: guava
 Class: ElementOrderTest
 Method: edgeOrder_natural
 Body: {
    MutableNetwork<Integer, String> network =
        NetworkBuilder.directed().edgeOrder(ElementOrder.<String>natural()).build();

    addEdges(network);

    assertThat(network.edgeOrder()).isEqualTo(ElementOrder.sorted(Ordering.<String>natural()));
    assertThat(network.edges()).containsExactly("e", "i", "p").inOrder();
    assertThat(network.nodeOrder()).isEqualTo(insertion()); // default
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdges (Alternative Action: natural=2 ) - Predicate: sorted - Scenario: network (Alternative Scenario: network=1 )

Project: guava
 Class: ElementOrderTest
 Method: nodeOrder_default
 Body: {
    MutableGraph<Integer> graph = GraphBuilder.directed().build();

    addNodes(graph);

    assertThat(graph.nodeOrder()).isEqualTo(insertion());
    assertThat(graph.nodes()).containsExactly(3, 1, 4).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNodes (Alternative Action: directed=1 ) - Predicate: insertion - Scenario: graph (Alternative Scenario: graph=1 )

Project: guava
 Class: ElementOrderTest
 Method: nodeOrder_natural
 Body: {
    MutableGraph<Integer> graph =
        GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();

    addNodes(graph);

    assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.sorted(Ordering.<Integer>natural()));
    assertThat(graph.nodes()).containsExactly(1, 3, 4).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNodes (Alternative Action: natural=2 ) - Predicate: sorted - Scenario: graph (Alternative Scenario: graph=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOfSortedExplicit
 Body: {
      Comparator<String> comparator = Ordering.natural().reverse();
      SortedMap<String, Integer> original = Maps.newTreeMap(comparator);
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableSortedMap<String, Integer> copy = ImmutableSortedMap.copyOfSorted(original);
      assertMapEquals(copy, "two", 2, "three", 3, "one", 1);
      assertSame(copy, ImmutableSortedMap.copyOfSorted(copy));
      assertSame(comparator, copy.comparator());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: comparator=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOfExplicitComparator
 Body: {
      Comparator<String> comparator = Ordering.natural().reverse();
      Map<String, Integer> original = new LinkedHashMap<>();
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableSortedMap<String, Integer> copy = ImmutableSortedMap.copyOf(original, comparator);
      assertMapEquals(copy, "two", 2, "three", 3, "one", 1);
      assertSame(copy, ImmutableSortedMap.copyOf(copy, comparator));
      assertSame(comparator, copy.comparator());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: comparator=1 )

Project: guava
 Class: CreationTests
 Method: testBuilderPutAll
 Body: {
      Map<String, Integer> toPut = new LinkedHashMap<>();
      toPut.put("one", 1);
      toPut.put("two", 2);
      toPut.put("three", 3);
      Map<String, Integer> moreToPut = new LinkedHashMap<>();
      moreToPut.put("four", 4);
      moreToPut.put("five", 5);

      ImmutableSortedMap<String, Integer> map =
          ImmutableSortedMap.<String, Integer>naturalOrder()
              .putAll(toPut)
              .putAll(moreToPut)
              .build();
      assertMapEquals(map, "five", 5, "four", 4, "one", 1, "three", 3, "two", 2);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: map (Alternative Scenario: toPut=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOf
 Body: {
      Map<String, Integer> original = new LinkedHashMap<>();
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableSortedMap<String, Integer> copy = ImmutableSortedMap.copyOf(original);
      assertMapEquals(copy, "one", 1, "three", 3, "two", 2);
      assertSame(copy, ImmutableSortedMap.copyOf(copy));
      assertSame(Ordering.natural(), copy.comparator());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: CreationTests
 Method: testBuilder_withMutableEntry
 Body: {
      ImmutableSortedMap.Builder<String, Integer> builder = ImmutableSortedMap.naturalOrder();
      final StringHolder holder = new StringHolder();
      holder.string = "one";
      Entry<String, Integer> entry =
          new AbstractMapEntry<String, Integer>() {
            @Override
            public String getKey() {
              return holder.string;
            }

            @Override
            public Integer getValue() {
              return 1;
            }
          };

      builder.put(entry);
      holder.string = "two";
      assertMapEquals(builder.build(), "one", 1);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: naturalOrder=1 ) - Predicate: build - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOfSortedNatural
 Body: {
      SortedMap<String, Integer> original = Maps.newTreeMap();
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableSortedMap<String, Integer> copy = ImmutableSortedMap.copyOfSorted(original);
      assertMapEquals(copy, "one", 1, "three", 3, "two", 2);
      assertSame(copy, ImmutableSortedMap.copyOfSorted(copy));
      assertSame(Ordering.natural(), copy.comparator());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: EnumHashBiMapTest
 Method: testCreate
 Body: {
    EnumHashBiMap<Currency, String> bimap = EnumHashBiMap.create(Currency.class);
    assertTrue(bimap.isEmpty());
    assertEquals("{}", bimap.toString());
    assertEquals(HashBiMap.create(), bimap);
    bimap.put(Currency.DOLLAR, "dollar");
    assertEquals("dollar", bimap.get(Currency.DOLLAR));
    assertEquals(Currency.DOLLAR, bimap.inverse().get("dollar"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: isEmpty - Scenario: bimap (Alternative Scenario: bimap=1 )

Project: guava
 Class: EnumHashBiMapTest
 Method: testEnumHashBiMapConstructor
 Body: {
    /* Test that it copies existing entries. */
    EnumHashBiMap<Currency, String> bimap1 = EnumHashBiMap.create(Currency.class);
    bimap1.put(Currency.DOLLAR, "dollar");
    EnumHashBiMap<Currency, String> bimap2 = EnumHashBiMap.create(bimap1);
    assertEquals("dollar", bimap2.get(Currency.DOLLAR));
    assertEquals(bimap1, bimap2);
    bimap2.inverse().put("franc", Currency.FRANC);
    assertEquals("franc", bimap2.get(Currency.FRANC));
    assertNull(bimap1.get(Currency.FRANC));
    assertFalse(bimap2.equals(bimap1));

    /* Test that it can be empty. */
    EnumHashBiMap<Currency, String> emptyBimap = EnumHashBiMap.create(Currency.class);
    EnumHashBiMap<Currency, String> bimap3 = EnumHashBiMap.create(emptyBimap);
    assertEquals(bimap3, emptyBimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: create=4 ) - Predicate: get - Scenario: bimap2 (Alternative Scenario: bimap2=1 )

Project: guava
 Class: EnumHashBiMapTest
 Method: testEntrySet
 Body: {
    // Bug 3168290
    Map<Currency, String> map =
        ImmutableMap.of(
            Currency.DOLLAR, "dollar",
            Currency.PESO, "peso",
            Currency.FRANC, "franc");
    EnumHashBiMap<Currency, String> bimap = EnumHashBiMap.create(map);

    Set<Object> uniqueEntries = Sets.newIdentityHashSet();
    uniqueEntries.addAll(bimap.entrySet());
    assertEquals(3, uniqueEntries.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: size=1 ) - Predicate: size - Scenario: uniqueEntries (Alternative Scenario: bimap=1 )

Project: guava
 Class: EnumHashBiMapTest
 Method: testEnumBiMapConstructor
 Body: {
    /* Test that it copies existing entries. */
    EnumBiMap<Currency, Country> bimap1 = EnumBiMap.create(Currency.class, Country.class);
    bimap1.put(Currency.DOLLAR, Country.SWITZERLAND);
    EnumHashBiMap<Currency, Object> bimap2 = // use supertype
        EnumHashBiMap.<Currency, Object>create(bimap1);
    assertEquals(Country.SWITZERLAND, bimap2.get(Currency.DOLLAR));
    assertEquals(bimap1, bimap2);
    bimap2.inverse().put("franc", Currency.FRANC);
    assertEquals("franc", bimap2.get(Currency.FRANC));
    assertNull(bimap1.get(Currency.FRANC));
    assertFalse(bimap2.equals(bimap1));

    /* Test that it can be empty. */
    EnumBiMap<Currency, Country> emptyBimap = EnumBiMap.create(Currency.class, Country.class);
    EnumHashBiMap<Currency, Country> bimap3 = // use exact type
        EnumHashBiMap.create(emptyBimap);
    assertEquals(bimap3, emptyBimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: create=4 ) - Predicate: get - Scenario: bimap2 (Alternative Scenario: bimap2=1 )

Project: guava
 Class: CharsTest
 Method: testAsList_isAView
 Body: {
    char[] array = {(char) 0, (char) 1};
    List<Character> list = Chars.asList(array);
    list.set(0, (char) 2);
    assertTrue(Arrays.equals(new char[] {(char) 2, (char) 1}, array));
    array[1] = (char) 3;
    assertEquals(Arrays.asList((char) 2, (char) 3), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: CharsTest
 Method: testAsList_toArray_roundTrip
 Body: {
    char[] array = {(char) 0, (char) 1, (char) 2};
    List<Character> list = Chars.asList(array);
    char[] newArray = Chars.toArray(list);

    // Make sure it returned a copy
    list.set(0, (char) 4);
    assertTrue(Arrays.equals(new char[] {(char) 0, (char) 1, (char) 2}, newArray));
    newArray[1] = (char) 5;
    assertEquals((char) 1, (char) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntrySet_iteratorRemovePropagates
 Body: {
    Iterator<Multiset.Entry<E>> iterator = getMultiset().entrySet().iterator();
    assertTrue(
        "non-empty multiset.entrySet() iterator.hasNext() returned false", iterator.hasNext());
    assertEquals(
        "multiset.entrySet() iterator.next() returned incorrect entry",
        Multisets.immutableEntry(e0(), 1),
        iterator.next());
    assertFalse(
        "size 1 multiset.entrySet() iterator.hasNext() returned true after next()",
        iterator.hasNext());
    iterator.remove();
    assertTrue(
        "multiset isn't empty after multiset.entrySet() iterator.remove()",
        getMultiset().isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: hasNext=2 ) - Predicate: hasNext - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsIteratorRemove
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    Iterator<E> itr = getMultiset().iterator();
    itr.next();
    itr.remove();
    assertEquals(2, entry.getCount());
    itr.next();
    itr.remove();
    itr.next();
    itr.remove();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: next=3 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryViewReflectsRemove
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    assertTrue(getMultiset().remove(e0()));
    assertEquals(2, entry.getCount());
    assertTrue(getMultiset().elementSet().remove(e0()));
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=4 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsElementSetIteratorRemove
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    Iterator<E> elementItr = getMultiset().elementSet().iterator();
    elementItr.next();
    elementItr.remove();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=3 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsEntrySetIteratorRemove
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Iterator<Multiset.Entry<E>> entryItr = getMultiset().entrySet().iterator();
    Multiset.Entry<E> entry = entryItr.next();
    entryItr.remove();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=2 ) - Predicate: count - Scenario: entryItr (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsEntrySetClear
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    getMultiset().entrySet().clear();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=3 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsElementSetClear
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    getMultiset().elementSet().clear();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=3 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsRemoveThenAdd
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    assertTrue(getMultiset().remove(e0()));
    assertEquals(2, entry.getCount());
    assertTrue(getMultiset().elementSet().remove(e0()));
    assertEquals(0, entry.getCount());
    getMultiset().add(e0(), 2);
    assertEquals(2, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=5 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetEntrySetTester
 Method: testEntryReflectsClear
 Body: {
    initThreeCopies();
    assertEquals(3, getMultiset().count(e0()));
    Multiset.Entry<E> entry = Iterables.getOnlyElement(getMultiset().entrySet());
    assertEquals(3, entry.getCount());
    getMultiset().clear();
    assertEquals(0, entry.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=3 ) - Predicate: count - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: AsyncEventBusTest
 Method: testBasicDistribution
 Body: {
    StringCatcher catcher = new StringCatcher();
    bus.register(catcher);

    // We post the event, but our Executor will not deliver it until instructed.
    bus.post(EVENT);

    List<String> events = catcher.getEvents();
    assertTrue("No events should be delivered synchronously.", events.isEmpty());

    // Now we find the task in our Executor and explicitly activate it.
    List<Runnable> tasks = executor.getTasks();
    assertEquals("One event dispatch task should be queued.", 1, tasks.size());

    tasks.get(0).run();

    assertEquals("One event should be delivered.", 1, events.size());
    assertEquals("Correct string should be delivered.", EVENT, events.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: size=2 ) - Predicate: isEmpty - Scenario: events (Alternative Scenario: catcher=1 )

Project: guava
 Class: ImmutableDoubleArrayTest
 Method: testBuilder_presize_zero
 Body: {
    ImmutableDoubleArray.Builder builder = ImmutableDoubleArray.builder(0);
    builder.add(5.0);
    ImmutableDoubleArray array = builder.build();
    assertThat(array.asList()).containsExactly(5.0);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: N/A - Scenario: array (Alternative Scenario: array=1 )

Project: guava
 Class: ImmutableDoubleArrayTest
 Method: testCopyOf_iterable_notCollection_nonempty
 Body: {
    List<Double> list = Arrays.asList(0.0, 1.0, 3.0);
    ImmutableDoubleArray iia = ImmutableDoubleArray.copyOf(iterable(list));
    list.set(2, 2.0);
    assertThat(iia.asList()).containsExactly(0.0, 1.0, 3.0).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableDoubleArrayTest
 Method: testCopyOf_collection_nonempty
 Body: {
    List<Double> list = Arrays.asList(0.0, 1.0, 3.0);
    ImmutableDoubleArray iia = ImmutableDoubleArray.copyOf(list);
    list.set(2, 2.0);
    assertThat(iia.asList()).containsExactly(0.0, 1.0, 3.0).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableDoubleArrayTest
 Method: testForEach
 Body: {
    ImmutableDoubleArray.of().forEach(i -> fail());
    ImmutableDoubleArray.of(0, 1, 3).subArray(1, 1).forEach(i -> fail());

    AtomicInteger count = new AtomicInteger(0);
    ImmutableDoubleArray.of(0, 1, 2, 3)
        .forEach(i -> assertThat(i).isEqualTo((double) count.getAndIncrement()));
    assertEquals(4, count.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: of=3 ) - Predicate: N/A - Scenario: count (Alternative Scenario: count=1 )

Project: guava
 Class: ImmutableDoubleArrayTest
 Method: testCopyOf_iterable_collection_nonempty
 Body: {
    List<Double> list = Arrays.asList(0.0, 1.0, 3.0);
    ImmutableDoubleArray iia = ImmutableDoubleArray.copyOf((Iterable<Double>) list);
    list.set(2, 2.0);
    assertThat(iia.asList()).containsExactly(0.0, 1.0, 3.0).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: LittleEndianDataOutputStreamTest
 Method: testWriteBytes_discardHighOrderBytes
 Body: {

    /* Write out various test values in LITTLE ENDIAN FORMAT */
    out.writeBytes("\uAAAA\uAABB\uAACC");

    byte[] data = baos.toByteArray();

    /* Setup input streams */
    DataInput in = new DataInputStream(new ByteArrayInputStream(data));

    /* Read in various values NORMALLY */
    byte[] b = new byte[3];
    in.readFully(b);
    byte[] expected = {(byte) 0xAA, (byte) 0xBB, (byte) 0xCC};
    assertEquals(expected, b);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: writeBytes=1 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: b=1 )

Project: guava
 Class: LittleEndianDataOutputStreamTest
 Method: testWriteBytes
 Body: {

    /* Write out various test values in LITTLE ENDIAN FORMAT */
    out.writeBytes("r\u00C9sum\u00C9");

    byte[] data = baos.toByteArray();

    /* Setup input streams */
    DataInput in = new DataInputStream(new ByteArrayInputStream(data));

    /* Read in various values NORMALLY */
    byte[] b = new byte[6];
    in.readFully(b);
    assertEquals("r\u00C9sum\u00C9".getBytes(Charsets.ISO_8859_1), b);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: writeBytes=1 ) - Predicate: getBytes - Scenario: b (Alternative Scenario: b=1 )

Project: guava
 Class: LittleEndianDataOutputStreamTest
 Method: testWriteChars
 Body: {

    /* Write out various test values in LITTLE ENDIAN FORMAT */
    out.writeChars("r\u00C9sum\u00C9");

    byte[] data = baos.toByteArray();

    /* Setup input streams */
    DataInput in = new DataInputStream(new ByteArrayInputStream(data));

    /* Read in various values NORMALLY */
    byte[] actual = new byte[12];
    in.readFully(actual);
    assertEquals('r', actual[0]);
    assertEquals(0, actual[1]);
    assertEquals((byte) 0xC9, actual[2]);
    assertEquals(0, actual[3]);
    assertEquals('s', actual[4]);
    assertEquals(0, actual[5]);
    assertEquals('u', actual[6]);
    assertEquals(0, actual[7]);
    assertEquals('m', actual[8]);
    assertEquals(0, actual[9]);
    assertEquals((byte) 0xC9, actual[10]);
    assertEquals(0, actual[11]);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: readFully=1 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: WellBehavedMapTest
 Method: testEntrySet_contain
 Body: {
    WellBehavedMap<Foo, Integer> map = WellBehavedMap.wrap(new EnumMap<Foo, Integer>(Foo.class));
    map.putAll(ImmutableMap.of(Foo.X, 1, Foo.Y, 2, Foo.Z, 3));

    // testing with the exact entry
    assertTrue(map.entrySet().contains(Maps.immutableEntry(Foo.X, 1)));
    assertTrue(map.entrySet().contains(Maps.immutableEntry(Foo.Y, new Integer(2))));

    // testing an entry with a contained key, but not the same value
    assertFalse(map.entrySet().contains(Maps.immutableEntry(Foo.X, 5)));

    // testing a non-existent key
    assertFalse(map.entrySet().contains(Maps.immutableEntry(Foo.T, 0)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: contains=4 ) - Predicate: contains - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: WellBehavedMapTest
 Method: testEntriesAreMutableAndConsistent
 Body: {
    WellBehavedMap<Foo, Integer> map = WellBehavedMap.wrap(new EnumMap<Foo, Integer>(Foo.class));
    map.putAll(ImmutableMap.of(Foo.X, 1));

    Entry<Foo, Integer> entry1 = Iterables.getOnlyElement(map.entrySet());
    Entry<Foo, Integer> entry2 = Iterables.getOnlyElement(map.entrySet());

    // the entries are constructed and forgotten, thus different
    assertNotSame(entry1, entry2);

    Set<Entry<Foo, Integer>> entrySet = map.entrySet();

    assertTrue(entrySet.contains(entry1));
    assertTrue(entrySet.contains(entry2));

    // mutating entry
    entry1.setValue(2);

    // entry2 is also modified
    assertEquals(entry1.getValue(), entry2.getValue());

    // and both are still contained in the set
    assertTrue(entrySet.contains(entry1));
    assertTrue(entrySet.contains(entry2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: contains=4 ) - Predicate: N/A - Scenario: entry1 (Alternative Scenario: entry1=1 )

Project: guava
 Class: WellBehavedMapTest
 Method: testEntrySet_remove
 Body: {
    WellBehavedMap<Foo, Integer> map = WellBehavedMap.wrap(new EnumMap<Foo, Integer>(Foo.class));
    map.putAll(ImmutableMap.of(Foo.X, 1, Foo.Y, 2, Foo.Z, 3));
    Set<Entry<Foo, Integer>> entrySet = map.entrySet();

    // removing an existing entry, verifying consistency
    Entry<Foo, Integer> entry = Maps.immutableEntry(Foo.Y, 2);
    assertTrue(entrySet.remove(entry));
    assertFalse(map.containsKey(Foo.Y));
    assertNull(map.get(Foo.Y));
    assertFalse(entrySet.contains(entry));

    // we didn't have that entry, not removed
    assertFalse(entrySet.remove(Maps.immutableEntry(Foo.T, 4)));

    // we didn't have that entry, only <Z, 3>, must not remove
    assertFalse(entrySet.remove(Maps.immutableEntry(Foo.Z, 5)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: immutableEntry=3 ) - Predicate: remove - Scenario: entrySet (Alternative Scenario: entry=1 )

Project: guava
 Class: GcFinalizationTest
 Method: testAwaitDone_FinalizationPredicate
 Body: {
    final WeakHashMap<Object, Object> map = new WeakHashMap<>();
    map.put(new Object(), Boolean.TRUE);
    GcFinalization.awaitDone(
        new FinalizationPredicate() {
          public boolean isDone() {
            return map.isEmpty();
          }
        });
    assertTrue(map.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: isEmpty=2 ) - Predicate: isEmpty - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: GcFinalizationTest
 Method: testAwaitFullGc
 Body: {
    final CountDownLatch finalizerRan = new CountDownLatch(1);
    final WeakReference<Object> ref =
        new WeakReference<Object>(
            new Object() {
              @Override
              protected void finalize() {
                finalizerRan.countDown();
              }
            });

    // Don't copy this into your own test!
    // Use e.g. awaitClear or await(CountDownLatch) instead.
    GcFinalization.awaitFullGc();

    // If this test turns out to be flaky, add a second call to awaitFullGc()
    // GcFinalization.awaitFullGc();

    assertEquals(0, finalizerRan.getCount());
    assertNull(ref.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitFullGc (Alternative Action: get=1 ) - Predicate: getCount - Scenario: ref (Alternative Scenario: ref=1 )

Project: guava
 Class: EquivalenceTest
 Method: testEquivalentTo
 Body: {
    Predicate<Object> equalTo1 = Equivalence.equals().equivalentTo("1");
    assertTrue(equalTo1.apply("1"));
    assertFalse(equalTo1.apply("2"));
    assertFalse(equalTo1.apply(null));
    Predicate<Object> isNull = Equivalence.equals().equivalentTo(null);
    assertFalse(isNull.apply("1"));
    assertFalse(isNull.apply("2"));
    assertTrue(isNull.apply(null));

    new EqualsTester()
        .addEqualityGroup(equalTo1, Equivalence.equals().equivalentTo("1"))
        .addEqualityGroup(isNull)
        .addEqualityGroup(Equivalence.identity().equivalentTo("1"))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: apply=6 ) - Predicate: apply - Scenario: equalTo1 (Alternative Scenario: equalTo1=1 )

Project: guava
 Class: SynchronizedMultimapTest
 Method: testSynchronizedSortedSetMultimap
 Body: {
    SortedSetMultimap<String, Integer> multimap =
        Multimaps.synchronizedSortedSetMultimap(TreeMultimap.<String, Integer>create());
    multimap.putAll("foo", Arrays.asList(3, -1, 2, 4, 1));
    multimap.putAll("bar", Arrays.asList(1, 2, 3, 1));
    assertThat(multimap.removeAll("foo")).containsExactly(-1, 1, 2, 3, 4).inOrder();
    assertFalse(multimap.containsKey("foo"));
    assertThat(multimap.replaceValues("bar", Arrays.asList(6, 5)))
        .containsExactly(1, 2, 3)
        .inOrder();
    assertThat(multimap.get("bar")).containsExactly(5, 6).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: asList=3 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: SynchronizedMultimapTest
 Method: testSynchronizedLinkedListMultimapRandomAccess
 Body: {
    ListMultimap<String, Integer> delegate = LinkedListMultimap.create();
    delegate.put("foo", 1);
    delegate.put("foo", 3);
    ListMultimap<String, Integer> multimap = Multimaps.synchronizedListMultimap(delegate);
    assertFalse(multimap.get("foo") instanceof RandomAccess);
    assertFalse(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: delegate=1 )

Project: guava
 Class: SynchronizedMultimapTest
 Method: testSynchronizedListMultimap
 Body: {
    ListMultimap<String, Integer> multimap =
        Multimaps.synchronizedListMultimap(ArrayListMultimap.<String, Integer>create());
    multimap.putAll("foo", Arrays.asList(3, -1, 2, 4, 1));
    multimap.putAll("bar", Arrays.asList(1, 2, 3, 1));
    assertThat(multimap.removeAll("foo")).containsExactly(3, -1, 2, 4, 1).inOrder();
    assertFalse(multimap.containsKey("foo"));
    assertThat(multimap.replaceValues("bar", Arrays.asList(6, 5)))
        .containsExactly(1, 2, 3, 1)
        .inOrder();
    assertThat(multimap.get("bar")).containsExactly(6, 5).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: asList=3 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: SynchronizedMultimapTest
 Method: testSynchronizedArrayListMultimapRandomAccess
 Body: {
    ListMultimap<String, Integer> delegate = ArrayListMultimap.create();
    delegate.put("foo", 1);
    delegate.put("foo", 3);
    ListMultimap<String, Integer> multimap = Multimaps.synchronizedListMultimap(delegate);
    assertTrue(multimap.get("foo") instanceof RandomAccess);
    assertTrue(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: delegate=1 )

Project: guava
 Class: MultimapEntriesTester
 Method: testEntriesRemainValidAfterRemove
 Body: {
    Iterator<Entry<K, V>> iterator = multimap().entries().iterator();
    Entry<K, V> entry = iterator.next();
    K key = entry.getKey();
    V value = entry.getValue();
    multimap().removeAll(key);
    assertEquals(key, entry.getKey());
    assertEquals(value, entry.getValue());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: removeAll (Alternative Action: getValue=2 ) - Predicate: getKey - Scenario: value (Alternative Scenario: entry=1 )

Project: guava
 Class: MultimapEntriesTester
 Method: testIteratorRemovePropagatesToMultimap
 Body: {
    Iterator<Entry<K, V>> iterator = multimap().entries().iterator();
    assertEquals(Helpers.mapEntry(k0(), v0()), iterator.next());
    iterator.remove();
    assertTrue(multimap().isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: multimap=2 ) - Predicate: mapEntry - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: CollectSpliteratorsTest
 Method: testMultisetsSpliterator
 Body: {
    Multiset<String> multiset = TreeMultiset.create();
    multiset.add("a", 3);
    multiset.add("b", 1);
    multiset.add("c", 2);

    List<String> actualValues = Lists.newArrayList();
    multiset.spliterator().forEachRemaining(actualValues::add);
    assertThat(multiset).containsExactly("a", "a", "a", "b", "c", "c").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachRemaining (Alternative Action: add=3 ) - Predicate: N/A - Scenario: actualValues (Alternative Scenario: multiset=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testReloadAfterSimulatedKeyReclamation
 Body: {
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);

    Object key = new Object();
    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, cache.size());

    CacheTesting.simulateKeyReclamation(cache, key);

    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateKeyReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(3, countingLoader.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: simulateKeyReclamation (Alternative Action: simulateKeyReclamation=2 ) - Predicate: getUnchecked - Scenario: countingLoader (Alternative Scenario: cache=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testExpandDuringLoading
 Body: {
    final int count = 3;
    final AtomicInteger callCount = new AtomicInteger();
    // tells the computing thread when to start computing
    final CountDownLatch computeSignal = new CountDownLatch(1);
    // tells the main thread when computation is pending
    final CountDownLatch secondSignal = new CountDownLatch(1);
    // tells the main thread when the second get has started
    final CountDownLatch thirdSignal = new CountDownLatch(1);
    // tells the main thread when the third get has started
    final CountDownLatch fourthSignal = new CountDownLatch(1);
    // tells the test when all gets have returned
    final CountDownLatch doneSignal = new CountDownLatch(count);

    CacheLoader<String, String> computeFunction =
        new CacheLoader<String, String>() {
          @Override
          public String load(String key) throws InterruptedException {
            callCount.incrementAndGet();
            secondSignal.countDown();
            computeSignal.await();
            return key + "foo";
          }
        };

    final LoadingCache<String, String> cache =
        CacheBuilder.newBuilder().weakKeys().build(computeFunction);

    final AtomicReferenceArray<String> result = new AtomicReferenceArray<>(count);

    final String key = "bar";

    // start computing thread
    new Thread() {
      @Override
      public void run() {
        result.set(0, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // wait for computation to start
    secondSignal.await();

    // start waiting thread
    new Thread() {
      @Override
      public void run() {
        thirdSignal.countDown();
        result.set(1, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the second get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    thirdSignal.await();
    Thread.yield();

    // Expand!
    CacheTesting.forceExpandSegment(cache, key);

    // start another waiting thread
    new Thread() {
      @Override
      public void run() {
        fourthSignal.countDown();
        result.set(2, cache.getUnchecked(key));
        doneSignal.countDown();
      }
    }.start();

    // give the third get a chance to run; it is okay for this to be racy
    // as the end result should be the same either way
    fourthSignal.await();
    Thread.yield();

    // let computation finish
    computeSignal.countDown();
    doneSignal.await();

    assertTrue(callCount.get() == 1);
    assertEquals("barfoo", result.get(0));
    assertEquals("barfoo", result.get(1));
    assertEquals("barfoo", result.get(2));
    assertEquals("barfoo", cache.getUnchecked(key));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: countDown=7 ) - Predicate: N/A - Scenario: key (Alternative Scenario: result=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testAsMapDuringLoading
 Body: {
    final CountDownLatch getStartedSignal = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader<String, String> computeFunction =
        new CacheLoader<String, String>() {
          @Override
          public String load(String key) throws InterruptedException {
            getStartedSignal.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap<String, String> map = cache.asMap();
    map.put(refreshKey, refreshKey);
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, map.get(refreshKey));

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    getStartedSignal.await();

    // computation is in progress; asMap shouldn't have changed
    assertEquals(1, map.size());
    assertFalse(map.containsKey(getKey));
    assertSame(refreshKey, map.get(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // asMap view should have been updated
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=4 ) - Predicate: size - Scenario: map (Alternative Scenario: getKey=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testInvalidateAndReloadDuringLoading
 Body: {
    // computation starts; clear() is called, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(4);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader<String, String> computeFunction =
        new CacheLoader<String, String>() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap<String, String> map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(map.containsKey(refreshKey));

    // start new computations
    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // results should be visible
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: countDown=6 ) - Predicate: containsKey - Scenario: map (Alternative Scenario: getKey=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testInvalidateDuringLoading
 Body: {
    // computation starts; invalidate() is called on the key being computed, computation finishes
    final CountDownLatch computationStarted = new CountDownLatch(2);
    final CountDownLatch letGetFinishSignal = new CountDownLatch(1);
    final CountDownLatch getFinishedSignal = new CountDownLatch(2);
    final String getKey = "get";
    final String refreshKey = "refresh";
    final String suffix = "Suffix";

    CacheLoader<String, String> computeFunction =
        new CacheLoader<String, String>() {
          @Override
          public String load(String key) throws InterruptedException {
            computationStarted.countDown();
            letGetFinishSignal.await();
            return key + suffix;
          }
        };

    final LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);
    ConcurrentMap<String, String> map = cache.asMap();
    map.put(refreshKey, refreshKey);

    new Thread() {
      @Override
      public void run() {
        cache.getUnchecked(getKey);
        getFinishedSignal.countDown();
      }
    }.start();
    new Thread() {
      @Override
      public void run() {
        cache.refresh(refreshKey);
        getFinishedSignal.countDown();
      }
    }.start();

    computationStarted.await();
    cache.invalidate(getKey);
    cache.invalidate(refreshKey);
    assertFalse(map.containsKey(getKey));
    assertFalse(map.containsKey(refreshKey));

    // let computation complete
    letGetFinishSignal.countDown();
    getFinishedSignal.await();
    checkNothingLogged();

    // results should be visible
    assertEquals(2, cache.size());
    assertEquals(getKey + suffix, map.get(getKey));
    assertEquals(refreshKey + suffix, map.get(refreshKey));
    assertEquals(2, cache.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: countDown=4 ) - Predicate: containsKey - Scenario: map (Alternative Scenario: getKey=1 )

Project: guava
 Class: CacheLoadingTest
 Method: testReloadAfterSimulatedValueReclamation
 Body: {
    CountingLoader countingLoader = new CountingLoader();
    LoadingCache<Object, Object> cache =
        CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);

    Object key = new Object();
    assertNotNull(cache.getUnchecked(key));

    CacheTesting.simulateValueReclamation(cache, key);

    // this blocks if computation can't deal with partially-collected values
    assertNotNull(cache.getUnchecked(key));
    assertEquals(1, cache.size());
    assertEquals(2, countingLoader.getCount());

    CacheTesting.simulateValueReclamation(cache, key);
    cache.refresh(key);
    checkNothingLogged();
    assertEquals(1, cache.size());
    assertEquals(3, countingLoader.getCount());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: simulateValueReclamation (Alternative Action: size=2 ) - Predicate: getUnchecked - Scenario: countingLoader (Alternative Scenario: cache=1 )

Project: guava
 Class: MapForEachTester
 Method: testForEach_nullValues
 Body: {
    initMapWithNullValue();
    List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullValue());
    List<Entry<K, V>> entries = new ArrayList<>();
    getMap().forEach((k, v) -> entries.add(entry(k, v)));
    Helpers.assertEqualIgnoringOrder(expectedEntries, entries);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: add=1 ) - Predicate: N/A - Scenario: entries (Alternative Scenario: expectedEntries=1 )

Project: guava
 Class: MapForEachTester
 Method: testForEach_nullKeys
 Body: {
    initMapWithNullKey();
    List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullKey());
    List<Entry<K, V>> entries = new ArrayList<>();
    getMap().forEach((k, v) -> entries.add(entry(k, v)));
    Helpers.assertEqualIgnoringOrder(expectedEntries, entries);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: add=1 ) - Predicate: N/A - Scenario: entries (Alternative Scenario: expectedEntries=1 )

Project: guava
 Class: EventBusTest
 Method: testDeadEventForwarding
 Body: {
    GhostCatcher catcher = new GhostCatcher();
    bus.register(catcher);

    // A String -- an event for which noone has registered.
    bus.post(EVENT);

    List<DeadEvent> events = catcher.getEvents();
    assertEquals("One dead event should be delivered.", 1, events.size());
    assertEquals("The dead event should wrap the original event.", EVENT, events.get(0).getEvent());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: getEvent=1 ) - Predicate: size - Scenario: events (Alternative Scenario: catcher=1 )

Project: guava
 Class: EventBusTest
 Method: testRegistrationWithBridgeMethod
 Body: {
    final AtomicInteger calls = new AtomicInteger();
    bus.register(
        new Callback<String>() {
          @Subscribe
          @Override
          public void call(String s) {
            calls.incrementAndGet();
          }
        });

    bus.post("hello");

    assertEquals(1, calls.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: register (Alternative Action: incrementAndGet=1 ) - Predicate: get - Scenario: calls (Alternative Scenario: calls=1 )

Project: guava
 Class: EventBusTest
 Method: testDeadEventPosting
 Body: {
    GhostCatcher catcher = new GhostCatcher();
    bus.register(catcher);

    bus.post(new DeadEvent(this, EVENT));

    List<DeadEvent> events = catcher.getEvents();
    assertEquals("The explicit DeadEvent should be delivered.", 1, events.size());
    assertEquals("The dead event must not be re-wrapped.", EVENT, events.get(0).getEvent());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: getEvent=1 ) - Predicate: size - Scenario: events (Alternative Scenario: catcher=1 )

Project: guava
 Class: EventBusTest
 Method: testBasicCatcherDistribution
 Body: {
    StringCatcher catcher = new StringCatcher();
    bus.register(catcher);
    bus.post(EVENT);

    List<String> events = catcher.getEvents();
    assertEquals("Only one event should be delivered.", 1, events.size());
    assertEquals("Correct string should be delivered.", EVENT, events.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: getEvents=1 ) - Predicate: size - Scenario: events (Alternative Scenario: catcher=1 )

Project: guava
 Class: EventBusTest
 Method: testPolymorphicDistribution
 Body: {
    // Three catchers for related types String, Object, and Comparable<?>.
    // String isa Object
    // String isa Comparable<?>
    // Comparable<?> isa Object
    StringCatcher stringCatcher = new StringCatcher();

    final List<Object> objectEvents = Lists.newArrayList();
    Object objCatcher =
        new Object() {
          @SuppressWarnings("unused")
          @Subscribe
          public void eat(Object food) {
            objectEvents.add(food);
          }
        };

    final List<Comparable<?>> compEvents = Lists.newArrayList();
    Object compCatcher =
        new Object() {
          @SuppressWarnings("unused")
          @Subscribe
          public void eat(Comparable<?> food) {
            compEvents.add(food);
          }
        };
    bus.register(stringCatcher);
    bus.register(objCatcher);
    bus.register(compCatcher);

    // Two additional event types: Object and Comparable<?> (played by Integer)
    Object objEvent = new Object();
    Object compEvent = new Integer(6);

    bus.post(EVENT);
    bus.post(objEvent);
    bus.post(compEvent);

    // Check the StringCatcher...
    List<String> stringEvents = stringCatcher.getEvents();
    assertEquals("Only one String should be delivered.", 1, stringEvents.size());
    assertEquals("Correct string should be delivered.", EVENT, stringEvents.get(0));

    // Check the Catcher<Object>...
    assertEquals("Three Objects should be delivered.", 3, objectEvents.size());
    assertEquals("String fixture must be first object delivered.", EVENT, objectEvents.get(0));
    assertEquals("Object fixture must be second object delivered.", objEvent, objectEvents.get(1));
    assertEquals(
        "Comparable fixture must be thirdobject delivered.", compEvent, objectEvents.get(2));

    // Check the Catcher<Comparable<?>>...
    assertEquals("Two Comparable<?>s should be delivered.", 2, compEvents.size());
    assertEquals("String fixture must be first comparable delivered.", EVENT, compEvents.get(0));
    assertEquals(
        "Comparable fixture must be second comparable delivered.", compEvent, compEvents.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: post (Alternative Action: get=6 ) - Predicate: size - Scenario: stringEvents (Alternative Scenario: compCatcher=1 )

Project: guava
 Class: EventBusTest
 Method: testSubscriberThrowsException
 Body: {
    final RecordingSubscriberExceptionHandler handler = new RecordingSubscriberExceptionHandler();
    final EventBus eventBus = new EventBus(handler);
    final RuntimeException exception =
        new RuntimeException("but culottes have a tendancy to ride up!");
    final Object subscriber =
        new Object() {
          @Subscribe
          public void throwExceptionOn(String message) {
            throw exception;
          }
        };
    eventBus.register(subscriber);
    eventBus.post(EVENT);

    assertEquals("Cause should be available.", exception, handler.exception);
    assertEquals("EventBus should be available.", eventBus, handler.context.getEventBus());
    assertEquals("Event should be available.", EVENT, handler.context.getEvent());
    assertEquals("Subscriber should be available.", subscriber, handler.context.getSubscriber());
    assertEquals(
        "Method should be available.",
        subscriber.getClass().getMethod("throwExceptionOn", String.class),
        handler.context.getSubscriberMethod());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: register (Alternative Action: getEvent=1 ) - Predicate: N/A - Scenario: subscriber (Alternative Scenario: exception=1 )

Project: guava
 Class: CacheLoaderTest
 Method: testAsyncReload
 Body: {
    final AtomicInteger loadCount = new AtomicInteger();
    final AtomicInteger reloadCount = new AtomicInteger();
    final AtomicInteger loadAllCount = new AtomicInteger();

    CacheLoader<Object, Object> baseLoader =
        new CacheLoader<Object, Object>() {
          @Override
          public Object load(Object key) {
            loadCount.incrementAndGet();
            return new Object();
          }

          @Override
          public ListenableFuture<Object> reload(Object key, Object oldValue) {
            reloadCount.incrementAndGet();
            return Futures.immediateFuture(new Object());
          }

          @Override
          public Map<Object, Object> loadAll(Iterable<?> keys) {
            loadAllCount.incrementAndGet();
            return ImmutableMap.of();
          }
        };

    assertEquals(0, loadCount.get());
    assertEquals(0, reloadCount.get());
    assertEquals(0, loadAllCount.get());

    baseLoader.load(new Object());
    @SuppressWarnings("unused") // go/futurereturn-lsc
    Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());
    baseLoader.loadAll(ImmutableList.of(new Object()));
    assertEquals(1, loadCount.get());
    assertEquals(1, reloadCount.get());
    assertEquals(1, loadAllCount.get());

    QueuingExecutor executor = new QueuingExecutor();
    CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);

    asyncReloader.load(new Object());
    @SuppressWarnings("unused") // go/futurereturn-lsc
    Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());
    asyncReloader.loadAll(ImmutableList.of(new Object()));
    assertEquals(2, loadCount.get());
    assertEquals(1, reloadCount.get());
    assertEquals(2, loadAllCount.get());

    executor.runNext();
    assertEquals(2, loadCount.get());
    assertEquals(2, reloadCount.get());
    assertEquals(2, loadAllCount.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: load (Alternative Action: get=12 ) - Predicate: get - Scenario: loadCount (Alternative Scenario: reloadCount=1 )

Project: guava
 Class: MoreTests
 Method: testDifference
 Body: {
      Set<String> friends = Sets.newHashSet("Tom", "Joe", "Dave");
      Set<String> enemies = Sets.newHashSet("Dick", "Harry", "Tom");

      Set<String> goodFriends = Sets.difference(friends, enemies);
      assertEquals(2, goodFriends.size());

      ImmutableSet<String> immut = Sets.difference(friends, enemies).immutableCopy();
      HashSet<String> mut = Sets.difference(friends, enemies).copyInto(new HashSet<String>());

      enemies.add("Dave");
      assertEquals(1, goodFriends.size());
      assertEquals(2, immut.size());
      assertEquals(2, mut.size());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: size=4 ) - Predicate: size - Scenario: friends (Alternative Scenario: immut=1 )

Project: guava
 Class: MoreTests
 Method: testUnion
 Body: {
      Set<String> all = Sets.union(friends, enemies);
      assertEquals(5, all.size());

      ImmutableSet<String> immut = Sets.union(friends, enemies).immutableCopy();
      HashSet<String> mut = Sets.union(friends, enemies).copyInto(new HashSet<String>());

      enemies.add("Buck");
      assertEquals(6, all.size());
      assertEquals(5, immut.size());
      assertEquals(5, mut.size());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: size=4 ) - Predicate: size - Scenario: all (Alternative Scenario: all=1 )

Project: guava
 Class: MoreTests
 Method: testSymmetricDifference
 Body: {
      Set<String> friends = Sets.newHashSet("Tom", "Joe", "Dave");
      Set<String> enemies = Sets.newHashSet("Dick", "Harry", "Tom");

      Set<String> symmetricDifferenceFriendsFirst = Sets.symmetricDifference(friends, enemies);
      assertEquals(4, symmetricDifferenceFriendsFirst.size());

      Set<String> symmetricDifferenceEnemiesFirst = Sets.symmetricDifference(enemies, friends);
      assertEquals(4, symmetricDifferenceEnemiesFirst.size());

      assertEquals(symmetricDifferenceFriendsFirst, symmetricDifferenceEnemiesFirst);

      ImmutableSet<String> immut = Sets.symmetricDifference(friends, enemies).immutableCopy();
      HashSet<String> mut =
          Sets.symmetricDifference(friends, enemies).copyInto(new HashSet<String>());

      enemies.add("Dave");
      assertEquals(3, symmetricDifferenceFriendsFirst.size());
      assertEquals(4, immut.size());
      assertEquals(4, mut.size());

      immut = Sets.symmetricDifference(enemies, friends).immutableCopy();
      mut = Sets.symmetricDifference(enemies, friends).copyInto(new HashSet<String>());
      friends.add("Harry");
      assertEquals(2, symmetricDifferenceEnemiesFirst.size());
      assertEquals(3, immut.size());
      assertEquals(3, mut.size());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: size=8 ) - Predicate: size - Scenario: friends (Alternative Scenario: symmetricDifferenceFriendsFirst=1 )

Project: guava
 Class: MoreTests
 Method: testIntersection
 Body: {
      Set<String> friends = Sets.newHashSet("Tom", "Joe", "Dave");
      Set<String> enemies = Sets.newHashSet("Dick", "Harry", "Tom");

      Set<String> frenemies = Sets.intersection(friends, enemies);
      assertEquals(1, frenemies.size());

      ImmutableSet<String> immut = Sets.intersection(friends, enemies).immutableCopy();
      HashSet<String> mut = Sets.intersection(friends, enemies).copyInto(new HashSet<String>());

      enemies.add("Joe");
      assertEquals(2, frenemies.size());
      assertEquals(1, immut.size());
      assertEquals(1, mut.size());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: size=4 ) - Predicate: size - Scenario: friends (Alternative Scenario: immut=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutNullValue_supported
 Body: {
    int size = getNumElements();

    multimap().put(k3(), null);

    assertGet(k3(), Lists.newArrayList((V) null)); // ImmutableList.of can't take null.
    assertEquals(size + 1, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: k3=2 ) - Predicate: k3 - Scenario: size (Alternative Scenario: size=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutNullKey
 Body: {
    int size = getNumElements();

    multimap().put(null, v3());

    assertGet(null, v3());
    assertEquals(size + 1, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: multimap=2 ) - Predicate: v3 - Scenario: size (Alternative Scenario: size=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutNotPresentKeyPropagatesToGet
 Body: {
    int size = getNumElements();
    Collection<V> collection = multimap().get(k3());
    assertEmpty(collection);
    multimap().put(k3(), v3());
    assertContains(collection, v3());
    assertEquals(size + 1, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: multimap=3 ) - Predicate: N/A - Scenario: size (Alternative Scenario: size=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutTwoElements
 Body: {
    int size = getNumElements();

    List<V> values = Helpers.copyToList(multimap().get(k0()));

    assertTrue(multimap().put(k0(), v1()));
    assertTrue(multimap().put(k0(), v2()));

    values.add(v1());
    values.add(v2());

    assertGet(k0(), values);
    assertEquals(size + 2, multimap().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: k0=4 ) - Predicate: put - Scenario: size (Alternative Scenario: size=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutNotPresentKeyPropagatesToEntries
 Body: {
    Collection<Entry<K, V>> entries = multimap().entries();
    assertFalse(entries.contains(Helpers.mapEntry(k3(), v3())));
    multimap().put(k3(), v3());
    assertContains(entries, Helpers.mapEntry(k3(), v3()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: k3=3 ) - Predicate: contains - Scenario: entries (Alternative Scenario: entries=1 )

Project: guava
 Class: MultimapPutTester
 Method: testPutPresentKeyPropagatesToEntries
 Body: {
    Collection<Entry<K, V>> entries = multimap().entries();
    assertFalse(entries.contains(Helpers.mapEntry(k0(), v3())));
    multimap().put(k0(), v3());
    assertContains(entries, Helpers.mapEntry(k0(), v3()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: k0=3 ) - Predicate: contains - Scenario: entries (Alternative Scenario: entries=1 )

Project: guava
 Class: CloserTest
 Method: testNoExceptionsThrown
 Body: {
    Closer closer = new Closer(suppressor);

    TestCloseable c1 = closer.register(TestCloseable.normal());
    TestCloseable c2 = closer.register(TestCloseable.normal());
    TestCloseable c3 = closer.register(TestCloseable.normal());

    assertFalse(c1.isClosed());
    assertFalse(c2.isClosed());
    assertFalse(c3.isClosed());

    closer.close();

    assertTrue(c1.isClosed());
    assertTrue(c2.isClosed());
    assertTrue(c3.isClosed());

    assertTrue(suppressor.suppressions.isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: close (Alternative Action: isClosed=6 ) - Predicate: isClosed - Scenario: closer (Alternative Scenario: c3=1 )

Project: guava
 Class: FilesFileTraverserTest
 Method: testFileTraverser_multipleDirectoryLayers_breadthFirstStartsWithTopLayer
 Body: {
    File fileA = newFile("file-a");
    File dir1 = newDir("dir-1");
    newFile("dir-1/file-b");
    newFile("dir-1/dir-2");

    assertThat(Iterables.limit(Files.fileTraverser().breadthFirst(rootDir), 3))
        .containsExactly(rootDir, fileA, dir1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: newFile (Alternative Action: newFile=3 ) - Predicate: N/A - Scenario: dir1 (Alternative Scenario: dir1=1 )

Project: guava
 Class: CountTest
 Method: testGetAndAdd
 Body: {
    Count holder = new Count(20);
    assertEquals(20, holder.get());
    holder.add(1);
    assertEquals(21, holder.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: get=2 ) - Predicate: get - Scenario: holder (Alternative Scenario: holder=1 )

Project: guava
 Class: TrustedListenableFutureTaskTest
 Method: testToString
 Body: {
    final CountDownLatch enterLatch = new CountDownLatch(1);
    final CountDownLatch exitLatch = new CountDownLatch(1);
    final TrustedListenableFutureTask<Void> task =
        TrustedListenableFutureTask.create(
            new Callable<Void>() {
              @Override
              public Void call() throws Exception {
                enterLatch.countDown();
                new CountDownLatch(1).await(); // wait forever
                return null;
              }
            });
    assertFalse(task.isDone());
    Thread thread =
        new Thread(
            new Runnable() {
              @Override
              public void run() {
                try {
                  task.run();
                } finally {
                  exitLatch.countDown();
                }
              }
            },
            "Custom thread name");
    thread.start();
    enterLatch.await();
    assertFalse(task.isDone());
    String result = task.toString();
    assertThat(result).contains("Custom thread name");
    task.cancel(true);
    exitLatch.await();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: start (Alternative Action: await=3 ) - Predicate: isDone - Scenario: enterLatch (Alternative Scenario: result=1 )

Project: guava
 Class: TrustedListenableFutureTaskTest
 Method: testSuccessful
 Body: {
    TrustedListenableFutureTask<Integer> task = TrustedListenableFutureTask.create(returning(2));
    assertFalse(task.isDone());
    task.run();
    assertTrue(task.isDone());
    assertFalse(task.isCancelled());
    assertEquals(2, getDone(task).intValue());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: run (Alternative Action: isDone=2 ) - Predicate: isDone - Scenario: task (Alternative Scenario: task=1 )

Project: guava
 Class: CreationTests
 Method: testBuilderPutAll
 Body: {
      Map<String, Integer> toPut = new LinkedHashMap<>();
      toPut.put("one", 1);
      toPut.put("two", 2);
      toPut.put("three", 3);
      Map<String, Integer> moreToPut = new LinkedHashMap<>();
      moreToPut.put("four", 4);
      moreToPut.put("five", 5);

      ImmutableMap<String, Integer> map =
          new Builder<String, Integer>().putAll(toPut).putAll(moreToPut).build();
      assertMapEquals(map, "one", 1, "two", 2, "three", 3, "four", 4, "five", 5);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: map (Alternative Scenario: toPut=1 )

Project: guava
 Class: CreationTests
 Method: testCopyOf
 Body: {
      Map<String, Integer> original = new LinkedHashMap<>();
      original.put("one", 1);
      original.put("two", 2);
      original.put("three", 3);

      ImmutableMap<String, Integer> copy = ImmutableMap.copyOf(original);
      assertMapEquals(copy, "one", 1, "two", 2, "three", 3);
      assertSame(copy, ImmutableMap.copyOf(copy));
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: CreationTests
 Method: testBuilder_withMutableEntry
 Body: {
      ImmutableMap.Builder<String, Integer> builder = new Builder<>();
      final StringHolder holder = new StringHolder();
      holder.string = "one";
      Entry<String, Integer> entry =
          new AbstractMapEntry<String, Integer>() {
            @Override
            public String getKey() {
              return holder.string;
            }

            @Override
            public Integer getValue() {
              return 1;
            }
          };

      builder.put(entry);
      holder.string = "two";
      assertMapEquals(builder.build(), "one", 1);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: build=1 ) - Predicate: build - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: UnsignedBytesTest
 Method: testLexicographicalComparator
 Body: {
    List<byte[]> ordered =
        Arrays.asList(
            new byte[] {},
            new byte[] {LEAST},
            new byte[] {LEAST, LEAST},
            new byte[] {LEAST, (byte) 1},
            new byte[] {(byte) 1},
            new byte[] {(byte) 1, LEAST},
            new byte[] {GREATEST, GREATEST - (byte) 1},
            new byte[] {GREATEST, GREATEST},
            new byte[] {GREATEST, GREATEST, GREATEST});

    // The Unsafe implementation if it's available. Otherwise, the Java implementation.
    Comparator<byte[]> comparator = UnsignedBytes.lexicographicalComparator();
    Helpers.testComparator(comparator, ordered);
    assertSame(comparator, SerializableTester.reserialize(comparator));

    // The Java implementation.
    Comparator<byte[]> javaImpl = UnsignedBytes.lexicographicalComparatorJavaImpl();
    Helpers.testComparator(javaImpl, ordered);
    assertSame(javaImpl, SerializableTester.reserialize(javaImpl));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testComparator (Alternative Action: testComparator=2 ) - Predicate: reserialize - Scenario: comparator (Alternative Scenario: comparator=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@Nullable Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsSortedTransformValuesTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@Nullable String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: CollectionRemoveTester
 Method: testRemove_present
 Body: {
    int initialSize = collection.size();
    assertTrue("remove(present) should return true", collection.remove(e0()));
    assertEquals(
        "remove(present) should decrease a collection's size by one.",
        initialSize - 1,
        collection.size());
    expectMissing(e0());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: expectMissing (Alternative Action: size=2 ) - Predicate: remove - Scenario: initialSize (Alternative Scenario: initialSize=1 )

Project: guava
 Class: MultimapValuesTester
 Method: testValuesIteratorRemove
 Body: {
    Iterator<V> valuesItr = multimap().values().iterator();
    valuesItr.next();
    valuesItr.remove();
    assertTrue(multimap().isEmpty());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: multimap=2 ) - Predicate: isEmpty - Scenario: valuesItr (Alternative Scenario: valuesItr=1 )

Project: guava
 Class: TestingExecutorsTest
 Method: testNoOpScheduledExecutor
 Body: {
    taskDone = false;
    Runnable task =
        new Runnable() {
          @Override
          public void run() {
            taskDone = true;
          }
        };
    ScheduledFuture<?> future =
        TestingExecutors.noOpScheduledExecutor().schedule(task, 10, TimeUnit.MILLISECONDS);
    Thread.sleep(20);
    assertFalse(taskDone);
    assertFalse(future.isDone());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sleep (Alternative Action: sleep=1 ) - Predicate: N/A - Scenario: future (Alternative Scenario: task=1 )

Project: guava
 Class: TestingExecutorsTest
 Method: testNoOpScheduledExecutorShutdown
 Body: {
    ListeningScheduledExecutorService executor = TestingExecutors.noOpScheduledExecutor();
    assertFalse(executor.isShutdown());
    assertFalse(executor.isTerminated());
    executor.shutdown();
    assertTrue(executor.isShutdown());
    assertTrue(executor.isTerminated());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: shutdown (Alternative Action: isTerminated=2 ) - Predicate: isShutdown - Scenario: executor (Alternative Scenario: executor=1 )

Project: guava
 Class: HashingTest
 Method: testConcatenatingHashFunction_makeHash
 Body: {
    byte[] md5Hash = Hashing.md5().hashLong(42L).asBytes();
    byte[] murmur3Hash = Hashing.murmur3_32().hashLong(42L).asBytes();
    byte[] combined = new byte[md5Hash.length + murmur3Hash.length];
    ByteBuffer buffer = ByteBuffer.wrap(combined);
    buffer.put(md5Hash);
    buffer.put(murmur3Hash);
    HashCode expected = HashCode.fromBytes(combined);

    assertEquals(
        expected, Hashing.concatenating(Hashing.md5(), Hashing.murmur3_32()).hashLong(42L));
    assertEquals(
        expected, Hashing.concatenating(asList(Hashing.md5(), Hashing.murmur3_32())).hashLong(42L));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: hashLong=4 ) - Predicate: hashLong - Scenario: expected (Alternative Scenario: md5Hash=1 )

Project: guava
 Class: HashingTest
 Method: testGoodFastHashEquals
 Body: {
    HashFunction hashFunction1a = Hashing.goodFastHash(1);
    HashFunction hashFunction1b = Hashing.goodFastHash(32);
    HashFunction hashFunction2a = Hashing.goodFastHash(33);
    HashFunction hashFunction2b = Hashing.goodFastHash(128);
    HashFunction hashFunction3a = Hashing.goodFastHash(129);
    HashFunction hashFunction3b = Hashing.goodFastHash(256);
    HashFunction hashFunction4a = Hashing.goodFastHash(257);
    HashFunction hashFunction4b = Hashing.goodFastHash(384);

    new EqualsTester()
        .addEqualityGroup(hashFunction1a, hashFunction1b)
        .addEqualityGroup(hashFunction2a, hashFunction2b)
        .addEqualityGroup(hashFunction3a, hashFunction3b)
        .addEqualityGroup(hashFunction4a, hashFunction4b)
        .testEquals();

    assertEquals(hashFunction1a.toString(), hashFunction1b.toString());
    assertEquals(hashFunction2a.toString(), hashFunction2b.toString());
    assertEquals(hashFunction3a.toString(), hashFunction3b.toString());
    assertEquals(hashFunction4a.toString(), hashFunction4b.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: goodFastHash=8 ) - Predicate: toString - Scenario: hashFunction4b (Alternative Scenario: hashFunction4a=1 )

Project: guava
 Class: EnumBiMapTest
 Method: testKeySetIteratorRemove
 Body: {
    // The enum orderings are alphabetical, leading to the bimap and its inverse
    // having inconsistent iteration orderings.
    Map<Currency, Country> map =
        ImmutableMap.of(
            Currency.DOLLAR, Country.CANADA,
            Currency.PESO, Country.CHILE,
            Currency.FRANC, Country.SWITZERLAND);
    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);

    Iterator<Currency> iter = bimap.keySet().iterator();
    assertEquals(Currency.DOLLAR, iter.next());
    iter.remove();

    // forward map ordered by currency
    assertThat(bimap.keySet()).containsExactly(Currency.FRANC, Currency.PESO).inOrder();
    // forward map ordered by currency (even for country values)
    assertThat(bimap.values()).containsExactly(Country.SWITZERLAND, Country.CHILE).inOrder();
    // backward map ordered by country
    assertThat(bimap.inverse().keySet())
        .containsExactly(Country.CHILE, Country.SWITZERLAND)
        .inOrder();
    // backward map ordered by country (even for currency values)
    assertThat(bimap.inverse().values()).containsExactly(Currency.PESO, Currency.FRANC).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: keySet=3 ) - Predicate: next - Scenario: map (Alternative Scenario: bimap=1 )

Project: guava
 Class: EnumBiMapTest
 Method: testEntrySet
 Body: {
    // Bug 3168290
    Map<Currency, Country> map =
        ImmutableMap.of(
            Currency.DOLLAR, Country.CANADA,
            Currency.PESO, Country.CHILE,
            Currency.FRANC, Country.SWITZERLAND);
    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);
    Set<Object> uniqueEntries = Sets.newIdentityHashSet();
    uniqueEntries.addAll(bimap.entrySet());
    assertEquals(3, uniqueEntries.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: size=1 ) - Predicate: size - Scenario: uniqueEntries (Alternative Scenario: bimap=1 )

Project: guava
 Class: EnumBiMapTest
 Method: testEnumBiMapConstructor
 Body: {
    /* Test that it copies existing entries. */
    EnumBiMap<Currency, Country> bimap1 = EnumBiMap.create(Currency.class, Country.class);
    bimap1.put(Currency.DOLLAR, Country.CANADA);
    EnumBiMap<Currency, Country> bimap2 = EnumBiMap.create(bimap1);
    assertEquals(Country.CANADA, bimap2.get(Currency.DOLLAR));
    assertEquals(bimap1, bimap2);
    bimap2.inverse().put(Country.SWITZERLAND, Currency.FRANC);
    assertEquals(Country.SWITZERLAND, bimap2.get(Currency.FRANC));
    assertNull(bimap1.get(Currency.FRANC));
    assertFalse(bimap2.equals(bimap1));

    /* Test that it can be empty. */
    EnumBiMap<Currency, Country> emptyBimap = EnumBiMap.create(Currency.class, Country.class);
    EnumBiMap<Currency, Country> bimap3 = EnumBiMap.create(emptyBimap);
    assertEquals(bimap3, emptyBimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: create=4 ) - Predicate: get - Scenario: bimap2 (Alternative Scenario: bimap2=1 )

Project: guava
 Class: EnumBiMapTest
 Method: testValuesIteratorRemove
 Body: {
    // The enum orderings are alphabetical, leading to the bimap and its inverse
    // having inconsistent iteration orderings.
    Map<Currency, Country> map =
        ImmutableMap.of(
            Currency.DOLLAR, Country.CANADA,
            Currency.PESO, Country.CHILE,
            Currency.FRANC, Country.SWITZERLAND);
    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(map);

    Iterator<Currency> iter = bimap.keySet().iterator();
    assertEquals(Currency.DOLLAR, iter.next());
    assertEquals(Currency.FRANC, iter.next());
    iter.remove();

    // forward map ordered by currency
    assertThat(bimap.keySet()).containsExactly(Currency.DOLLAR, Currency.PESO).inOrder();
    // forward map ordered by currency (even for country values)
    assertThat(bimap.values()).containsExactly(Country.CANADA, Country.CHILE).inOrder();
    // backward map ordered by country
    assertThat(bimap.inverse().keySet()).containsExactly(Country.CANADA, Country.CHILE).inOrder();
    // backward map ordered by country (even for currency values)
    assertThat(bimap.inverse().values()).containsExactly(Currency.DOLLAR, Currency.PESO).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: keySet=3 ) - Predicate: next - Scenario: map (Alternative Scenario: bimap=1 )

Project: guava
 Class: EnumBiMapTest
 Method: testCreate
 Body: {
    EnumBiMap<Currency, Country> bimap = EnumBiMap.create(Currency.class, Country.class);
    assertTrue(bimap.isEmpty());
    assertEquals("{}", bimap.toString());
    assertEquals(HashBiMap.create(), bimap);
    bimap.put(Currency.DOLLAR, Country.CANADA);
    assertEquals(Country.CANADA, bimap.get(Currency.DOLLAR));
    assertEquals(Currency.DOLLAR, bimap.inverse().get(Country.CANADA));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: isEmpty - Scenario: bimap (Alternative Scenario: bimap=1 )

Project: guava
 Class: ImmutableIntArrayTest
 Method: testCopyOf_iterable_collection_nonempty
 Body: {
    List<Integer> list = Arrays.asList(0, 1, 3);
    ImmutableIntArray iia = ImmutableIntArray.copyOf((Iterable<Integer>) list);
    list.set(2, 2);
    assertThat(iia.asList()).containsExactly(0, 1, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableIntArrayTest
 Method: testCopyOf_collection_nonempty
 Body: {
    List<Integer> list = Arrays.asList(0, 1, 3);
    ImmutableIntArray iia = ImmutableIntArray.copyOf(list);
    list.set(2, 2);
    assertThat(iia.asList()).containsExactly(0, 1, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableIntArrayTest
 Method: testForEach
 Body: {
    ImmutableIntArray.of().forEach(i -> fail());
    ImmutableIntArray.of(0, 1, 3).subArray(1, 1).forEach(i -> fail());

    AtomicInteger count = new AtomicInteger(0);
    ImmutableIntArray.of(0, 1, 2, 3).forEach(i -> assertThat(i).isEqualTo(count.getAndIncrement()));
    assertEquals(4, count.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: of=3 ) - Predicate: N/A - Scenario: count (Alternative Scenario: count=1 )

Project: guava
 Class: ImmutableIntArrayTest
 Method: testBuilder_presize_zero
 Body: {
    ImmutableIntArray.Builder builder = ImmutableIntArray.builder(0);
    builder.add(5);
    ImmutableIntArray array = builder.build();
    assertThat(array.asList()).containsExactly(5);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: N/A - Scenario: array (Alternative Scenario: array=1 )

Project: guava
 Class: ImmutableIntArrayTest
 Method: testCopyOf_iterable_notCollection_nonempty
 Body: {
    List<Integer> list = Arrays.asList(0, 1, 3);
    ImmutableIntArray iia = ImmutableIntArray.copyOf(iterable(list));
    list.set(2, 2);
    assertThat(iia.asList()).containsExactly(0, 1, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testInvalidatingRemove2
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    List<Integer> values =
        Lists.newArrayList(
            1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5, 6, 7, 8, 9, 4, 5,
            200, 250);
    mmHeap.addAll(values);
    assertEquals(25, mmHeap.size());
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    mmHeap.remove(2);
    assertEquals(24, mmHeap.size());
    assertTrue("Heap is not intact after remove()", mmHeap.isIntact());
    values.removeAll(Lists.newArrayList(2));
    assertEquals(values.size(), mmHeap.size());
    assertTrue(values.containsAll(mmHeap));
    assertTrue(mmHeap.containsAll(values));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: size=4 ) - Predicate: size - Scenario: values (Alternative Scenario: values=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_expectedSize_withContents
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.expectedSize(8).create(NUMBERS);
    assertEquals(6, queue.size());
    assertEquals(8, queue.capacity());
    checkUnbounded(queue);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: size=1 ) - Predicate: size - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testRemoveFromStringHeap
 Body: {
    MinMaxPriorityQueue<String> mmHeap = MinMaxPriorityQueue.expectedSize(5).create();
    Collections.addAll(mmHeap, "foo", "bar", "foobar", "barfoo", "larry", "sergey", "eric");
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    assertEquals("bar", mmHeap.peek());
    assertEquals("sergey", mmHeap.peekLast());
    assertEquals(7, mmHeap.size());
    assertTrue("Could not remove larry", mmHeap.remove("larry"));
    assertEquals(6, mmHeap.size());
    assertFalse("heap contains larry which has been removed", mmHeap.contains("larry"));
    assertTrue("heap does not contain sergey", mmHeap.contains("sergey"));
    assertTrue("Could not remove larry", mmHeap.removeAll(Lists.newArrayList("sergey", "eric")));
    assertFalse("Could remove nikesh which is not in the heap", mmHeap.remove("nikesh"));
    assertEquals(4, mmHeap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: size=3 ) - Predicate: isIntact - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testIteratorInvalidatingIteratorRemove2
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(
        Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    Iterator<Integer> it = mmHeap.iterator();
    assertEquals((Integer) 1, it.next());
    assertEquals((Integer) 20, it.next());
    assertEquals((Integer) 1000, it.next());
    assertEquals((Integer) 2, it.next());
    it.remove();
    // After this remove, 400 has moved up and 20 down past cursor
    assertTrue("Heap is not intact after remove", mmHeap.isIntact());
    assertEquals((Integer) 10, it.next());
    assertEquals((Integer) 3, it.next());
    it.remove();
    // After this remove, 400 moved down again and 500 up past the cursor
    assertTrue("Heap is not intact after remove", mmHeap.isIntact());
    assertEquals((Integer) 12, it.next());
    assertEquals((Integer) 30, it.next());
    assertEquals((Integer) 40, it.next());
    // Skipping 20
    assertEquals((Integer) 11, it.next());
    // Not skipping 400, because it moved back down
    assertEquals((Integer) 400, it.next());
    assertEquals((Integer) 13, it.next());
    assertEquals((Integer) 200, it.next());
    assertEquals((Integer) 300, it.next());
    // Last from forgetMeNot.
    assertEquals((Integer) 500, it.next());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: next=15 ) - Predicate: isIntact - Scenario: mmHeap (Alternative Scenario: it=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testInvalidatingRemove
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(
        Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600));
    assertEquals(15, mmHeap.size());
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    mmHeap.remove(12);
    assertEquals(14, mmHeap.size());
    assertTrue("Heap is not intact after remove()", mmHeap.isIntact());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: isIntact=2 ) - Predicate: size - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testSmallMinHeap
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.add(1);
    mmHeap.add(3);
    mmHeap.add(2);
    assertEquals(1, (int) mmHeap.peek());
    assertEquals(1, (int) mmHeap.poll());
    assertEquals(3, (int) mmHeap.peekLast());
    assertEquals(2, (int) mmHeap.peek());
    assertEquals(2, (int) mmHeap.poll());
    assertEquals(3, (int) mmHeap.peekLast());
    assertEquals(3, (int) mmHeap.peek());
    assertEquals(3, (int) mmHeap.poll());
    assertNull(mmHeap.peekLast());
    assertNull(mmHeap.peek());
    assertNull(mmHeap.poll());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: poll=4 ) - Predicate: N/A - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_expectedSize
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.expectedSize(8).create();
    assertEquals(8, queue.capacity());
    checkUnbounded(queue);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: checkUnbounded=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_withContents
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create(NUMBERS);
    assertEquals(6, queue.size());
    assertEquals(11, queue.capacity());
    checkUnbounded(queue);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: size=1 ) - Predicate: size - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_expectedSize_comparator
 Body: {
    MinMaxPriorityQueue<Integer> queue =
        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).expectedSize(8).create();
    assertEquals(8, queue.capacity());
    checkUnbounded(queue);
    assertSame(SOME_COMPARATOR, queue.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: comparator=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreateWithOrdering
 Body: {
    MinMaxPriorityQueue<String> mmHeap =
        MinMaxPriorityQueue.orderedBy(Ordering.natural().reverse()).create();
    Collections.addAll(mmHeap, "foo", "bar", "foobar", "barfoo", "larry", "sergey", "eric");
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    assertEquals("sergey", mmHeap.peek());
    assertEquals("bar", mmHeap.peekLast());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: isIntact=1 ) - Predicate: isIntact - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testRemoveRegression
 Body: {
    MinMaxPriorityQueue<Long> queue =
        MinMaxPriorityQueue.create(ImmutableList.of(2L, 3L, 0L, 4L, 1L));
    queue.remove(4L);
    queue.remove(1L);
    assertThat(queue).doesNotContain(1L);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: remove=2 ) - Predicate: N/A - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_maximumSize_withContents
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.maximumSize(42).create(NUMBERS);
    assertEquals(6, queue.size());
    assertEquals(11, queue.capacity());
    assertEquals(42, queue.maximumSize);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkNatural (Alternative Action: size=1 ) - Predicate: size - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_maximumSize
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.maximumSize(42).create();
    assertEquals(11, queue.capacity());
    assertEquals(42, queue.maximumSize);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkNatural (Alternative Action: maximumSize=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testSmall
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.add(1);
    mmHeap.add(4);
    mmHeap.add(2);
    mmHeap.add(3);
    assertEquals(4, (int) mmHeap.pollLast());
    assertEquals(3, (int) mmHeap.peekLast());
    assertEquals(3, (int) mmHeap.pollLast());
    assertEquals(1, (int) mmHeap.peek());
    assertEquals(2, (int) mmHeap.peekLast());
    assertEquals(2, (int) mmHeap.pollLast());
    assertEquals(1, (int) mmHeap.peek());
    assertEquals(1, (int) mmHeap.peekLast());
    assertEquals(1, (int) mmHeap.pollLast());
    assertNull(mmHeap.peek());
    assertNull(mmHeap.peekLast());
    assertNull(mmHeap.pollLast());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: pollLast=5 ) - Predicate: N/A - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_comparator
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).create();
    assertEquals(11, queue.capacity());
    checkUnbounded(queue);
    assertSame(SOME_COMPARATOR, queue.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: comparator=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testRemove
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(Lists.newArrayList(1, 2, 3, 4, 47, 1, 5, 3, 0));
    assertTrue("Heap is not intact initally", mmHeap.isIntact());
    assertEquals(9, mmHeap.size());
    mmHeap.remove(5);
    assertEquals(8, mmHeap.size());
    assertTrue("Heap is not intact after remove()", mmHeap.isIntact());
    assertEquals(47, (int) mmHeap.pollLast());
    assertEquals(4, (int) mmHeap.pollLast());
    mmHeap.removeAll(Lists.newArrayList(2, 3));
    assertEquals(3, mmHeap.size());
    assertTrue("Heap is not intact after removeAll()", mmHeap.isIntact());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: isIntact=3 ) - Predicate: isIntact - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_comparator_withContents
 Body: {
    MinMaxPriorityQueue<Integer> queue =
        MinMaxPriorityQueue.orderedBy(SOME_COMPARATOR).create(NUMBERS);
    assertEquals(6, queue.size());
    assertEquals(11, queue.capacity());
    checkUnbounded(queue);
    assertSame(SOME_COMPARATOR, queue.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: comparator=1 ) - Predicate: size - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_expectedSize_maximumSize
 Body: {
    MinMaxPriorityQueue<Integer> queue =
        MinMaxPriorityQueue.expectedSize(8).maximumSize(42).create();
    assertEquals(8, queue.capacity());
    assertEquals(42, queue.maximumSize);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkNatural (Alternative Action: maximumSize=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreateWithCapacityAndOrdering
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap =
        MinMaxPriorityQueue.orderedBy(Ordering.natural().reverse()).expectedSize(5).create();
    Collections.addAll(mmHeap, 1, 7, 2, 56, 2, 5, 23, 68, 0, 3);
    assertTrue("Heap is not intact initially", mmHeap.isIntact());
    assertEquals(68, (int) mmHeap.peek());
    assertEquals(0, (int) mmHeap.peekLast());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: isIntact=1 ) - Predicate: isIntact - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testContains
 Body: {
    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();
    mmHeap.addAll(Lists.newArrayList(1, 1, 2));
    assertEquals(3, mmHeap.size());
    assertFalse("Heap does not contain null", mmHeap.contains(null));
    assertFalse("Heap does not contain 3", mmHeap.contains(3));
    assertFalse("Heap does not contain 3", mmHeap.remove(3));
    assertEquals(3, mmHeap.size());
    assertTrue("Heap is not intact after remove()", mmHeap.isIntact());
    assertTrue("Heap contains two 1's", mmHeap.contains(1));
    assertTrue("Heap contains two 1's", mmHeap.remove(1));
    assertTrue("Heap contains 1", mmHeap.contains(1));
    assertTrue("Heap contains 1", mmHeap.remove(1));
    assertFalse("Heap does not contain 1", mmHeap.contains(1));
    assertTrue("Heap contains 2", mmHeap.remove(2));
    assertEquals(0, mmHeap.size());
    assertFalse("Heap does not contain anything", mmHeap.contains(1));
    assertFalse("Heap does not contain anything", mmHeap.remove(2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: contains=6 ) - Predicate: size - Scenario: mmHeap (Alternative Scenario: mmHeap=1 )

Project: guava
 Class: MinMaxPriorityQueueTest
 Method: testCreation_simple
 Body: {
    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create();
    assertEquals(11, queue.capacity());
    checkUnbounded(queue);
    checkNatural(queue);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnbounded (Alternative Action: checkUnbounded=1 ) - Predicate: capacity - Scenario: queue (Alternative Scenario: queue=1 )

Project: guava
 Class: TypesTest
 Method: testNewTypeVariable
 Body: {
    TypeVariable<?> noBoundJvmType = WithTypeVariable.getTypeVariable("withoutBound");
    TypeVariable<?> objectBoundJvmType = WithTypeVariable.getTypeVariable("withObjectBound");
    TypeVariable<?> upperBoundJvmType = WithTypeVariable.getTypeVariable("withUpperBound");
    TypeVariable<?> noBound = withBounds(noBoundJvmType);
    TypeVariable<?> objectBound = withBounds(objectBoundJvmType, Object.class);
    TypeVariable<?> upperBound = withBounds(upperBoundJvmType, Number.class, CharSequence.class);

    assertEqualTypeVariable(noBoundJvmType, noBound);
    assertEqualTypeVariable(noBoundJvmType, withBounds(noBoundJvmType, Object.class));
    assertEqualTypeVariable(objectBoundJvmType, objectBound);
    assertEqualTypeVariable(upperBoundJvmType, upperBound);

    new TypeVariableEqualsTester()
        .addEqualityGroup(noBoundJvmType, noBound)
        .addEqualityGroup(objectBoundJvmType, objectBound)
        .addEqualityGroup(upperBoundJvmType, upperBound)
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: withBounds=4 ) - Predicate: N/A - Scenario: noBoundJvmType (Alternative Scenario: noBound=1 )

Project: guava
 Class: TypesTest
 Method: testNewArrayType
 Body: {
    Type jvmType1 = new TypeCapture<List<String>[]>() {}.capture();
    GenericArrayType ourType1 =
        (GenericArrayType) Types.newArrayType(Types.newParameterizedType(List.class, String.class));
    Type jvmType2 = new TypeCapture<List[]>() {}.capture();
    Type ourType2 = Types.newArrayType(List.class);
    new EqualsTester()
        .addEqualityGroup(jvmType1, ourType1)
        .addEqualityGroup(jvmType2, ourType2)
        .testEquals();
    assertEquals(new TypeCapture<List<String>>() {}.capture(), ourType1.getGenericComponentType());
    assertEquals(jvmType1.toString(), ourType1.toString());
    assertEquals(jvmType2.toString(), ourType2.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: toString=4 ) - Predicate: capture - Scenario: ourType2 (Alternative Scenario: ourType2=1 )

Project: guava
 Class: TypesTest
 Method: testNewParameterizedTypeWithOwner
 Body: {
    ParameterizedType jvmType =
        (ParameterizedType) new TypeCapture<Entry<String, int[][]>>() {}.capture();
    ParameterizedType ourType =
        Types.newParameterizedTypeWithOwner(Map.class, Entry.class, String.class, int[][].class);

    new EqualsTester()
        .addEqualityGroup(jvmType, ourType)
        .addEqualityGroup(new TypeCapture<Entry<String, String>>() {}.capture())
        .addEqualityGroup(new TypeCapture<Map<String, Integer>>() {}.capture())
        .testEquals();
    assertEquals(jvmType.toString(), ourType.toString());
    assertEquals(Map.class, ourType.getOwnerType());
    assertEquals(Entry.class, ourType.getRawType());
    assertThat(ourType.getActualTypeArguments())
        .asList()
        .containsExactlyElementsIn(asList(jvmType.getActualTypeArguments()))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: addEqualityGroup=3 ) - Predicate: toString - Scenario: ourType (Alternative Scenario: jvmType=1 )

Project: guava
 Class: TypesTest
 Method: testNewArrayType_primitive
 Body: {
    Type jvmType = new TypeCapture<int[]>() {}.capture();
    Type ourType = Types.newArrayType(int.class);
    assertEquals(jvmType.toString(), ourType.toString());
    new EqualsTester().addEqualityGroup(jvmType, ourType).testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: toString=2 ) - Predicate: toString - Scenario: jvmType (Alternative Scenario: jvmType=1 )

Project: guava
 Class: TypesTest
 Method: testNewParameterizedType
 Body: {
    ParameterizedType jvmType =
        (ParameterizedType) new TypeCapture<HashMap<String, int[][]>>() {}.capture();
    ParameterizedType ourType =
        Types.newParameterizedType(HashMap.class, String.class, int[][].class);

    new EqualsTester().addEqualityGroup(jvmType, ourType).testEquals();
    assertEquals(jvmType.toString(), ourType.toString());
    assertEquals(jvmType.hashCode(), ourType.hashCode());
    assertEquals(HashMap.class, ourType.getRawType());
    assertThat(ourType.getActualTypeArguments())
        .asList()
        .containsExactlyElementsIn(asList(jvmType.getActualTypeArguments()))
        .inOrder();
    assertEquals(
        Arrays.asList(String.class, Types.newArrayType(Types.newArrayType(int.class))),
        Arrays.asList(ourType.getActualTypeArguments()));
    assertEquals(null, ourType.getOwnerType());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: getActualTypeArguments=3 ) - Predicate: toString - Scenario: ourType (Alternative Scenario: jvmType=1 )

Project: guava
 Class: TypesTest
 Method: testNewArrayTypeOfArray
 Body: {
    Type jvmType = new TypeCapture<int[][]>() {}.capture();
    Type ourType = Types.newArrayType(int[].class);
    assertEquals(jvmType.toString(), ourType.toString());
    new EqualsTester().addEqualityGroup(jvmType, ourType).testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: toString=2 ) - Predicate: toString - Scenario: jvmType (Alternative Scenario: jvmType=1 )

Project: guava
 Class: TypesTest
 Method: testNewWildcardType
 Body: {
    WildcardType noBoundJvmType = WithWildcardType.getWildcardType("withoutBound");
    WildcardType objectBoundJvmType = WithWildcardType.getWildcardType("withObjectBound");
    WildcardType upperBoundJvmType = WithWildcardType.getWildcardType("withUpperBound");
    WildcardType lowerBoundJvmType = WithWildcardType.getWildcardType("withLowerBound");
    WildcardType objectBound = Types.subtypeOf(Object.class);
    WildcardType upperBound = Types.subtypeOf(int[][].class);
    WildcardType lowerBound = Types.supertypeOf(String[][].class);

    assertEqualWildcardType(noBoundJvmType, objectBound);
    assertEqualWildcardType(objectBoundJvmType, objectBound);
    assertEqualWildcardType(upperBoundJvmType, upperBound);
    assertEqualWildcardType(lowerBoundJvmType, lowerBound);

    new EqualsTester()
        .addEqualityGroup(noBoundJvmType, objectBoundJvmType, objectBound)
        .addEqualityGroup(upperBoundJvmType, upperBound)
        .addEqualityGroup(lowerBoundJvmType, lowerBound)
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: getWildcardType=4 ) - Predicate: N/A - Scenario: noBoundJvmType (Alternative Scenario: upperBound=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testTrustedGetFailure_Failed
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isEqualTo(failure);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setException (Alternative Action: tryInternalFastPathGetFailure=1 ) - Predicate: N/A - Scenario: failure (Alternative Scenario: failure=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testListenersExecuteImmediately_afterWaiterWakesUp
 Body: {
    final AbstractFuture<String> f =
        new AbstractFuture<String>() {
          @Override
          protected void afterDone() {
            // this simply delays executing listeners
            try {
              Thread.sleep(TimeUnit.SECONDS.toMillis(10));
            } catch (InterruptedException ignored) {
              Thread.currentThread().interrupt(); // preserve status
            }
          }
        };
    Thread t =
        new Thread() {
          @Override
          public void run() {
            f.set("foo");
          }
        };
    t.start();
    f.get();
    final AtomicBoolean ranImmediately = new AtomicBoolean();
    f.addListener(
        new Runnable() {
          @Override
          public void run() {
            ranImmediately.set(true);
          }
        },
        MoreExecutors.directExecutor());
    assertThat(ranImmediately.get()).isTrue();
    t.interrupt();
    t.join();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addListener (Alternative Action: set=2 ) - Predicate: N/A - Scenario: ranImmediately (Alternative Scenario: ranImmediately=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testSetFuture_misbehavingFutureDoesNotThrow
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    ListenableFuture<String> badFuture =
        new ListenableFuture<String>() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }

          @Override
          public boolean isDone() {
            return true;
          }

          @Override
          public boolean isCancelled() {
            return true; // BAD!!
          }

          @Override
          public String get() {
            return "foo"; // BAD!!
          }

          @Override
          public String get(long time, TimeUnit unit) {
            return "foo"; // BAD!!
          }

          @Override
          public void addListener(Runnable runnable, Executor executor) {
            executor.execute(runnable);
          }
        };
    future.setFuture(badFuture);
    assertThat(future.isCancelled()).isTrue();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setFuture (Alternative Action: isCancelled=1 ) - Predicate: N/A - Scenario: badFuture (Alternative Scenario: badFuture=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testSetFutureSelf_cancel
 Body: {
    SettableFuture<String> orig = SettableFuture.create();
    orig.setFuture(orig);
    orig.cancel(true);
    assertTrue(orig.isCancelled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setFuture (Alternative Action: cancel=1 ) - Predicate: isCancelled - Scenario: orig (Alternative Scenario: orig=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testException
 Body: {
    final Throwable failure = new Throwable();
    AbstractFuture<String> future =
        new AbstractFuture<String>() {
          {
            setException(failure);
          }
        };

    ExecutionException ee1 = getExpectingExecutionException(future);
    ExecutionException ee2 = getExpectingExecutionException(future);

    // Ensure we get a unique execution exception on each get
    assertNotSame(ee1, ee2);

    assertSame(failure, ee1.getCause());
    assertSame(failure, ee2.getCause());

    checkStackTrace(ee1);
    checkStackTrace(ee2);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkStackTrace (Alternative Action: checkStackTrace=2 ) - Predicate: N/A - Scenario: failure (Alternative Scenario: ee1=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testGetFailure_Failed
 Body: {
    AbstractFuture<String> future = new AbstractFuture<String>() {};
    final Throwable failure = new Throwable();
    future.setException(failure);
    assertThat(future.tryInternalFastPathGetFailure()).isNull();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setException (Alternative Action: tryInternalFastPathGetFailure=1 ) - Predicate: N/A - Scenario: failure (Alternative Scenario: failure=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testToString_completed
 Body: {
    AbstractFuture<Object> testFuture2 =
        new AbstractFuture<Object>() {
          @Override
          public String pendingToString() {
            return "cause=[Someday...]";
          }
        };
    AbstractFuture<Object> testFuture3 = new AbstractFuture<Object>() {};
    testFuture3.setFuture(testFuture2);
    assertThat(testFuture3.toString())
        .matches(
            "[^\\[]+\\[status=PENDING, info=\\[setFuture="
                + "\\[[^\\[]+\\[status=PENDING, info=\\[cause=\\[Someday...\\]\\]\\]\\]\\]\\]");
    testFuture2.set("result string");
    assertThat(testFuture3.toString())
        .matches("[^\\[]+\\[status=SUCCESS, result=\\[result string\\]\\]");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setFuture (Alternative Action: toString=2 ) - Predicate: N/A - Scenario: testFuture3 (Alternative Scenario: testFuture2=1 )

Project: guava
 Class: AbstractFutureTest
 Method: testSetFuture_misbehavingFutureThrows
 Body: {
    SettableFuture<String> future = SettableFuture.create();
    ListenableFuture<String> badFuture =
        new ListenableFuture<String>() {
          @Override
          public boolean cancel(boolean interrupt) {
            return false;
          }

          @Override
          public boolean isDone() {
            return true;
          }

          @Override
          public boolean isCancelled() {
            return false; // BAD!!
          }

          @Override
          public String get() {
            throw new CancellationException(); // BAD!!
          }

          @Override
          public String get(long time, TimeUnit unit) {
            throw new CancellationException(); // BAD!!
          }

          @Override
          public void addListener(Runnable runnable, Executor executor) {
            executor.execute(runnable);
          }
        };
    future.setFuture(badFuture);
    ExecutionException expected = getExpectingExecutionException(future);
    assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
    assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setFuture (Alternative Action: setFuture=1 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: badFuture=1 )

Project: guava
 Class: ImmutableMultisetTest
 Method: testIterationOrderThroughBuilderRemovals
 Body: {
    ImmutableMultiset.Builder<String> builder = ImmutableMultiset.builder();
    builder.addCopies("a", 2);
    builder.add("b");
    builder.add("c");
    builder.setCount("b", 0);
    ImmutableMultiset<String> multiset = builder.build();
    assertThat(multiset.elementSet()).containsExactly("a", "c").inOrder();
    builder.add("b");
    assertThat(builder.build().elementSet()).containsExactly("a", "c", "b").inOrder();
    assertThat(multiset.elementSet()).containsExactly("a", "c").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setCount (Alternative Action: add=3 ) - Predicate: N/A - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: ImmutableMultisetTest
 Method: testCreation_arrayOfArray
 Body: {
    String[] array = new String[] {"a"};
    Multiset<String[]> multiset = ImmutableMultiset.<String[]>of(array);
    Multiset<String[]> expected = HashMultiset.create();
    expected.add(array);
    assertEquals(expected, multiset);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: multiset=1 )

Project: guava
 Class: FunctionalTest
 Method: testServiceStartStop
 Body: {
      AbstractIdleService service = new DefaultService();
      service.startAsync().awaitRunning();
      assertEquals(Service.State.RUNNING, service.state());
      service.stopAsync().awaitTerminated();
      assertEquals(Service.State.TERMINATED, service.state());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=2 ) - Predicate: state - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: WrappingExecutorServiceTest
 Method: testExecute
 Body: {
    MockExecutor mock = new MockExecutor();
    TestExecutor testExecutor = new TestExecutor(mock);
    testExecutor.execute(doNothing());
    mock.assertLastMethodCalled("execute");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: execute (Alternative Action: doNothing=1 ) - Predicate: N/A - Scenario: testExecutor (Alternative Scenario: mock=1 )

Project: guava
 Class: WrappingExecutorServiceTest
 Method: testDelegations
 Body: {
    MockExecutor mock = new MockExecutor();
    TestExecutor testExecutor = new TestExecutor(mock);
    assertFalse(testExecutor.awaitTermination(10, TimeUnit.MILLISECONDS));
    mock.assertLastMethodCalled("awaitTermination");
    assertFalse(testExecutor.isTerminated());
    mock.assertLastMethodCalled("isTerminated");
    assertFalse(testExecutor.isShutdown());
    mock.assertLastMethodCalled("isShutdown");
    testExecutor.shutdown();
    mock.assertLastMethodCalled("shutdown");
    List<Runnable> list = testExecutor.shutdownNow();
    mock.assertLastMethodCalled("shutdownNow");
    assertEquals(ImmutableList.of(), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: shutdown (Alternative Action: isTerminated=1 ) - Predicate: awaitTermination - Scenario: mock (Alternative Scenario: mock=1 )

Project: guava
 Class: HashMultimapTest
 Method: testCreate
 Body: {
    HashMultimap<String, Integer> multimap = HashMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    assertEquals(ImmutableSet.of(1, 3), multimap.get("foo"));
    assertEquals(2, multimap.expectedValuesPerKey);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: HashMultimapTest
 Method: testCreateFromMultimap
 Body: {
    HashMultimap<String, Integer> multimap = HashMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    HashMultimap<String, Integer> copy = HashMultimap.create(multimap);
    assertEquals(multimap, copy);
    assertEquals(2, copy.expectedValuesPerKey);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: HashMultimapTest
 Method: testCreateFromSizes
 Body: {
    HashMultimap<String, Integer> multimap = HashMultimap.create(20, 15);
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    assertEquals(ImmutableSet.of(1, 3), multimap.get("foo"));
    assertEquals(15, multimap.expectedValuesPerKey);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: MultisetForEachEntryTester
 Method: testForEachEntry
 Body: {
    List<Entry<E>> expected = new ArrayList<>(getMultiset().entrySet());
    List<Entry<E>> actual = new ArrayList<>();
    getMultiset()
        .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));
    Helpers.assertEqualIgnoringOrder(expected, actual);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachEntry (Alternative Action: getMultiset=2 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: MultisetForEachEntryTester
 Method: testForEachEntryDuplicates
 Body: {
    initThreeCopies();
    List<Entry<E>> expected = Collections.singletonList(Multisets.immutableEntry(e0(), 3));
    List<Entry<E>> actual = new ArrayList<>();
    getMultiset()
        .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));
    assertEquals(expected, actual);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachEntry (Alternative Action: immutableEntry=2 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: MultisetForEachEntryTester
 Method: testForEachEntryOrdered
 Body: {
    List<Entry<E>> expected = new ArrayList<>(getMultiset().entrySet());
    List<Entry<E>> actual = new ArrayList<>();
    getMultiset()
        .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));
    assertEquals(expected, actual);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachEntry (Alternative Action: getMultiset=2 ) - Predicate: N/A - Scenario: actual (Alternative Scenario: actual=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewMultimap
 Body: {
    // The ubiquitous EnumArrayBlockingQueueMultimap
    CountingSupplier<Queue<Integer>> factory = new QueueSupplier();

    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals("[3, 1, 4]", multimap.get(Color.BLUE).toString());

    Multimap<Color, Integer> ummodifiable = Multimaps.unmodifiableMultimap(multimap);
    assertEquals("[3, 1, 4]", ummodifiable.get(Color.BLUE).toString());

    Collection<Integer> collection = multimap.get(Color.BLUE);
    assertEquals(collection, collection);

    assertFalse(multimap.keySet() instanceof SortedSet);
    assertFalse(multimap.asMap() instanceof SortedMap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: get=3 ) - Predicate: N/A - Scenario: factory (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testUnmodifiableArrayListMultimapRandomAccess
 Body: {
    ListMultimap<String, Integer> delegate = ArrayListMultimap.create();
    delegate.put("foo", 1);
    delegate.put("foo", 3);
    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);
    assertTrue(multimap.get("foo") instanceof RandomAccess);
    assertTrue(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: delegate=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewSetMultimap
 Body: {
    CountingSupplier<Set<Integer>> factory = new SetSupplier();
    Map<Color, Collection<Integer>> map = Maps.newHashMap();
    SetMultimap<Color, Integer> multimap = Multimaps.newSetMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals(Sets.newHashSet(4, 3, 1), multimap.get(Color.BLUE));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: factory (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewListMultimapSerialization
 Body: {
    CountingSupplier<LinkedList<Integer>> factory = new ListSupplier();
    Map<Color, Collection<Integer>> map = Maps.newTreeMap();
    ListMultimap<Color, Integer> multimap = Multimaps.newListMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testForMapAsMap
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("foo", 1);
    map.put("bar", 2);
    Map<String, Collection<Integer>> asMap = Multimaps.forMap(map).asMap();
    assertEquals(Collections.singleton(1), asMap.get("foo"));
    assertNull(asMap.get("cow"));
    assertTrue(asMap.containsKey("foo"));
    assertFalse(asMap.containsKey("cow"));

    Set<Entry<String, Collection<Integer>>> entries = asMap.entrySet();
    assertFalse(entries.contains((Object) 4.5));
    assertFalse(entries.remove((Object) 4.5));
    assertFalse(entries.contains(Maps.immutableEntry("foo", Collections.singletonList(1))));
    assertFalse(entries.remove(Maps.immutableEntry("foo", Collections.singletonList(1))));
    assertFalse(entries.contains(Maps.immutableEntry("foo", Sets.newLinkedHashSet(asList(1, 2)))));
    assertFalse(entries.remove(Maps.immutableEntry("foo", Sets.newLinkedHashSet(asList(1, 2)))));
    assertFalse(entries.contains(Maps.immutableEntry("foo", Collections.singleton(2))));
    assertFalse(entries.remove(Maps.immutableEntry("foo", Collections.singleton(2))));
    assertTrue(map.containsKey("foo"));
    assertTrue(entries.contains(Maps.immutableEntry("foo", Collections.singleton(1))));
    assertTrue(entries.remove(Maps.immutableEntry("foo", Collections.singleton(1))));
    assertFalse(map.containsKey("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: immutableEntry=8 ) - Predicate: singleton - Scenario: asMap (Alternative Scenario: entries=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewSortedSetMultimapSerialization
 Body: {
    CountingSupplier<TreeSet<Integer>> factory = new SortedSetSupplier();
    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    SortedSetMultimap<Color, Integer> multimap = Multimaps.newSortedSetMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
    assertEquals(INT_COMPARATOR, multimap.valueComparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testUnmodifiableMultimapIsView
 Body: {
    Multimap<String, Integer> mod = HashMultimap.create();
    Multimap<String, Integer> unmod = Multimaps.unmodifiableMultimap(mod);
    assertEquals(mod, unmod);
    mod.put("foo", 1);
    assertTrue(unmod.containsEntry("foo", 1));
    assertEquals(mod, unmod);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsEntry=1 ) - Predicate: N/A - Scenario: mod (Alternative Scenario: mod=1 )

Project: guava
 Class: MultimapsTest
 Method: testUnmodifiableLinkedListMultimapRandomAccess
 Body: {
    ListMultimap<String, Integer> delegate = LinkedListMultimap.create();
    delegate.put("foo", 1);
    delegate.put("foo", 3);
    ListMultimap<String, Integer> multimap = Multimaps.unmodifiableListMultimap(delegate);
    assertFalse(multimap.get("foo") instanceof RandomAccess);
    assertFalse(multimap.get("bar") instanceof RandomAccess);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: delegate=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewMultimapSerialization
 Body: {
    CountingSupplier<Queue<Integer>> factory = new QueueSupplier();
    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    Multimap<Color, Integer> multimap = Multimaps.newMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testUnmodifiableSynchronizedTreeMultimap
 Body: {
    TreeMultimap<String, Integer> delegate =
        TreeMultimap.create(Ordering.<String>natural(), INT_COMPARATOR);
    SortedSetMultimap<String, Integer> multimap = Multimaps.synchronizedSortedSetMultimap(delegate);
    checkUnmodifiableMultimap(multimap, false, "null", 42);
    assertSame(INT_COMPARATOR, multimap.valueComparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: checkUnmodifiableMultimap (Alternative Action: valueComparator=1 ) - Predicate: valueComparator - Scenario: multimap (Alternative Scenario: delegate=1 )

Project: guava
 Class: MultimapsTest
 Method: testForMapSerialization
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("foo", 1);
    map.put("bar", 2);
    Multimap<String, Integer> multimapView = Multimaps.forMap(map);
    SerializableTester.reserializeAndAssert(multimapView);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: N/A - Scenario: multimapView (Alternative Scenario: multimapView=1 )

Project: guava
 Class: MultimapsTest
 Method: testForMapRemoveAll
 Body: {
    Map<String, Integer> map = Maps.newHashMap();
    map.put("foo", 1);
    map.put("bar", 2);
    map.put("cow", 3);
    Multimap<String, Integer> multimap = Multimaps.forMap(map);
    assertEquals(3, multimap.size());
    assertEquals(Collections.emptySet(), multimap.removeAll("dog"));
    assertEquals(3, multimap.size());
    assertTrue(multimap.containsKey("bar"));
    assertEquals(Collections.singleton(2), multimap.removeAll("bar"));
    assertEquals(2, multimap.size());
    assertFalse(multimap.containsKey("bar"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=3 ) - Predicate: size - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewListMultimap
 Body: {
    CountingSupplier<LinkedList<Integer>> factory = new ListSupplier();
    Map<Color, Collection<Integer>> map = Maps.newTreeMap();
    ListMultimap<Color, Integer> multimap = Multimaps.newListMultimap(map, factory);
    assertEquals(0, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4, 1));
    assertEquals(1, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(2, factory.count);
    assertEquals("{BLUE=[3, 1, 4, 1], RED=[2, 7, 1, 8]}", multimap.toString());
    assertFalse(multimap.get(Color.BLUE) instanceof RandomAccess);

    assertTrue(multimap.keySet() instanceof SortedSet);
    assertTrue(multimap.asMap() instanceof SortedMap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: factory (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewSetMultimapSerialization
 Body: {
    CountingSupplier<Set<Integer>> factory = new SetSupplier();
    Map<Color, Collection<Integer>> map = Maps.newHashMap();
    SetMultimap<Color, Integer> multimap = Multimaps.newSetMultimap(map, factory);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    SerializableTester.reserializeAndAssert(multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testNewSortedSetMultimap
 Body: {
    CountingSupplier<TreeSet<Integer>> factory = new SortedSetSupplier();
    Map<Color, Collection<Integer>> map = Maps.newEnumMap(Color.class);
    SortedSetMultimap<Color, Integer> multimap = Multimaps.newSortedSetMultimap(map, factory);
    // newSortedSetMultimap calls the factory once to determine the comparator.
    assertEquals(1, factory.count);
    multimap.putAll(Color.BLUE, asList(3, 1, 4));
    assertEquals(2, factory.count);
    multimap.putAll(Color.RED, asList(2, 7, 1, 8));
    assertEquals(3, factory.count);
    assertEquals("[4, 3, 1]", multimap.get(Color.BLUE).toString());
    assertEquals(INT_COMPARATOR, multimap.valueComparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: factory (Alternative Scenario: factory=1 )

Project: guava
 Class: MultimapsTest
 Method: testTransformValuesIsView
 Body: {
    Multimap<String, String> multimap = LinkedListMultimap.create();
    multimap.put("a", "a");
    Multimap<String, Integer> transformed =
        Multimaps.transformValues(
            multimap,
            new Function<String, Integer>() {

              @Override
              public Integer apply(String str) {
                return str.length();
              }
            });
    Entry<String, String> entry = multimap.entries().iterator().next();
    entry.setValue("bbb");
    assertThat(transformed.entries()).containsExactly(immutableEntry("a", 3));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValue (Alternative Action: entries=2 ) - Predicate: immutableEntry - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: LongsTest
 Method: testAsList_toArray_roundTrip
 Body: {
    long[] array = {(long) 0, (long) 1, (long) 2};
    List<Long> list = Longs.asList(array);
    long[] newArray = Longs.toArray(list);

    // Make sure it returned a copy
    list.set(0, (long) 4);
    assertTrue(Arrays.equals(new long[] {(long) 0, (long) 1, (long) 2}, newArray));
    newArray[1] = (long) 5;
    assertEquals((long) 1, (long) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: LongsTest
 Method: testAsList_isAView
 Body: {
    long[] array = {(long) 0, (long) 1};
    List<Long> list = Longs.asList(array);
    list.set(0, (long) 2);
    assertTrue(Arrays.equals(new long[] {(long) 2, (long) 1}, array));
    array[1] = (long) 3;
    assertEquals(Arrays.asList((long) 2, (long) 3), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: CacheExpirationTest
 Method: testExpiration_invalidateAll
 Body: {
    FakeTicker ticker = new FakeTicker();
    QueuingRemovalListener<Integer, Integer> listener =
        TestingRemovalListeners.queuingRemovalListener();
    Cache<Integer, Integer> cache =
        CacheBuilder.newBuilder()
            .expireAfterAccess(1, TimeUnit.MINUTES)
            .removalListener(listener)
            .ticker(ticker)
            .build();
    cache.put(1, 1);
    ticker.advance(10, TimeUnit.MINUTES);
    cache.invalidateAll();

    assertThat(listener.poll().getCause()).isEqualTo(RemovalCause.EXPIRED);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: ticker=1 ) - Predicate: N/A - Scenario: cache (Alternative Scenario: cache=1 )

Project: guava
 Class: ImmutableGraphTest
 Method: immutableGraph
 Body: {
    MutableGraph<String> mutableGraph = GraphBuilder.directed().build();
    mutableGraph.addNode("A");
    ImmutableGraph<String> immutableGraph = ImmutableGraph.copyOf(mutableGraph);

    assertThat(immutableGraph).isNotInstanceOf(MutableValueGraph.class);
    assertThat(immutableGraph).isEqualTo(mutableGraph);

    mutableGraph.addNode("B");
    assertThat(immutableGraph).isNotEqualTo(mutableGraph);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=2 ) - Predicate: N/A - Scenario: immutableGraph (Alternative Scenario: mutableGraph=1 )

Project: guava
 Class: ImmutableGraphTest
 Method: immutableValueGraph
 Body: {
    MutableValueGraph<String, Integer> mutableValueGraph = ValueGraphBuilder.directed().build();
    mutableValueGraph.addNode("A");
    ImmutableValueGraph<String, Integer> immutableValueGraph =
        ImmutableValueGraph.copyOf(mutableValueGraph);

    assertThat(immutableValueGraph.asGraph()).isInstanceOf(ImmutableGraph.class);
    assertThat(immutableValueGraph).isNotInstanceOf(MutableValueGraph.class);
    assertThat(immutableValueGraph).isEqualTo(mutableValueGraph);

    mutableValueGraph.addNode("B");
    assertThat(immutableValueGraph).isNotEqualTo(mutableValueGraph);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addNode (Alternative Action: addNode=2 ) - Predicate: N/A - Scenario: immutableValueGraph (Alternative Scenario: mutableValueGraph=1 )

Project: guava
 Class: ForwardingMapTest
 Method: testToStringWithNullValues
 Body: {
    Map<String, String> hashmap = Maps.newHashMap();
    hashmap.put("foo", "bar");
    hashmap.put("baz", null);

    StandardImplForwardingMap<String, String> forwardingMap =
        new StandardImplForwardingMap<>(Maps.<String, String>newHashMap());
    forwardingMap.put("foo", "bar");
    forwardingMap.put("baz", null);

    assertEquals(hashmap.toString(), forwardingMap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: forwardingMap (Alternative Scenario: forwardingMap=1 )

Project: guava
 Class: ForwardingMapTest
 Method: testToStringWithNullKeys
 Body: {
    Map<String, String> hashmap = Maps.newHashMap();
    hashmap.put("foo", "bar");
    hashmap.put(null, "baz");

    StandardImplForwardingMap<String, String> forwardingMap =
        new StandardImplForwardingMap<>(Maps.<String, String>newHashMap());
    forwardingMap.put("foo", "bar");
    forwardingMap.put(null, "baz");

    assertEquals(hashmap.toString(), forwardingMap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: toString - Scenario: forwardingMap (Alternative Scenario: forwardingMap=1 )

Project: guava
 Class: OrderingTest
 Method: testCompound_static
 Body: {
    Comparator<String> comparator =
        Ordering.compound(
            ImmutableList.of(
                byCharAt(0), byCharAt(1), byCharAt(2), byCharAt(3), byCharAt(4), byCharAt(5)));
    Helpers.testComparator(
        comparator,
        ImmutableList.of(
            "applesauce",
            "apricot",
            "artichoke",
            "banality",
            "banana",
            "banquet",
            "tangelo",
            "tangerine"));
    reserializeAndAssert(comparator);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testComparator (Alternative Action: byCharAt=6 ) - Predicate: N/A - Scenario: comparator (Alternative Scenario: comparator=1 )

Project: guava
 Class: OrderingTest
 Method: testUsingToString
 Body: {
    Ordering<Object> ordering = Ordering.usingToString();
    Helpers.testComparator(ordering, 1, 12, 124, 2);
    assertEquals("Ordering.usingToString()", ordering.toString());
    assertSame(ordering, reserialize(ordering));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testComparator (Alternative Action: testComparator=1 ) - Predicate: toString - Scenario: ordering (Alternative Scenario: ordering=1 )

Project: guava
 Class: OrderingTest
 Method: testExplicit_sortingExample
 Body: {
    Comparator<Integer> c = Ordering.explicit(2, 8, 6, 1, 7, 5, 3, 4, 0, 9);
    List<Integer> list = Arrays.asList(0, 3, 5, 6, 7, 8, 9);
    Collections.sort(list, c);
    assertThat(list).containsExactly(8, 6, 7, 5, 3, 0, 9).inOrder();
    reserializeAndAssert(c);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: sort (Alternative Action: explicit=1 ) - Predicate: N/A - Scenario: list (Alternative Scenario: c=1 )

Project: guava
 Class: OrderingTest
 Method: testOnResultOf_natural
 Body: {
    Comparator<String> comparator =
        Ordering.natural().onResultOf(StringLengthFunction.StringLength);
    assertTrue(comparator.compare("to", "be") == 0);
    assertTrue(comparator.compare("or", "not") < 0);
    assertTrue(comparator.compare("that", "to") > 0);

    new EqualsTester()
        .addEqualityGroup(
            comparator, Ordering.natural().onResultOf(StringLengthFunction.StringLength))
        .addEqualityGroup(DECREASING_INTEGER)
        .testEquals();
    reserializeAndAssert(comparator);
    assertEquals("Ordering.natural().onResultOf(StringLength)", comparator.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: compare=3 ) - Predicate: N/A - Scenario: comparator (Alternative Scenario: comparator=1 )

Project: guava
 Class: OrderingTest
 Method: testFrom
 Body: {
    Ordering<String> caseInsensitiveOrdering = Ordering.from(String.CASE_INSENSITIVE_ORDER);
    assertEquals(0, caseInsensitiveOrdering.compare("A", "a"));
    assertTrue(caseInsensitiveOrdering.compare("a", "B") < 0);
    assertTrue(caseInsensitiveOrdering.compare("B", "a") > 0);

    @SuppressWarnings("deprecation") // test of deprecated method
    Ordering<String> orderingFromOrdering = Ordering.from(Ordering.<String>natural());
    new EqualsTester()
        .addEqualityGroup(caseInsensitiveOrdering, Ordering.from(String.CASE_INSENSITIVE_ORDER))
        .addEqualityGroup(orderingFromOrdering, Ordering.natural())
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: compare=3 ) - Predicate: compare - Scenario: caseInsensitiveOrdering (Alternative Scenario: orderingFromOrdering=1 )

Project: guava
 Class: OrderingTest
 Method: testOnResultOf_chained
 Body: {
    Comparator<String> comparator =
        DECREASING_INTEGER.onResultOf(StringLengthFunction.StringLength);
    assertTrue(comparator.compare("to", "be") == 0);
    assertTrue(comparator.compare("not", "or") < 0);
    assertTrue(comparator.compare("to", "that") > 0);

    new EqualsTester()
        .addEqualityGroup(
            comparator, DECREASING_INTEGER.onResultOf(StringLengthFunction.StringLength))
        .addEqualityGroup(DECREASING_INTEGER.onResultOf(Functions.constant(1)))
        .addEqualityGroup(Ordering.natural())
        .testEquals();
    reserializeAndAssert(comparator);
    assertEquals("Ordering.natural().reverse().onResultOf(StringLength)", comparator.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: compare=3 ) - Predicate: N/A - Scenario: comparator (Alternative Scenario: comparator=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testRemove_someRemaining
 Body: {
    int countToRemove = 30;
    int countRemaining = 1;
    AtomicInteger current = new AtomicInteger(countToRemove + countRemaining);

    when(backingMap.get(KEY)).thenReturn(current);

    assertEquals(countToRemove + countRemaining, multiset.remove(KEY, countToRemove));
    assertEquals(countRemaining, current.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: get=2 ) - Predicate: remove - Scenario: current (Alternative Scenario: countToRemove=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testSetCount_basic
 Body: {
    int initialCount = 20;
    int countToSet = 40;
    AtomicInteger current = new AtomicInteger(initialCount);

    when(backingMap.get(KEY)).thenReturn(current);

    assertEquals(initialCount, multiset.setCount(KEY, countToSet));
    assertEquals(countToSet, current.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: get=2 ) - Predicate: setCount - Scenario: current (Alternative Scenario: initialCount=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testAdd_laterFewWithSuccess
 Body: {
    int INITIAL_COUNT = 32;
    int COUNT_TO_ADD = 400;

    AtomicInteger initial = new AtomicInteger(INITIAL_COUNT);
    when(backingMap.get(KEY)).thenReturn(initial);

    assertEquals(INITIAL_COUNT, multiset.add(KEY, COUNT_TO_ADD));
    assertEquals(INITIAL_COUNT + COUNT_TO_ADD, initial.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: get=2 ) - Predicate: add - Scenario: initial (Alternative Scenario: COUNT_TO_ADD=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testSetCount_asRemove
 Body: {
    int countToRemove = 40;
    AtomicInteger current = new AtomicInteger(countToRemove);

    when(backingMap.get(KEY)).thenReturn(current);
    when(backingMap.remove(KEY, current)).thenReturn(true);

    assertEquals(countToRemove, multiset.setCount(KEY, 0));
    assertEquals(0, current.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=2 ) - Predicate: setCount - Scenario: current (Alternative Scenario: countToRemove=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testRemove_noneRemaining
 Body: {
    int countToRemove = 30;
    AtomicInteger current = new AtomicInteger(countToRemove);

    when(backingMap.get(KEY)).thenReturn(current);
    // it's ok if removal fails: another thread may have done the remove
    when(backingMap.remove(KEY, current)).thenReturn(false);

    assertEquals(countToRemove, multiset.remove(KEY, countToRemove));
    assertEquals(0, current.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=2 ) - Predicate: remove - Scenario: current (Alternative Scenario: countToRemove=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testAdd_firstFewWithSuccess
 Body: {
    final int COUNT = 400;

    when(backingMap.get(KEY)).thenReturn(null);
    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(null);

    assertEquals(0, multiset.add(KEY, COUNT));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=2 ) - Predicate: add - Scenario: COUNT (Alternative Scenario: COUNT=1 )

Project: guava
 Class: ConcurrentHashMultisetTest
 Method: testAdd_withFailures
 Body: {
    AtomicInteger existing = new AtomicInteger(12);
    AtomicInteger existingZero = new AtomicInteger(0);

    // initial map.get()
    when(backingMap.get(KEY)).thenReturn(null);
    // since get returned null, try a putIfAbsent; that fails due to a simulated race
    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existingZero);
    // since the putIfAbsent returned a zero, we'll try to replace...
    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);
    // ...and then putIfAbsent. Simulate failure on both
    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);

    // next map.get()
    when(backingMap.get(KEY)).thenReturn(existingZero);
    // since get returned zero, try a replace; that fails due to a simulated race
    when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);
    when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);

    // another map.get()
    when(backingMap.get(KEY)).thenReturn(existing);
    // we shouldn't see any more map operations; CHM will now just update the AtomicInteger

    assertEquals(12, multiset.add(KEY, 3));
    assertEquals(15, existing.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=8 ) - Predicate: add - Scenario: existingZero (Alternative Scenario: existing=1 )

Project: guava
 Class: AbstractCacheTest
 Method: testGetIfPresent
 Body: {
    final AtomicReference<Object> valueRef = new AtomicReference<>();
    Cache<Object, Object> cache =
        new AbstractCache<Object, Object>() {
          @Override
          public Object getIfPresent(Object key) {
            return valueRef.get();
          }
        };

    assertNull(cache.getIfPresent(new Object()));

    Object newValue = new Object();
    valueRef.set(newValue);
    assertSame(newValue, cache.getIfPresent(new Object()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: getIfPresent=2 ) - Predicate: getIfPresent - Scenario: valueRef (Alternative Scenario: valueRef=1 )

Project: guava
 Class: AbstractCacheTest
 Method: testInvalidateAll
 Body: {
    final List<Object> invalidated = Lists.newArrayList();
    Cache<Integer, Integer> cache =
        new AbstractCache<Integer, Integer>() {
          @Override
          public Integer getIfPresent(Object key) {
            throw new UnsupportedOperationException();
          }

          @Override
          public void invalidate(Object key) {
            invalidated.add(key);
          }
        };

    List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);
    cache.invalidateAll(toInvalidate);
    assertEquals(toInvalidate, invalidated);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: invalidateAll (Alternative Action: add=1 ) - Predicate: N/A - Scenario: toInvalidate (Alternative Scenario: cache=1 )

Project: guava
 Class: EnumMultisetTest
 Method: testClassCreate
 Body: {
    Multiset<Color> ms = EnumMultiset.create(Color.class);
    ms.add(Color.RED);
    ms.add(Color.YELLOW);
    ms.add(Color.RED);
    assertEquals(0, ms.count(Color.BLUE));
    assertEquals(1, ms.count(Color.YELLOW));
    assertEquals(2, ms.count(Color.RED));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: count - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: EnumMultisetTest
 Method: testToString
 Body: {
    Multiset<Color> ms = EnumMultiset.create(Color.class);
    ms.add(Color.BLUE, 3);
    ms.add(Color.YELLOW, 1);
    ms.add(Color.RED, 2);
    assertEquals("[BLUE x 3, RED x 2, YELLOW]", ms.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: toString - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: EnumMultisetTest
 Method: testEntrySet
 Body: {
    Multiset<Color> ms = EnumMultiset.create(Color.class);
    ms.add(Color.BLUE, 3);
    ms.add(Color.YELLOW, 1);
    ms.add(Color.RED, 2);

    Set<Object> uniqueEntries = Sets.newIdentityHashSet();
    uniqueEntries.addAll(ms.entrySet());
    assertEquals(3, uniqueEntries.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: add=3 ) - Predicate: size - Scenario: uniqueEntries (Alternative Scenario: ms=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderRowsBy_dense
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.put('c', 3, "foo");
    builder.put('c', 2, "bar");
    builder.put('c', 1, "baz");
    builder.put('b', 3, "cat");
    builder.put('b', 1, "dog");
    builder.put('a', 3, "foo");
    builder.put('a', 2, "bar");
    builder.put('a', 1, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();
    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=8 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testSparseSerialization_bothOrders
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.<Character>natural());
    builder.orderColumnsBy(Ordering.<Integer>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    builder.put('c', 3, "cat");
    builder.put('d', 4, "dog");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testSparseSerialization_columnOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.<Integer>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    builder.put('c', 3, "cat");
    builder.put('d', 4, "dog");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderRowsAndColumnsBy_dense
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.orderColumnsBy(Ordering.natural());
    builder.put('c', 3, "foo");
    builder.put('c', 2, "bar");
    builder.put('c', 1, "baz");
    builder.put('b', 3, "cat");
    builder.put('b', 1, "dog");
    builder.put('a', 3, "foo");
    builder.put('a', 2, "bar");
    builder.put('a', 1, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('a', 'b', 'c').inOrder();
    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();
    assertThat(table.values())
        .containsExactly("baz", "bar", "foo", "dog", "cat", "baz", "bar", "foo")
        .inOrder();
    assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();
    assertThat(table.column(1).keySet()).containsExactly('a', 'b', 'c').inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=8 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_withMutableCell
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = new ImmutableTable.Builder<>();

    final StringHolder holder = new StringHolder();
    holder.string = "foo";
    Table.Cell<Character, Integer, String> mutableCell =
        new Tables.AbstractCell<Character, Integer, String>() {
          @Override
          public Character getRowKey() {
            return 'K';
          }

          @Override
          public Integer getColumnKey() {
            return 42;
          }

          @Override
          public String getValue() {
            return holder.string;
          }
        };

    // Add the mutable cell to the builder
    builder.put(mutableCell);

    // Mutate the value
    holder.string = "bar";

    // Make sure it uses the original value.
    assertEquals(ImmutableTable.of('K', 42, "foo"), builder.build());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: build=1 ) - Predicate: of - Scenario: mutableCell (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testDenseSerialization_bothOrders
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.<Character>natural());
    builder.orderColumnsBy(Ordering.<Integer>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderRowsAndColumnsBy_sparse
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.orderColumnsBy(Ordering.natural());
    builder.put('x', 2, "foo");
    builder.put('r', 1, "bar");
    builder.put('c', 3, "baz");
    builder.put('b', 7, "cat");
    builder.put('e', 5, "dog");
    builder.put('c', 0, "axe");
    builder.put('e', 3, "tub");
    builder.put('r', 4, "foo");
    builder.put('x', 5, "bar");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();
    assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder();
    assertThat(table.values())
        .containsExactly("cat", "axe", "baz", "tub", "dog", "bar", "foo", "foo", "bar")
        .inOrder();
    assertThat(table.row('c').keySet()).containsExactly(0, 3).inOrder();
    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=9 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = new ImmutableTable.Builder<>();
    assertEquals(ImmutableTable.of(), builder.build());
    assertEquals(ImmutableTable.of('a', 1, "foo"), builder.put('a', 1, "foo").build());
    Table<Character, Integer, String> expectedTable = HashBasedTable.create();
    expectedTable.put('a', 1, "foo");
    expectedTable.put('b', 1, "bar");
    expectedTable.put('a', 2, "baz");
    Table<Character, Integer, String> otherTable = HashBasedTable.create();
    otherTable.put('b', 1, "bar");
    otherTable.put('a', 2, "baz");
    assertEquals(expectedTable, builder.putAll(otherTable).build());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: of - Scenario: builder (Alternative Scenario: otherTable=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testSparseSerialization_manualOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    builder.put('c', 3, "cat");
    builder.put('d', 4, "dog");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testDenseSerialization_manualOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderRowsAndColumnsBy_putAll
 Body: {
    Table<Character, Integer, String> table = HashBasedTable.create();
    table.put('b', 2, "foo");
    table.put('b', 1, "bar");
    table.put('a', 2, "baz");
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    Table<Character, Integer, String> copy =
        builder
            .orderRowsBy(Ordering.natural())
            .orderColumnsBy(Ordering.natural())
            .putAll(table)
            .build();
    assertThat(copy.rowKeySet()).containsExactly('a', 'b').inOrder();
    assertThat(copy.columnKeySet()).containsExactly(1, 2).inOrder();
    assertThat(copy.values()).containsExactly("baz", "bar", "foo").inOrder();
    assertThat(copy.row('b').keySet()).containsExactly(1, 2).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: builder (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderColumnsBy_dense
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.natural());
    builder.put('c', 3, "foo");
    builder.put('c', 2, "bar");
    builder.put('c', 1, "baz");
    builder.put('b', 3, "cat");
    builder.put('b', 1, "dog");
    builder.put('a', 3, "foo");
    builder.put('a', 2, "bar");
    builder.put('a', 1, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.columnKeySet()).containsExactly(1, 2, 3).inOrder();
    assertThat(table.row('c').keySet()).containsExactly(1, 2, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=8 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderColumnsBy_sparse
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.natural());
    builder.put('x', 2, "foo");
    builder.put('r', 1, "bar");
    builder.put('c', 3, "baz");
    builder.put('b', 7, "cat");
    builder.put('e', 5, "dog");
    builder.put('c', 0, "axe");
    builder.put('e', 3, "tub");
    builder.put('r', 4, "foo");
    builder.put('x', 5, "bar");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.columnKeySet()).containsExactly(0, 1, 2, 3, 4, 5, 7).inOrder();
    assertThat(table.row('c').keySet()).containsExactly(0, 3).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=9 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testCopyOf
 Body: {
    Table<Character, Integer, String> table = TreeBasedTable.create();
    validateTableCopies(table);
    table.put('b', 2, "foo");
    validateTableCopies(table);
    table.put('b', 1, "bar");
    table.put('a', 2, "baz");
    validateTableCopies(table);
    // Even though rowKeySet, columnKeySet, and cellSet have the same
    // iteration ordering, row has an inconsistent ordering.
    assertThat(table.row('b').keySet()).containsExactly(1, 2).inOrder();
    assertThat(ImmutableTable.copyOf(table).row('b').keySet()).containsExactly(2, 1).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: validateTableCopies (Alternative Action: validateTableCopies=3 ) - Predicate: N/A - Scenario: table (Alternative Scenario: table=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testDenseSerialization_rowOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.<Character>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testDenseSerialization_columnOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderColumnsBy(Ordering.<Integer>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(DenseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testBuilder_orderRowsBy_sparse
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.natural());
    builder.put('x', 2, "foo");
    builder.put('r', 1, "bar");
    builder.put('c', 3, "baz");
    builder.put('b', 7, "cat");
    builder.put('e', 5, "dog");
    builder.put('c', 0, "axe");
    builder.put('e', 3, "tub");
    builder.put('r', 4, "foo");
    builder.put('x', 5, "bar");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table.rowKeySet()).containsExactly('b', 'c', 'e', 'r', 'x').inOrder();
    assertThat(table.column(5).keySet()).containsExactly('e', 'x').inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=9 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableTableTest
 Method: testSparseSerialization_rowOrder
 Body: {
    ImmutableTable.Builder<Character, Integer, String> builder = ImmutableTable.builder();
    builder.orderRowsBy(Ordering.<Character>natural());
    builder.put('b', 2, "foo");
    builder.put('b', 1, "bar");
    builder.put('a', 2, "baz");
    builder.put('c', 3, "cat");
    builder.put('d', 4, "dog");
    Table<Character, Integer, String> table = builder.build();
    assertThat(table).isInstanceOf(SparseImmutableTable.class);
    validateReserialization(table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=5 ) - Predicate: N/A - Scenario: table (Alternative Scenario: builder=1 )

Project: guava
 Class: ConfigurableUndirectedMultiNetworkTest
 Method: addEdge_existingSelfLoopEdgeBetweenSameNodes
 Body: {
    addEdge(N1, N1, E11);
    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
    assertThat(addEdge(N1, N1, E11)).isFalse();
    assertThat(network.edges()).containsExactlyElementsIn(edges);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edges=2 ) - Predicate: N/A - Scenario: edges (Alternative Scenario: edges=1 )

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testForEachEntry
 Body: {
    ImmutableSortedMultiset<String> multiset =
        ImmutableSortedMultiset.<String>naturalOrder().add("a").add("b").add("a").add("c").build();
    List<Multiset.Entry<String>> entries = new ArrayList<>();
    multiset.forEachEntry((e, c) -> entries.add(Multisets.immutableEntry(e, c)));
    assertThat(entries)
        .containsExactly(
            Multisets.immutableEntry("a", 2),
            Multisets.immutableEntry("b", 1),
            Multisets.immutableEntry("c", 1))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEachEntry (Alternative Action: add=5 ) - Predicate: N/A - Scenario: entries (Alternative Scenario: multiset=1 )

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testCreation_arrayOfArray
 Body: {
    Comparator<String[]> comparator =
        Ordering.natural()
            .lexicographical()
            .onResultOf(
                new Function<String[], Iterable<Comparable>>() {
                  @Override
                  public Iterable<Comparable> apply(String[] input) {
                    return Arrays.<Comparable>asList(input);
                  }
                });
    String[] array = new String[] {"a"};
    Multiset<String[]> multiset = ImmutableSortedMultiset.orderedBy(comparator).add(array).build();
    Multiset<String[]> expected = HashMultiset.create();
    expected.add(array);
    assertEquals(expected, multiset);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: multiset=1 )

Project: guava
 Class: ImmutableSortedMultisetTest
 Method: testCopyOfSortedDefensiveCopy
 Body: {
    // Depending on JDK version, either toArray() or toArray(T[]) may be called... use this class
    // rather than mocking to ensure that one of those methods is called.
    class TestHashSet<E> extends HashSet<E> {
      boolean toArrayCalled = false;

      @Override
      public Object[] toArray() {
        toArrayCalled = true;
        return super.toArray();
      }

      @Override
      public <T> T[] toArray(T[] a) {
        toArrayCalled = true;
        return super.toArray(a);
      }
    }

    // Test that toArray() is used to make a defensive copy in copyOf(), so concurrently modified
    // synchronized collections can be safely copied.
    SortedMultiset<String> toCopy = mock(SortedMultiset.class);
    TestHashSet<Entry<String>> entrySet = new TestHashSet<>();
    when((Comparator<Comparable<String>>) toCopy.comparator())
        .thenReturn(Ordering.<Comparable<String>>natural());
    when(toCopy.entrySet()).thenReturn(entrySet);
    ImmutableSortedMultiset<String> unused = ImmutableSortedMultiset.copyOfSorted(toCopy);
    assertTrue(entrySet.toArrayCalled);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: thenReturn (Alternative Action: thenReturn=2 ) - Predicate: N/A - Scenario: unused (Alternative Scenario: entrySet=1 )

Project: guava
 Class: PredicatesTest
 Method: testOr_iterableDefensivelyCopied
 Body: {
    final List<Predicate<Object>> list = newArrayList();
    Iterable<Predicate<Object>> iterable =
        new Iterable<Predicate<Object>>() {
          @Override
          public Iterator<Predicate<Object>> iterator() {
            return list.iterator();
          }
        };
    Predicate<Object> predicate = Predicates.or(iterable);
    assertFalse(predicate.apply(1));
    list.add(Predicates.alwaysTrue());
    assertFalse(predicate.apply(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: apply=2 ) - Predicate: apply - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: PredicatesTest
 Method: testOr_listDefensivelyCopied
 Body: {
    List<Predicate<Object>> list = newArrayList();
    Predicate<Object> predicate = Predicates.or(list);
    assertFalse(predicate.apply(1));
    list.add(Predicates.alwaysTrue());
    assertFalse(predicate.apply(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: apply=2 ) - Predicate: apply - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: PredicatesTest
 Method: testIn_handlesClassCastException
 Body: {
    class CollectionThatThrowsCCE<T> extends ArrayList<T> {
      private static final long serialVersionUID = 1L;

      @Override
      public boolean contains(Object element) {
        throw new ClassCastException("");
      }
    }
    Collection<Integer> nums = new CollectionThatThrowsCCE<>();
    nums.add(3);
    Predicate<Integer> isThree = Predicates.in(nums);
    assertFalse(isThree.apply(3));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: apply - Scenario: isThree (Alternative Scenario: isThree=1 )

Project: guava
 Class: PredicatesTest
 Method: testAnd_listDefensivelyCopied
 Body: {
    List<Predicate<Object>> list = newArrayList();
    Predicate<Object> predicate = Predicates.and(list);
    assertTrue(predicate.apply(1));
    list.add(Predicates.alwaysFalse());
    assertTrue(predicate.apply(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: apply=2 ) - Predicate: apply - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: PredicatesTest
 Method: testCompose
 Body: {
    Function<String, String> trim = TrimStringFunction.INSTANCE;
    Predicate<String> equalsFoo = Predicates.equalTo("Foo");
    Predicate<String> equalsBar = Predicates.equalTo("Bar");
    Predicate<String> trimEqualsFoo = Predicates.compose(equalsFoo, trim);
    Function<String, String> identity = Functions.identity();

    assertTrue(trimEqualsFoo.apply("Foo"));
    assertTrue(trimEqualsFoo.apply("   Foo   "));
    assertFalse(trimEqualsFoo.apply("Foo-b-que"));

    new EqualsTester()
        .addEqualityGroup(trimEqualsFoo, Predicates.compose(equalsFoo, trim))
        .addEqualityGroup(equalsFoo)
        .addEqualityGroup(trim)
        .addEqualityGroup(Predicates.compose(equalsFoo, identity))
        .addEqualityGroup(Predicates.compose(equalsBar, trim))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: addEqualityGroup=5 ) - Predicate: apply - Scenario: trim (Alternative Scenario: trim=1 )

Project: guava
 Class: PredicatesTest
 Method: testAnd_iterableDefensivelyCopied
 Body: {
    final List<Predicate<Object>> list = newArrayList();
    Iterable<Predicate<Object>> iterable =
        new Iterable<Predicate<Object>>() {
          @Override
          public Iterator<Predicate<Object>> iterator() {
            return list.iterator();
          }
        };
    Predicate<Object> predicate = Predicates.and(iterable);
    assertTrue(predicate.apply(1));
    list.add(Predicates.alwaysFalse());
    assertTrue(predicate.apply(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: apply=2 ) - Predicate: apply - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: IteratorsTest
 Method: testGet_withDefault_basic
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    assertEquals("a", get(iterator, 0, "c"));
    assertTrue(iterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: get - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testGet_basic
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    assertEquals("b", get(iterator, 1));
    assertFalse(iterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: get - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testGet_withDefault_atSize
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    assertEquals("c", get(iterator, 2, "c"));
    assertFalse(iterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: get - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testGet_withDefault_pastEnd
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    assertEquals("c", get(iterator, 3, "c"));
    assertFalse(iterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: get - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testLimitRemove
 Body: {
    List<String> list = newArrayList();
    list.add("cool");
    list.add("pants");
    Iterator<String> iterator = Iterators.limit(list.iterator(), 1);
    iterator.next();
    iterator.remove();
    assertFalse(iterator.hasNext());
    assertEquals(1, list.size());
    assertEquals("pants", list.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: add=2 ) - Predicate: hasNext - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testCycleRemoveAfterHasNextExtraPicky
 Body: {
    PickyIterable<String> iterable = new PickyIterable("a");
    Iterator<String> cycle = Iterators.cycle(iterable);
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    assertTrue(cycle.hasNext());
    cycle.remove();
    assertTrue(iterable.elements.isEmpty());
    assertFalse(cycle.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: hasNext=3 ) - Predicate: hasNext - Scenario: iterable (Alternative Scenario: iterable=1 )

Project: guava
 Class: IteratorsTest
 Method: testGetLast_basic
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    assertEquals("b", getLast(list.iterator()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: getLast - Scenario: list (Alternative Scenario: list=1 )

Project: guava
 Class: IteratorsTest
 Method: testAdvance_basic
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    advance(iterator, 1);
    assertEquals("b", iterator.next());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: advance (Alternative Action: add=2 ) - Predicate: next - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testPaddedPartition_view
 Body: {
    List<Integer> list = asList(1, 2);
    Iterator<List<Integer>> partitions = Iterators.paddedPartition(list.iterator(), 1);

    // Changes before the PaddedPartition is retrieved are reflected
    list.set(0, 3);
    List<Integer> first = partitions.next();

    // Changes after are not
    list.set(0, 4);

    assertEquals(ImmutableList.of(3), first);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=2 ) - Predicate: of - Scenario: first (Alternative Scenario: partitions=1 )

Project: guava
 Class: IteratorsTest
 Method: testCycleRemoveAfterHasNext
 Body: {
    Iterable<String> iterable = Lists.newArrayList("a");
    Iterator<String> cycle = Iterators.cycle(iterable);
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    assertTrue(cycle.hasNext());
    cycle.remove();
    assertEquals(Collections.emptyList(), iterable);
    assertFalse(cycle.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: hasNext=3 ) - Predicate: hasNext - Scenario: iterable (Alternative Scenario: iterable=1 )

Project: guava
 Class: IteratorsTest
 Method: testAll
 Body: {
    List<String> list = Lists.newArrayList();
    Predicate<String> predicate = Predicates.equalTo("cool");

    assertTrue(Iterators.all(list.iterator(), predicate));
    list.add("cool");
    assertTrue(Iterators.all(list.iterator(), predicate));
    list.add("pants");
    assertFalse(Iterators.all(list.iterator(), predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: all=3 ) - Predicate: all - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: IteratorsTest
 Method: testAdvance_pastEnd
 Body: {
    List<String> list = newArrayList();
    list.add("a");
    list.add("b");
    Iterator<String> iterator = list.iterator();
    advance(iterator, 5);
    assertFalse(iterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: advance (Alternative Action: add=2 ) - Predicate: hasNext - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testSize_partiallyConsumed
 Body: {
    Iterator<Integer> iterator = asList(1, 2, 3, 4, 5).iterator();
    iterator.next();
    iterator.next();
    assertEquals(3, Iterators.size(iterator));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: next=2 ) - Predicate: size - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: IteratorsTest
 Method: testCycleOfOneWithRemove
 Body: {
    Iterable<String> iterable = Lists.newArrayList("a");
    Iterator<String> cycle = Iterators.cycle(iterable);
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    cycle.remove();
    assertEquals(Collections.emptyList(), iterable);
    assertFalse(cycle.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: hasNext=2 ) - Predicate: hasNext - Scenario: iterable (Alternative Scenario: iterable=1 )

Project: guava
 Class: IteratorsTest
 Method: testTransformRemove
 Body: {
    List<String> list = Lists.newArrayList("1", "2", "3");
    Iterator<String> input = list.iterator();
    Iterator<Integer> iterator =
        Iterators.transform(
            input,
            new Function<String, Integer>() {
              @Override
              public Integer apply(String from) {
                return Integer.valueOf(from);
              }
            });

    assertEquals(Integer.valueOf(1), iterator.next());
    assertEquals(Integer.valueOf(2), iterator.next());
    iterator.remove();
    assertEquals(asList("1", "3"), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: valueOf=3 ) - Predicate: valueOf - Scenario: list (Alternative Scenario: input=1 )

Project: guava
 Class: IteratorsTest
 Method: testAny
 Body: {
    List<String> list = Lists.newArrayList();
    Predicate<String> predicate = Predicates.equalTo("pants");

    assertFalse(Iterators.any(list.iterator(), predicate));
    list.add("cool");
    assertFalse(Iterators.any(list.iterator(), predicate));
    list.add("pants");
    assertTrue(Iterators.any(list.iterator(), predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: iterator=3 ) - Predicate: any - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: IteratorsTest
 Method: testPartition_view
 Body: {
    List<Integer> list = asList(1, 2);
    Iterator<List<Integer>> partitions = Iterators.partition(list.iterator(), 1);

    // Changes before the partition is retrieved are reflected
    list.set(0, 3);
    List<Integer> first = partitions.next();

    // Changes after are not
    list.set(0, 4);

    assertEquals(ImmutableList.of(3), first);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=2 ) - Predicate: of - Scenario: first (Alternative Scenario: partitions=1 )

Project: guava
 Class: IteratorsTest
 Method: testCycleOfTwoWithRemove
 Body: {
    Iterable<String> iterable = Lists.newArrayList("a", "b");
    Iterator<String> cycle = Iterators.cycle(iterable);
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    assertTrue(cycle.hasNext());
    assertEquals("b", cycle.next());
    assertTrue(cycle.hasNext());
    assertEquals("a", cycle.next());
    cycle.remove();
    assertEquals(Collections.singletonList("b"), iterable);
    assertTrue(cycle.hasNext());
    assertEquals("b", cycle.next());
    assertTrue(cycle.hasNext());
    assertEquals("b", cycle.next());
    cycle.remove();
    assertEquals(Collections.emptyList(), iterable);
    assertFalse(cycle.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: hasNext=6 ) - Predicate: hasNext - Scenario: iterable (Alternative Scenario: iterable=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapReadsThrough
 Body: {
    Set<String> strings = Sets.newLinkedHashSet();
    Collections.addAll(strings, "one", "two", "three");
    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5), map);
    assertNull(map.get("four"));
    strings.add("four");
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5, "four", 4), map);
    assertEquals(Integer.valueOf(4), map.get("four"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: get=2 ) - Predicate: of - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testEnumMap
 Body: {
    EnumMap<SomeEnum, Integer> map = Maps.newEnumMap(SomeEnum.class);
    assertEquals(Collections.emptyMap(), map);
    map.put(SomeEnum.SOME_INSTANCE, 0);
    assertEquals(Collections.singletonMap(SomeEnum.SOME_INSTANCE, 0), map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: singletonMap=1 ) - Predicate: emptyMap - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapSortedWritesThrough
 Body: {
    SortedSet<String> strings = new NonNavigableSortedSet();
    Collections.addAll(strings, "one", "two", "three");
    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5), map);
    assertEquals(Integer.valueOf(3), map.remove("two"));
    assertThat(strings).containsExactly("one", "three").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: addAll=1 ) - Predicate: of - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testTreeMapDerived
 Body: {
    TreeMap<Derived, Integer> map = Maps.newTreeMap();
    assertEquals(Collections.emptyMap(), map);
    map.put(new Derived("foo"), 1);
    map.put(new Derived("bar"), 2);
    assertThat(map.keySet()).containsExactly(new Derived("bar"), new Derived("foo")).inOrder();
    assertThat(map.values()).containsExactly(2, 1).inOrder();
    assertNull(map.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: emptyMap - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapNavigableWritesThrough
 Body: {
    NavigableSet<String> strings = Sets.newTreeSet();
    Collections.addAll(strings, "one", "two", "three");
    NavigableMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5), map);
    assertEquals(Integer.valueOf(3), map.remove("two"));
    assertThat(strings).containsExactly("one", "three").inOrder();
    assertEquals(mapEntry("three", 5), map.subMap("one", false, "zzz", true).pollLastEntry());
    assertThat(strings).contains("one");
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: addAll=1 ) - Predicate: of - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapSortedReadsThrough
 Body: {
    SortedSet<String> strings = new NonNavigableSortedSet();
    Collections.addAll(strings, "one", "two", "three");
    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertNull(map.comparator());
    assertEquals(ImmutableSortedMap.of("one", 3, "two", 3, "three", 5), map);
    assertNull(map.get("four"));
    strings.add("four");
    assertEquals(ImmutableSortedMap.of("one", 3, "two", 3, "three", 5, "four", 4), map);
    assertEquals(Integer.valueOf(4), map.get("four"));
    SortedMap<String, Integer> headMap = map.headMap("two");
    assertEquals(ImmutableSortedMap.of("four", 4, "one", 3, "three", 5), headMap);
    strings.add("five");
    strings.remove("one");
    assertEquals(ImmutableSortedMap.of("five", 4, "four", 4, "three", 5), headMap);
    assertThat(map.entrySet())
        .containsExactly(
            mapEntry("five", 4), mapEntry("four", 4), mapEntry("three", 5), mapEntry("two", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: of=4 ) - Predicate: comparator - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testEnumMapWithInitialMap
 Body: {
    HashMap<SomeEnum, Integer> original = Maps.newHashMap();
    original.put(SomeEnum.SOME_INSTANCE, 0);
    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);
    assertEquals(original, copy);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: newHashMap=1 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTest
 Method: testHashMapGeneralizesTypes
 Body: {
    Map<String, Integer> original = new TreeMap<>();
    original.put("a", 1);
    original.put("b", 2);
    original.put("c", 3);
    HashMap<Object, Object> map =
        Maps.newHashMap((Map<? extends Object, ? extends Object>) original);
    assertEquals(original, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTest
 Method: testTreeMapWithInitialMap
 Body: {
    SortedMap<Integer, Integer> map = Maps.newTreeMap();
    map.put(5, 10);
    map.put(3, 20);
    map.put(1, 30);
    TreeMap<Integer, Integer> copy = Maps.newTreeMap(map);
    assertEquals(copy, map);
    assertSame(copy.comparator(), map.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapWritesThrough
 Body: {
    Set<String> strings = Sets.newLinkedHashSet();
    Collections.addAll(strings, "one", "two", "three");
    Map<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5), map);
    assertEquals(Integer.valueOf(3), map.remove("two"));
    assertThat(strings).containsExactly("one", "three").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: addAll=1 ) - Predicate: of - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapNavigableReadsThrough
 Body: {
    NavigableSet<String> strings = Sets.newTreeSet();
    Collections.addAll(strings, "one", "two", "three");
    NavigableMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertNull(map.comparator());
    assertEquals(ImmutableSortedMap.of("one", 3, "two", 3, "three", 5), map);
    assertNull(map.get("four"));
    strings.add("four");
    assertEquals(ImmutableSortedMap.of("one", 3, "two", 3, "three", 5, "four", 4), map);
    assertEquals(Integer.valueOf(4), map.get("four"));
    SortedMap<String, Integer> headMap = map.headMap("two");
    assertEquals(ImmutableSortedMap.of("four", 4, "one", 3, "three", 5), headMap);
    strings.add("five");
    strings.remove("one");
    assertEquals(ImmutableSortedMap.of("five", 4, "four", 4, "three", 5), headMap);
    assertThat(map.entrySet())
        .containsExactly(
            mapEntry("five", 4), mapEntry("four", 4), mapEntry("three", 5), mapEntry("two", 3))
        .inOrder();

    NavigableMap<String, Integer> tailMap = map.tailMap("s", true);
    NavigableMap<String, Integer> subMap = map.subMap("a", true, "t", false);

    strings.add("six");
    strings.remove("two");
    assertThat(tailMap.entrySet())
        .containsExactly(mapEntry("six", 3), mapEntry("three", 5))
        .inOrder();
    assertThat(subMap.entrySet())
        .containsExactly(mapEntry("five", 4), mapEntry("four", 4), mapEntry("six", 3))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: mapEntry=9 ) - Predicate: comparator - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testLinkedHashMapGeneralizesTypes
 Body: {
    Map<String, Integer> original = new LinkedHashMap<>();
    original.put("a", 1);
    original.put("b", 2);
    original.put("c", 3);
    HashMap<Object, Object> map = Maps.<Object, Object>newLinkedHashMap(original);
    assertEquals(original, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTest
 Method: testTreeMapNonGeneric
 Body: {
    TreeMap<LegacyComparable, Integer> map = Maps.newTreeMap();
    assertEquals(Collections.emptyMap(), map);
    map.put(new LegacyComparable("foo"), 1);
    map.put(new LegacyComparable("bar"), 2);
    assertThat(map.keySet())
        .containsExactly(new LegacyComparable("bar"), new LegacyComparable("foo"))
        .inOrder();
    assertThat(map.values()).containsExactly(2, 1).inOrder();
    assertNull(map.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: emptyMap - Scenario: map (Alternative Scenario: map=1 )

Project: guava
 Class: MapsTest
 Method: testAsMapSorted
 Body: {
    SortedSet<String> strings = new NonNavigableSortedSet();
    Collections.addAll(strings, "one", "two", "three");
    SortedMap<String, Integer> map = Maps.asMap(strings, LENGTH_FUNCTION);
    assertEquals(ImmutableMap.of("one", 3, "two", 3, "three", 5), map);
    assertEquals(Integer.valueOf(5), map.get("three"));
    assertNull(map.get("five"));
    assertThat(map.entrySet())
        .containsExactly(mapEntry("one", 3), mapEntry("three", 5), mapEntry("two", 3))
        .inOrder();
    assertThat(map.tailMap("onea").entrySet())
        .containsExactly(mapEntry("three", 5), mapEntry("two", 3))
        .inOrder();
    assertThat(map.subMap("one", "two").entrySet())
        .containsExactly(mapEntry("one", 3), mapEntry("three", 5))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: mapEntry=7 ) - Predicate: of - Scenario: map (Alternative Scenario: strings=1 )

Project: guava
 Class: MapsTest
 Method: testHashMapWithInitialMap
 Body: {
    Map<String, Integer> original = new TreeMap<>();
    original.put("a", 1);
    original.put("b", 2);
    original.put("c", 3);
    HashMap<String, Integer> map = Maps.newHashMap(original);
    assertEquals(original, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTest
 Method: testSynchronizedBiMap
 Body: {
    BiMap<String, Integer> bimap = HashBiMap.create();
    bimap.put("one", 1);
    BiMap<String, Integer> sync = Maps.synchronizedBiMap(bimap);
    bimap.put("two", 2);
    sync.put("three", 3);
    assertEquals(ImmutableSet.of(1, 2, 3), bimap.inverse().keySet());
    assertEquals(ImmutableSet.of(1, 2, 3), sync.inverse().keySet());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: sync (Alternative Scenario: bimap=1 )

Project: guava
 Class: MapsTest
 Method: testEnumMapWithInitialEnumMap
 Body: {
    EnumMap<SomeEnum, Integer> original = Maps.newEnumMap(SomeEnum.class);
    original.put(SomeEnum.SOME_INSTANCE, 0);
    EnumMap<SomeEnum, Integer> copy = Maps.newEnumMap(original);
    assertEquals(original, copy);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: newEnumMap=2 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTest
 Method: testToStringImplWithNullKeys
 Body: {
    Map<String, String> hashmap = Maps.newHashMap();
    hashmap.put("foo", "bar");
    hashmap.put(null, "baz");

    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: toString - Scenario: hashmap (Alternative Scenario: hashmap=1 )

Project: guava
 Class: MapsTest
 Method: testToStringImplWithNullValues
 Body: {
    Map<String, String> hashmap = Maps.newHashMap();
    hashmap.put("foo", "bar");
    hashmap.put("baz", null);

    assertEquals(hashmap.toString(), Maps.toStringImpl(hashmap));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=2 ) - Predicate: toString - Scenario: hashmap (Alternative Scenario: hashmap=1 )

Project: guava
 Class: AtomicLongMapTest
 Method: testPutAll
 Body: {
    Map<String, Long> in = ImmutableMap.of("1", 1L, "2", 2L, "3", 3L);
    AtomicLongMap<String> map = AtomicLongMap.create();
    assertTrue(map.isEmpty());
    assertSame(0, map.size());
    assertFalse(map.containsKey("1"));
    assertFalse(map.containsKey("2"));
    assertFalse(map.containsKey("3"));
    assertEquals(0L, map.get("1"));
    assertEquals(0L, map.get("2"));
    assertEquals(0L, map.get("3"));

    map.putAll(in);
    assertFalse(map.isEmpty());
    assertSame(3, map.size());
    assertTrue(map.containsKey("1"));
    assertTrue(map.containsKey("2"));
    assertTrue(map.containsKey("3"));
    assertEquals(1L, map.get("1"));
    assertEquals(2L, map.get("2"));
    assertEquals(3L, map.get("3"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: containsKey=6 ) - Predicate: isEmpty - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: AtomicLongMapTest
 Method: testSerialization
 Body: {
    AtomicLongMap<String> map = AtomicLongMap.create();
    map.put("key", 1L);
    AtomicLongMap<String> reserialized = SerializableTester.reserialize(map);
    assertEquals(map.asMap(), reserialized.asMap());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: asMap=2 ) - Predicate: asMap - Scenario: reserialized (Alternative Scenario: reserialized=1 )

Project: guava
 Class: HashingInputStreamTest
 Method: testRead_putSingleByte
 Body: {
    HashingInputStream in = new HashingInputStream(hashFunction, buffer);

    int b = in.read();
    assertEquals('y', b);

    verify(hasher).putByte((byte) 'y');
    verify(hashFunction).newHasher();
    verifyNoMoreInteractions(hashFunction, hasher);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putByte (Alternative Action: verify=2 ) - Predicate: N/A - Scenario: in (Alternative Scenario: b=1 )

Project: guava
 Class: TreeBasedTableTest
 Method: testCreateCopy
 Body: {
    TreeBasedTable<String, Integer, Character> original =
        TreeBasedTable.create(Collections.reverseOrder(), Ordering.usingToString());
    original.put("foo", 3, 'a');
    original.put("foo", 12, 'b');
    original.put("bar", 5, 'c');
    original.put("cat", 8, 'd');
    table = TreeBasedTable.create(original);
    assertThat(table.rowKeySet()).containsExactly("foo", "cat", "bar").inOrder();
    assertThat(table.row("foo").keySet()).containsExactly(12, 3).inOrder();
    assertEquals(original, table);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: original (Alternative Scenario: original=1 )

Project: guava
 Class: SettableFutureTest
 Method: testCancel_multipleBeforeSetFuture_interruptFirst
 Body: {
    SettableFuture<Object> async = SettableFuture.create();
    async.cancel(true);
    async.cancel(false);
    SettableFuture<Object> inner = SettableFuture.create();
    assertFalse(async.setFuture(inner));
    assertTrue(inner.isCancelled());
    assertTrue(inner.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=2 ) - Predicate: setFuture - Scenario: inner (Alternative Scenario: async=1 )

Project: guava
 Class: SettableFutureTest
 Method: testCancel_multipleBeforeSetFuture_noInterruptFirst
 Body: {
    SettableFuture<Object> async = SettableFuture.create();
    async.cancel(false);
    async.cancel(true);
    SettableFuture<Object> inner = SettableFuture.create();
    assertFalse(async.setFuture(inner));
    assertTrue(inner.isCancelled());
    assertFalse(inner.wasInterrupted());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: cancel (Alternative Action: cancel=2 ) - Predicate: setFuture - Scenario: inner (Alternative Scenario: async=1 )

Project: guava
 Class: StripedTest
 Method: testWeakReadWrite
 Body: {
    Striped<ReadWriteLock> striped = Striped.lazyWeakReadWriteLock(1000);
    Object key = new Object();
    Lock readLock = striped.get(key).readLock();
    WeakReference<Object> garbage = new WeakReference<>(new Object());
    GcFinalization.awaitClear(garbage);
    Lock writeLock = striped.get(key).writeLock();
    readLock.lock();
    assertFalse(writeLock.tryLock());
    readLock.unlock();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: lock (Alternative Action: get=2 ) - Predicate: tryLock - Scenario: writeLock (Alternative Scenario: striped=1 )

Project: guava
 Class: IntsTest
 Method: testAsList_toArray_roundTrip
 Body: {
    int[] array = {(int) 0, (int) 1, (int) 2};
    List<Integer> list = Ints.asList(array);
    int[] newArray = Ints.toArray(list);

    // Make sure it returned a copy
    list.set(0, (int) 4);
    assertTrue(Arrays.equals(new int[] {(int) 0, (int) 1, (int) 2}, newArray));
    newArray[1] = (int) 5;
    assertEquals((int) 1, (int) list.get(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: set=1 ) - Predicate: equals - Scenario: newArray (Alternative Scenario: array=1 )

Project: guava
 Class: IntsTest
 Method: testAsList_isAView
 Body: {
    int[] array = {(int) 0, (int) 1};
    List<Integer> list = Ints.asList(array);
    list.set(0, (int) 2);
    assertTrue(Arrays.equals(new int[] {(int) 2, (int) 1}, array));
    array[1] = (int) 3;
    assertEquals(Arrays.asList((int) 2, (int) 3), list);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: equals - Scenario: list (Alternative Scenario: array=1 )

Project: guava
 Class: CharSinkTest
 Method: testOpenBufferedStream
 Body: {
    Writer writer = sink.openBufferedStream();
    assertTrue(sink.wasStreamOpened());
    assertFalse(sink.wasStreamClosed());

    writer.write(STRING);
    writer.close();

    assertTrue(sink.wasStreamClosed());
    assertEquals(STRING, sink.getString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: wasStreamClosed=2 ) - Predicate: wasStreamOpened - Scenario: writer (Alternative Scenario: writer=1 )

Project: guava
 Class: CharSinkTest
 Method: testWriteFrom_reader
 Body: {
    StringReader reader = new StringReader(STRING);
    sink.writeFrom(reader);

    assertTrue(sink.wasStreamOpened() && sink.wasStreamClosed());
    assertEquals(STRING, sink.getString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeFrom (Alternative Action: wasStreamClosed=1 ) - Predicate: N/A - Scenario: reader (Alternative Scenario: reader=1 )

Project: guava
 Class: CharSinkTest
 Method: testWriteFromStream_doesNotCloseThatStream
 Body: {
    TestReader in = new TestReader();
    assertFalse(in.closed());
    sink.writeFrom(in);
    assertFalse(in.closed());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeFrom (Alternative Action: closed=2 ) - Predicate: closed - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: SafeTreeSetTest
 Method: testSeveral_serialization
 Body: {
    SortedSet<String> set = new SafeTreeSet<>();
    set.add("a");
    set.add("b");
    set.add("c");
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertEquals(set.comparator(), copy.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: comparator - Scenario: copy (Alternative Scenario: set=1 )

Project: guava
 Class: SafeTreeSetTest
 Method: testSingle_serialization
 Body: {
    SortedSet<String> set = new SafeTreeSet<>();
    set.add("e");
    SortedSet<String> copy = SerializableTester.reserializeAndAssert(set);
    assertEquals(set.comparator(), copy.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: comparator=2 ) - Predicate: comparator - Scenario: copy (Alternative Scenario: set=1 )

Project: guava
 Class: LinkedHashMultisetTest
 Method: testCreateWithSize
 Body: {
    Multiset<String> multiset = LinkedHashMultiset.create(50);
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals("[foo x 2, bar]", multiset.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: LinkedHashMultisetTest
 Method: testLosesPlaceInLine
 Body: {
    Multiset<String> ms = LinkedHashMultiset.create();
    ms.add("a");
    ms.add("b", 2);
    ms.add("c");
    assertThat(ms.elementSet()).containsExactly("a", "b", "c").inOrder();
    ms.remove("b");
    assertThat(ms.elementSet()).containsExactly("a", "b", "c").inOrder();
    ms.add("b");
    assertThat(ms.elementSet()).containsExactly("a", "b", "c").inOrder();
    ms.remove("b", 2);
    ms.add("b");
    assertThat(ms.elementSet()).containsExactly("a", "c", "b").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=5 ) - Predicate: N/A - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: LinkedHashMultisetTest
 Method: testCreate
 Body: {
    Multiset<String> multiset = LinkedHashMultiset.create();
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
    assertEquals("[foo x 2, bar]", multiset.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: LinkedHashMultisetTest
 Method: testToString
 Body: {
    Multiset<String> ms = LinkedHashMultiset.create();
    ms.add("a", 3);
    ms.add("c", 1);
    ms.add("b", 2);

    assertEquals("[a x 3, c, b x 2]", ms.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=3 ) - Predicate: toString - Scenario: ms (Alternative Scenario: ms=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredKeysFilteredReflectsBackingChanges
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      Map<String, Integer> filtered = Maps.filterKeys(unfiltered, NOT_LENGTH_3);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      assertEquals(ImmutableMap.of("two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("three", 3, "four", 4), filtered);

      unfiltered.remove("three");
      assertEquals(ImmutableMap.of("two", 2, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("four", 4), filtered);

      unfiltered.clear();
      assertEquals(ImmutableMap.of(), unfiltered);
      assertEquals(ImmutableMap.of(), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: of=6 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredEntriesObjectPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Object> predicate = Predicates.alwaysFalse();
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: isEmpty - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testFirstAndLastKeyFilteredMap
 Body: {
      SortedMap<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("apple", 2);
      unfiltered.put("banana", 6);
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 5);

      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);
      assertEquals("banana", filtered.firstKey());
      assertEquals("cat", filtered.lastKey());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: firstKey - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testHeadSubTailMap_FilteredMap
 Body: {
      SortedMap<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("apple", 2);
      unfiltered.put("banana", 6);
      unfiltered.put("cat", 4);
      unfiltered.put("dog", 3);
      SortedMap<String, Integer> filtered = Maps.filterEntries(unfiltered, CORRECT_LENGTH);

      assertEquals(ImmutableMap.of("banana", 6), filtered.headMap("dog"));
      assertEquals(ImmutableMap.of(), filtered.headMap("banana"));
      assertEquals(ImmutableMap.of("banana", 6, "dog", 3), filtered.headMap("emu"));

      assertEquals(ImmutableMap.of("banana", 6), filtered.subMap("banana", "dog"));
      assertEquals(ImmutableMap.of("dog", 3), filtered.subMap("cat", "emu"));

      assertEquals(ImmutableMap.of("dog", 3), filtered.tailMap("cat"));
      assertEquals(ImmutableMap.of("banana", 6, "dog", 3), filtered.tailMap("banana"));
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: of=7 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredValuesClear
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("one", 1);
      unfiltered.put("two", 2);
      unfiltered.put("three", 3);
      unfiltered.put("four", 4);
      Map<String, Integer> filtered = Maps.filterValues(unfiltered, EVEN);
      assertEquals(ImmutableMap.of("one", 1, "two", 2, "three", 3, "four", 4), unfiltered);
      assertEquals(ImmutableMap.of("two", 2, "four", 4), filtered);

      filtered.clear();
      assertEquals(ImmutableMap.of("one", 1, "three", 3), unfiltered);
      assertTrue(filtered.isEmpty());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: of - Scenario: filtered (Alternative Scenario: filtered=1 )

Project: guava
 Class: FilteredSortedMapTest
 Method: testFilteredEntriesWildCardEntryPredicate
 Body: {
      Map<String, Integer> unfiltered = createUnfiltered();
      unfiltered.put("cat", 3);
      unfiltered.put("dog", 2);
      unfiltered.put("horse", 5);
      Predicate<Entry<?, ?>> predicate =
          new Predicate<Entry<?, ?>>() {
            @Override
            public boolean apply(Entry<?, ?> input) {
              return "cat".equals(input.getKey()) || Integer.valueOf(2) == input.getValue();
            }
          };
      Map<String, Integer> filtered = Maps.filterEntries(unfiltered, predicate);
      assertEquals(ImmutableMap.of("cat", 3, "dog", 2), filtered);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: predicate (Alternative Scenario: predicate=1 )

Project: guava
 Class: MapComputeIfPresentTester
 Method: testComputeIfPresent_nullKeySupportedPresent
 Body: {
    initMapWithNullKey();
    assertEquals(
        "computeIfPresent(null, function) should return new value",
        v3(),
        getMap()
            .computeIfPresent(
                null,
                (k, v) -> {
                  assertNull(k);
                  assertEquals(getValueForNullKey(), v);
                  return v3();
                }));

    Entry<K, V>[] expected = createArrayWithNullKey();
    expected[getNullLocation()] = entry(null, v3());
    expectContents(expected);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initMapWithNullKey (Alternative Action: v3=3 ) - Predicate: v3 - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testCopyOfWithDuplicates
 Body: {
    ArrayListMultimap<Object, Object> input = ArrayListMultimap.create();
    input.put("foo", 1);
    input.put("bar", 2);
    input.put("foo", 3);
    input.put("foo", 1);
    ImmutableSetMultimap<Object, Object> copy = ImmutableSetMultimap.copyOf(input);
    assertEquals(3, copy.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: size - Scenario: copy (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderOrderKeysAndValuesBy
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(Collections.reverseOrder());
    builder.orderValuesBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "c", "b", "a").inOrder();
    assertThat(multimap.values()).containsExactly(2, 4, 6, 3, 5, 2).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(6, 3).inOrder();
    assertTrue(multimap.get("a") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(), ((ImmutableSortedSet<Integer>) multimap.get("a")).comparator());
    assertTrue(multimap.get("x") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(), ((ImmutableSortedSet<Integer>) multimap.get("x")).comparator());
    assertTrue(multimap.asMap().get("a") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(),
        ((ImmutableSortedSet<Integer>) multimap.asMap().get("a")).comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=8 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderOrderKeysByDuplicates
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.put("bb", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(
        new Ordering<String>() {
          @Override
          public int compare(String left, String right) {
            return left.length() - right.length();
          }
        });
    builder.put("cc", 4);
    builder.put("a", 2);
    builder.put("bb", 6);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "a", "bb", "cc").inOrder();
    assertThat(multimap.values()).containsExactly(2, 5, 2, 3, 6, 4).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("bb")).containsExactly(3, 6).inOrder();
    assertFalse(multimap.get("a") instanceof ImmutableSortedSet);
    assertFalse(multimap.get("x") instanceof ImmutableSortedSet);
    assertFalse(multimap.asMap().get("a") instanceof ImmutableSortedSet);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutAllMultimap
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", 1);
    toPut.put("bar", 4);
    toPut.put("foo", 2);
    toPut.put("foo", 3);
    Multimap<String, Integer> moreToPut = LinkedListMultimap.create();
    moreToPut.put("foo", 6);
    moreToPut.put("bar", 5);
    moreToPut.put("foo", 7);
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll(toPut);
    builder.putAll(moreToPut);
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(ImmutableSet.of(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: put=7 ) - Predicate: of - Scenario: multimap (Alternative Scenario: toPut=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testCopyOf
 Body: {
    HashMultimap<String, Integer> input = HashMultimap.create();
    input.put("foo", 1);
    input.put("bar", 2);
    input.put("foo", 3);
    Multimap<String, Integer> multimap = ImmutableSetMultimap.copyOf(input);
    assertEquals(multimap, input);
    assertEquals(input, multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutAllVarargs
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.putAll("foo", 6, 7);
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(ImmutableSet.of(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutAllIterable
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll("foo", Arrays.asList(1, 2, 3));
    builder.putAll("bar", Arrays.asList(4, 5));
    builder.putAll("foo", Arrays.asList(6, 7));
    Multimap<String, Integer> multimap = builder.build();
    assertEquals(ImmutableSet.of(1, 2, 3, 6, 7), multimap.get("foo"));
    assertEquals(ImmutableSet.of(4, 5), multimap.get("bar"));
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutAllMultimapWithDuplicates
 Body: {
    Multimap<String, Integer> toPut = LinkedListMultimap.create();
    toPut.put("foo", 1);
    toPut.put("bar", 4);
    toPut.put("foo", 2);
    toPut.put("foo", 1);
    toPut.put("bar", 5);
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll(toPut);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertEquals(4, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: put=5 ) - Predicate: size - Scenario: multimap (Alternative Scenario: toPut=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutAllWithDuplicates
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.putAll("foo", 1, 6, 7);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertEquals(7, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: size - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderOrderKeysBy
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderKeysBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("d", "c", "b", "a").inOrder();
    assertThat(multimap.values()).containsExactly(2, 4, 3, 6, 5, 2).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(3, 6).inOrder();
    assertFalse(multimap.get("a") instanceof ImmutableSortedSet);
    assertFalse(multimap.get("x") instanceof ImmutableSortedSet);
    assertFalse(multimap.asMap().get("a") instanceof ImmutableSortedSet);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilder_withMutableEntry
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = new Builder<>();
    final StringHolder holder = new StringHolder();
    holder.string = "one";
    Entry<String, Integer> entry =
        new AbstractMapEntry<String, Integer>() {
          @Override
          public String getKey() {
            return holder.string;
          }

          @Override
          public Integer getValue() {
            return 1;
          }
        };

    builder.put(entry);
    holder.string = "two";
    assertEquals(ImmutableSet.of(1), builder.build().get("one"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: build=1 ) - Predicate: of - Scenario: entry (Alternative Scenario: entry=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderPutWithDuplicates
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.putAll("foo", 1, 2, 3);
    builder.putAll("bar", 4, 5);
    builder.put("foo", 1);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertEquals(5, multimap.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: putAll=2 ) - Predicate: size - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ImmutableSetMultimapTest
 Method: testBuilderOrderValuesBy
 Body: {
    ImmutableSetMultimap.Builder<String, Integer> builder = ImmutableSetMultimap.builder();
    builder.put("b", 3);
    builder.put("d", 2);
    builder.put("a", 5);
    builder.orderValuesBy(Collections.reverseOrder());
    builder.put("c", 4);
    builder.put("a", 2);
    builder.put("b", 6);
    ImmutableSetMultimap<String, Integer> multimap = builder.build();
    assertThat(multimap.keySet()).containsExactly("b", "d", "a", "c").inOrder();
    assertThat(multimap.values()).containsExactly(6, 3, 2, 5, 2, 4).inOrder();
    assertThat(multimap.get("a")).containsExactly(5, 2).inOrder();
    assertThat(multimap.get("b")).containsExactly(6, 3).inOrder();
    assertTrue(multimap.get("a") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(), ((ImmutableSortedSet<Integer>) multimap.get("a")).comparator());
    assertTrue(multimap.get("x") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(), ((ImmutableSortedSet<Integer>) multimap.get("x")).comparator());
    assertTrue(multimap.asMap().get("a") instanceof ImmutableSortedSet);
    assertEquals(
        Collections.reverseOrder(),
        ((ImmutableSortedSet<Integer>) multimap.asMap().get("a")).comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=8 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: builder=1 )

Project: guava
 Class: ArrayTableTest
 Method: testRow
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<Integer, Character> expected = Maps.newHashMap();
    expected.put(1, 'a');
    expected.put(3, 'c');
    expected.put(2, null);
    assertEquals(expected, table.row("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: row - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ArrayTableTest
 Method: testHashCode
 Body: {
    table = ArrayTable.create(asList("foo", "bar"), asList(1, 3));
    table.put("foo", 1, 'a');
    table.put("bar", 1, 'b');
    table.put("foo", 3, 'c');
    int expected =
        Objects.hashCode("foo", 1, 'a')
            + Objects.hashCode("bar", 1, 'b')
            + Objects.hashCode("foo", 3, 'c')
            + Objects.hashCode("bar", 3, 0);
    assertEquals(expected, table.hashCode());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: hashCode=5 ) - Predicate: hashCode - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ArrayTableTest
 Method: testCreateCopyArrayTable
 Body: {
    Table<String, Integer, Character> original =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Table<String, Integer, Character> copy = ArrayTable.create(original);
    assertEquals(original, copy);
    original.put("foo", 1, 'd');
    assertEquals((Character) 'd', original.get("foo", 1));
    assertEquals((Character) 'a', copy.get("foo", 1));
    assertEquals(copy.rowKeySet(), original.rowKeySet());
    assertEquals(copy.columnKeySet(), original.columnKeySet());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: columnKeySet=2 ) - Predicate: N/A - Scenario: original (Alternative Scenario: original=1 )

Project: guava
 Class: ArrayTableTest
 Method: testColumn
 Body: {
    table = create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Map<String, Character> expected = Maps.newHashMap();
    expected.put("foo", 'a');
    expected.put("bar", 'b');
    expected.put("cat", null);
    assertEquals(expected, table.column(1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: column - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: ArrayTableTest
 Method: testEraseAll
 Body: {
    ArrayTable<String, Integer, Character> table =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    table.eraseAll();
    assertEquals(9, table.size());
    assertNull(table.get("bar", 1));
    assertTrue(table.containsRow("foo"));
    assertFalse(table.containsValue('a'));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: eraseAll (Alternative Action: size=1 ) - Predicate: size - Scenario: table (Alternative Scenario: table=1 )

Project: guava
 Class: ArrayTableTest
 Method: testToArray
 Body: {
    ArrayTable<String, Integer, Character> table =
        create("foo", 1, 'a', "bar", 1, 'b', "foo", 3, 'c');
    Character[][] array = table.toArray(Character.class);
    assertThat(array).hasLength(3);
    assertThat(array[0]).asList().containsExactly('a', null, 'c').inOrder();
    assertThat(array[1]).asList().containsExactly('b', null, null).inOrder();
    assertThat(array[2]).asList().containsExactly(null, null, null).inOrder();
    table.set(0, 2, 'd');
    assertEquals((Character) 'c', array[0][2]);
    array[0][2] = 'e';
    assertEquals((Character) 'd', table.at(0, 2));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: at=1 ) - Predicate: N/A - Scenario: table (Alternative Scenario: array=1 )

Project: guava
 Class: ArrayTableTest
 Method: testCreateCopyHashBasedTable
 Body: {
    Table<String, Integer, Character> original = HashBasedTable.create();
    original.put("foo", 1, 'a');
    original.put("bar", 1, 'b');
    original.put("foo", 3, 'c');
    Table<String, Integer, Character> copy = ArrayTable.create(original);
    assertEquals(4, copy.size());
    assertEquals((Character) 'a', copy.get("foo", 1));
    assertEquals((Character) 'b', copy.get("bar", 1));
    assertEquals((Character) 'c', copy.get("foo", 3));
    assertNull(copy.get("bar", 3));
    original.put("foo", 1, 'd');
    assertEquals((Character) 'd', original.get("foo", 1));
    assertEquals((Character) 'a', copy.get("foo", 1));
    assertEquals(copy.rowKeySet(), ImmutableSet.of("foo", "bar"));
    assertEquals(copy.columnKeySet(), ImmutableSet.of(1, 3));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=6 ) - Predicate: size - Scenario: copy (Alternative Scenario: original=1 )

Project: guava
 Class: AppendableWriterTest
 Method: testWriteMethods
 Body: {
    StringBuilder builder = new StringBuilder();
    Writer writer = new AppendableWriter(builder);

    writer.write("Hello".toCharArray());
    writer.write(',');
    writer.write(0xBEEF0020); // only lower 16 bits are important
    writer.write("Wo");
    writer.write("Whirled".toCharArray(), 3, 2);
    writer.write("Mad! Mad, I say", 2, 2);

    assertEquals("Hello, World!", builder.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: write=6 ) - Predicate: toString - Scenario: writer (Alternative Scenario: builder=1 )

Project: guava
 Class: AppendableWriterTest
 Method: testAppendMethods
 Body: {
    StringBuilder builder = new StringBuilder();
    Writer writer = new AppendableWriter(builder);

    writer.append("Hello,");
    writer.append(' ');
    writer.append("The World Wide Web", 4, 9);
    writer.append("!");

    assertEquals("Hello, World!", builder.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: append (Alternative Action: append=4 ) - Predicate: toString - Scenario: writer (Alternative Scenario: builder=1 )

Project: guava
 Class: AppendableWriterTest
 Method: testCloseFlush
 Body: {
    SpyAppendable spy = new SpyAppendable();
    Writer writer = new AppendableWriter(spy);

    writer.write("Hello");
    assertFalse(spy.flushed);
    assertFalse(spy.closed);

    writer.flush();
    assertTrue(spy.flushed);
    assertFalse(spy.closed);

    writer.close();
    assertTrue(spy.flushed);
    assertTrue(spy.closed);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: flush=1 ) - Predicate: N/A - Scenario: writer (Alternative Scenario: writer=1 )

Project: guava
 Class: ConfigurableUndirectedNetworkTest
 Method: addEdge_existingSelfLoopEdgeBetweenSameNodes
 Body: {
    addEdge(N1, N1, E11);
    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
    assertThat(addEdge(N1, N1, E11)).isFalse();
    assertThat(network.edges()).containsExactlyElementsIn(edges);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addEdge (Alternative Action: edges=2 ) - Predicate: N/A - Scenario: edges (Alternative Scenario: edges=1 )

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testFailOnErrorFromStartUpListener
 Body: {
    final Error error = new Error();
    final CountDownLatch latch = new CountDownLatch(1);
    TestService service = new TestService();
    service.addListener(
        new Service.Listener() {
          @Override
          public void running() {
            throw error;
          }

          @Override
          public void failed(State from, Throwable failure) {
            assertEquals(State.RUNNING, from);
            assertEquals(error, failure);
            latch.countDown();
          }
        },
        directExecutor());
    service.startAsync();
    latch.await();

    assertEquals(0, service.numberOfTimesRunCalled.get());
    assertEquals(Service.State.FAILED, service.state());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: directExecutor=1 ) - Predicate: directExecutor - Scenario: error (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testServiceStartStop
 Body: {
    NullService service = new NullService();
    service.startAsync().awaitRunning();
    assertFalse(future.isDone());
    service.stopAsync().awaitTerminated();
    assertTrue(future.isCancelled());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: isCancelled=1 ) - Predicate: isDone - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractScheduledServiceTest
 Method: testDefaultExecutorIsShutdownWhenServiceIsStopped
 Body: {
    final AtomicReference<ScheduledExecutorService> executor = Atomics.newReference();
    AbstractScheduledService service =
        new AbstractScheduledService() {
          @Override
          protected void runOneIteration() throws Exception {}

          @Override
          protected ScheduledExecutorService executor() {
            executor.set(super.executor());
            return executor.get();
          }

          @Override
          protected Scheduler scheduler() {
            return newFixedDelaySchedule(0, 1, TimeUnit.MILLISECONDS);
          }
        };

    service.startAsync();
    assertFalse(service.executor().isShutdown());
    service.awaitRunning();
    service.stopAsync();
    service.awaitTerminated();
    assertTrue(executor.get().awaitTermination(100, TimeUnit.MILLISECONDS));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: startAsync (Alternative Action: executor=2 ) - Predicate: isShutdown - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testSegmentReplace
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    int index = hash & (table.length() - 1);

    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference<Object, Object, ?> oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertNull(segment.replace(key, hash, newValue));
    assertEquals(0, segment.count);

    // same key
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.replace(key, hash, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    oldValueRef.clear();
    assertNull(segment.replace(key, hash, newValue));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setWeakValueReferenceForTesting (Alternative Action: replace=3 ) - Predicate: replace - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testClearValue
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);
    WeakValueReference<Object, Object, ?> valueRef = segment.getWeakValueReferenceForTesting(entry);

    // clear absent
    assertFalse(segment.clearValueForTesting(key, hash, valueRef));

    segment.setTableEntryForTesting(0, entry);
    // don't increment count; this is used during computation
    assertTrue(segment.clearValueForTesting(key, hash, valueRef));
    // no notification sent with clearValue
    assertEquals(0, segment.count);
    assertNull(table.get(0));

    // clear wrong value reference
    segment.setTableEntryForTesting(0, entry);
    WeakValueReference<Object, Object, ?> otherValueRef =
        segment.newWeakValueReferenceForTesting(entry, value);
    segment.setWeakValueReferenceForTesting(entry, otherValueRef);
    assertFalse(segment.clearValueForTesting(key, hash, valueRef));
    segment.setWeakValueReferenceForTesting(entry, valueRef);
    assertTrue(segment.clearValueForTesting(key, hash, valueRef));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueForTesting (Alternative Action: clearValueForTesting=4 ) - Predicate: length - Scenario: map (Alternative Scenario: valueRef=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testSegmentRemove
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    int index = hash & (table.length() - 1);

    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference<Object, Object, ?> oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);

    // same key
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertSame(oldValue, segment.remove(key, hash));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));

    // cleared
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.remove(key, hash));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setWeakValueReferenceForTesting (Alternative Action: get=4 ) - Predicate: N/A - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testSegmentPut
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, false));
    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    InternalEntry<Object, Object, ?> entry = segment.getEntry(key, hash);
    WeakValueReference<Object, Object, ?> oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.put(key, hash, newValue, false));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setWeakValueReferenceForTesting (Alternative Action: get=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testSegmentReplaceValue
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    int index = hash & (table.length() - 1);

    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    WeakValueReference<Object, Object, ?> oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);

    // no entry
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(0, segment.count);

    // same value
    segment.setTableEntryForTesting(index, entry);
    segment.count++;
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));
    assertTrue(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // different value
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));

    // cleared
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    oldValueRef.clear();
    assertFalse(segment.replace(key, hash, oldValue, newValue));
    assertEquals(0, segment.count);
    assertNull(segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setWeakValueReferenceForTesting (Alternative Action: replace=4 ) - Predicate: replace - Scenario: oldValueRef (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testRemoveEntry
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);

    // remove absent
    assertFalse(segment.removeTableEntryForTesting(entry));

    segment.setTableEntryForTesting(0, entry);
    segment.count = 1;
    assertTrue(segment.removeTableEntryForTesting(entry));
    assertEquals(0, segment.count);
    assertNull(table.get(0));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueForTesting (Alternative Action: removeTableEntryForTesting=2 ) - Predicate: length - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testClear
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    AtomicReferenceArray<? extends InternalEntry<Object, Object, ?>> table = segment.table;
    assertEquals(1, table.length());

    Object key = new Object();
    Object value = new Object();
    int hash = map.hash(key);
    InternalEntry<Object, Object, ?> entry = segment.newEntryForTesting(key, hash, null);
    segment.setValueForTesting(entry, value);

    segment.setTableEntryForTesting(0, entry);
    segment.readCount.incrementAndGet();
    segment.count = 1;

    assertSame(entry, table.get(0));

    segment.clear();
    assertNull(table.get(0));
    assertEquals(0, segment.readCount.get());
    assertEquals(0, segment.count);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setValueForTesting (Alternative Action: get=3 ) - Predicate: length - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: MapMakerInternalMapTest
 Method: testSegmentPutIfAbsent
 Body: {
    MapMakerInternalMap<Object, Object, ?, ?> map =
        makeMap(createMapMaker().concurrencyLevel(1).weakValues());
    Segment<Object, Object, ?, ?> segment = map.segments[0];
    // TODO(fry): check recency ordering

    Object key = new Object();
    int hash = map.hash(key);
    Object oldValue = new Object();
    Object newValue = new Object();

    // no entry
    assertEquals(0, segment.count);
    assertNull(segment.put(key, hash, oldValue, true));
    assertEquals(1, segment.count);

    // same key
    assertSame(oldValue, segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame(oldValue, segment.get(key, hash));

    // cleared
    InternalEntry<Object, Object, ?> entry = segment.getEntry(key, hash);
    WeakValueReference<Object, Object, ?> oldValueRef =
        segment.newWeakValueReferenceForTesting(entry, oldValue);
    segment.setWeakValueReferenceForTesting(entry, oldValueRef);
    assertSame(oldValue, segment.get(key, hash));
    oldValueRef.clear();
    assertNull(segment.put(key, hash, newValue, true));
    assertEquals(1, segment.count);
    assertSame(newValue, segment.get(key, hash));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: setWeakValueReferenceForTesting (Alternative Action: get=3 ) - Predicate: N/A - Scenario: map (Alternative Scenario: entry=1 )

Project: guava
 Class: MultisetReadsTester
 Method: testEquals_differentElements
 Body: {
    Multiset<E> other = HashMultiset.create(getSampleElements());
    other.remove(e0());
    other.add(e3());
    assertFalse("multiset equals a multiset with different elements", getMultiset().equals(other));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: add=1 ) - Predicate: equals - Scenario: other (Alternative Scenario: other=1 )

Project: guava
 Class: CallablesTest
 Method: testRenaming
 Body: {
    String oldName = Thread.currentThread().getName();
    final Supplier<String> newName = Suppliers.ofInstance("MyCrazyThreadName");
    Callable<Void> callable =
        new Callable<Void>() {
          @Override
          public Void call() throws Exception {
            assertEquals(Thread.currentThread().getName(), newName.get());
            return null;
          }
        };
    Callables.threadRenaming(callable, newName).call();
    assertEquals(oldName, Thread.currentThread().getName());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: call (Alternative Action: currentThread=3 ) - Predicate: getName - Scenario: callable (Alternative Scenario: callable=1 )

Project: guava
 Class: AbstractIdleServiceTest
 Method: testStop_withoutStart
 Body: {
    TestService service = new TestService();
    service.stopAsync().awaitTerminated();
    assertEquals(0, service.startUpCalled);
    assertEquals(0, service.shutDownCalled);
    assertEquals(Service.State.TERMINATED, service.state());
    assertThat(service.transitionStates).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitTerminated (Alternative Action: awaitTerminated=1 ) - Predicate: N/A - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractIdleServiceTest
 Method: testStart
 Body: {
    TestService service = new TestService();
    assertEquals(0, service.startUpCalled);
    service.startAsync().awaitRunning();
    assertEquals(1, service.startUpCalled);
    assertEquals(Service.State.RUNNING, service.state());
    assertThat(service.transitionStates).containsExactly(Service.State.STARTING);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: state=1 ) - Predicate: N/A - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractIdleServiceTest
 Method: testStop_afterStart
 Body: {
    TestService service = new TestService();
    service.startAsync().awaitRunning();
    assertEquals(1, service.startUpCalled);
    assertEquals(0, service.shutDownCalled);
    service.stopAsync().awaitTerminated();
    assertEquals(1, service.startUpCalled);
    assertEquals(1, service.shutDownCalled);
    assertEquals(Service.State.TERMINATED, service.state());
    assertThat(service.transitionStates)
        .containsExactly(Service.State.STARTING, Service.State.STOPPING)
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: awaitTerminated=1 ) - Predicate: N/A - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: AbstractIdleServiceTest
 Method: testServiceToString
 Body: {
    AbstractIdleService service = new TestService();
    assertEquals("TestService [NEW]", service.toString());
    service.startAsync().awaitRunning();
    assertEquals("TestService [RUNNING]", service.toString());
    service.stopAsync().awaitTerminated();
    assertEquals("TestService [TERMINATED]", service.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: toString=3 ) - Predicate: toString - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: TransposedTableTest
 Method: testTransposedViews
 Body: {
    Table<Integer, String, Character> original = HashBasedTable.create();
    Table<String, Integer, Character> transpose = Tables.transpose(original);
    original.put(1, "foo", 'a');
    assertSame(original.columnKeySet(), transpose.rowKeySet());
    assertSame(original.rowKeySet(), transpose.columnKeySet());
    assertSame(original.columnMap(), transpose.rowMap());
    assertSame(original.rowMap(), transpose.columnMap());
    assertSame(original.values(), transpose.values());
    assertEquals(original.row(1), transpose.column(1));
    assertEquals(original.row(2), transpose.column(2));
    assertEquals(original.column("foo"), transpose.row("foo"));
    assertEquals(original.column("bar"), transpose.row("bar"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: column=4 ) - Predicate: columnKeySet - Scenario: transpose (Alternative Scenario: original=1 )

Project: guava
 Class: TransposedTableTest
 Method: testPutTransposeModifiesOriginal
 Body: {
    Table<Integer, String, Character> original = HashBasedTable.create();
    Table<String, Integer, Character> transpose = Tables.transpose(original);
    transpose.put("foo", 1, 'a');
    assertEquals((Character) 'a', original.get(1, "foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=1 ) - Predicate: get - Scenario: transpose (Alternative Scenario: original=1 )

Project: guava
 Class: TransposedTableTest
 Method: testPutOriginalModifiesTranspose
 Body: {
    Table<Integer, String, Character> original = HashBasedTable.create();
    Table<String, Integer, Character> transpose = Tables.transpose(original);
    original.put(1, "foo", 'a');
    assertEquals((Character) 'a', transpose.get("foo", 1));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: get=1 ) - Predicate: get - Scenario: transpose (Alternative Scenario: original=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformRemoveEntry
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals("1", map.remove("a"));
    assertNull(map.remove("b"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: remove=2 ) - Predicate: remove - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEntrySetContains
 Body: {
    Map<String, Boolean> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", true);
    underlying.put(null, true);

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<Boolean, Boolean>() {
              @Override
              public Boolean apply(@Nullable Boolean from) {
                return (from == null) ? true : null;
              }
            });

    Set<Entry<String, Boolean>> entries = map.entrySet();
    assertTrue(entries.contains(Maps.immutableEntry("a", true)));
    assertTrue(entries.contains(Maps.immutableEntry("b", (Boolean) null)));
    assertTrue(entries.contains(Maps.immutableEntry((String) null, (Boolean) null)));

    assertFalse(entries.contains(Maps.immutableEntry("c", (Boolean) null)));
    assertFalse(entries.contains(Maps.immutableEntry((String) null, true)));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: contains=5 ) - Predicate: contains - Scenario: map (Alternative Scenario: entries=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformReflectsUnderlyingMap
 Body: {
    Map<String, Integer> underlying = Maps.newHashMap();
    underlying.put("a", 1);
    underlying.put("b", 2);
    underlying.put("c", 3);
    Map<String, String> map = Maps.transformValues(underlying, Functions.toStringFunction());
    assertEquals(underlying.size(), map.size());

    underlying.put("d", 4);
    assertEquals(underlying.size(), map.size());
    assertEquals("4", map.get("d"));

    underlying.remove("c");
    assertEquals(underlying.size(), map.size());
    assertFalse(map.containsKey("c"));

    underlying.clear();
    assertEquals(underlying.size(), map.size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: size=8 ) - Predicate: size - Scenario: map (Alternative Scenario: underlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEquals
 Body: {
    Map<String, Integer> underlying = ImmutableMap.of("a", 0, "b", 1, "c", 2);
    Map<String, Integer> expected = Maps.transformValues(underlying, Functions.<Integer>identity());

    assertMapsEqual(expected, expected);

    Map<String, Integer> equalToUnderlying = Maps.newTreeMap();
    equalToUnderlying.putAll(underlying);
    Map<String, Integer> map =
        Maps.transformValues(equalToUnderlying, Functions.<Integer>identity());
    assertMapsEqual(expected, map);

    map =
        Maps.transformValues(
            ImmutableMap.of("a", 1, "b", 2, "c", 3),
            new Function<Integer, Integer>() {
              @Override
              public Integer apply(Integer from) {
                return from - 1;
              }
            });
    assertMapsEqual(expected, map);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: transformValues=3 ) - Predicate: N/A - Scenario: underlying (Alternative Scenario: equalToUnderlying=1 )

Project: guava
 Class: MapsTransformValuesTest
 Method: testTransformEqualityOfMapsWithNullValues
 Body: {
    Map<String, String> underlying = Maps.newHashMap();
    underlying.put("a", null);
    underlying.put("b", "");

    Map<String, Boolean> map =
        Maps.transformValues(
            underlying,
            new Function<String, Boolean>() {
              @Override
              public Boolean apply(@Nullable String from) {
                return from == null;
              }
            });
    Map<String, Boolean> expected = ImmutableMap.of("a", true, "b", false);
    assertMapsEqual(expected, map);
    assertEquals(expected.get("a"), map.get("a"));
    assertEquals(expected.containsKey("a"), map.containsKey("a"));
    assertEquals(expected.get("b"), map.get("b"));
    assertEquals(expected.containsKey("b"), map.containsKey("b"));
    assertEquals(expected.get("c"), map.get("c"));
    assertEquals(expected.containsKey("c"), map.containsKey("c"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: containsKey=6 ) - Predicate: N/A - Scenario: map (Alternative Scenario: expected=1 )

Project: guava
 Class: ByteSinkTest
 Method: testOpenBufferedStream
 Body: {
    OutputStream out = sink.openBufferedStream();
    assertTrue(sink.wasStreamOpened());
    assertFalse(sink.wasStreamClosed());

    out.write(new byte[] {1, 2, 3, 4});
    out.close();

    assertTrue(sink.wasStreamClosed());
    assertArrayEquals(new byte[] {1, 2, 3, 4}, sink.getBytes());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: wasStreamClosed=2 ) - Predicate: wasStreamOpened - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ByteSinkTest
 Method: testWriteFromStream_doesNotCloseThatStream
 Body: {
    TestInputStream in = new TestInputStream(new ByteArrayInputStream(new byte[10]));
    assertFalse(in.closed());
    sink.writeFrom(in);
    assertFalse(in.closed());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeFrom (Alternative Action: closed=2 ) - Predicate: closed - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: ByteSinkTest
 Method: testWriteFrom_inputStream
 Body: {
    ByteArrayInputStream in = new ByteArrayInputStream(bytes);
    sink.writeFrom(in);

    assertTrue(sink.wasStreamOpened() && sink.wasStreamClosed());
    assertArrayEquals(bytes, sink.getBytes());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: writeFrom (Alternative Action: wasStreamClosed=1 ) - Predicate: N/A - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testEquals_bothExplicitOrdering
 Body: {
    SortedSet<String> set = of("in", "the", "a");
    assertEquals(Sets.newTreeSet(asList("in", "the", "a")), set);
    assertFalse(set.equals(Sets.newTreeSet(asList("in", "the", "house"))));
    assertFalse(Sets.newTreeSet(asList("in", "the", "house")).equals(set));
    assertFalse(set.equals(Sets.newHashSet(4, 5, 6)));
    assertFalse(Sets.newHashSet(4, 5, 6).equals(set));

    Set<String> complex = Sets.newTreeSet(STRING_LENGTH);
    Collections.addAll(complex, "in", "the", "a");
    assertEquals(set, complex);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: equals=4 ) - Predicate: newTreeSet - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testLegacyComparable_builder_natural
 Body: {
    @SuppressWarnings("unchecked")
    // Note: IntelliJ wrongly reports an error for this statement
    ImmutableSortedSet.Builder<LegacyComparable> builder =
        ImmutableSortedSet.<LegacyComparable>naturalOrder();

    builder.addAll(LegacyComparable.VALUES_BACKWARD);
    builder.add(LegacyComparable.X);
    builder.add(LegacyComparable.Y, LegacyComparable.Z);

    ImmutableSortedSet<LegacyComparable> set = builder.build();
    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_FORWARD, set));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: elementsEqual - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testCopyOf_sortedSetIterable
 Body: {
    SortedSet<String> input = Sets.newTreeSet(STRING_LENGTH);
    Collections.addAll(input, "in", "the", "quick", "jumped", "over", "a");
    SortedSet<String> set = copyOf(input);
    assertThat(set).containsExactly("a", "in", "jumped", "over", "quick", "the").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: addAll=1 ) - Predicate: N/A - Scenario: set (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testCopyOfSorted_explicit_ordering
 Body: {
    SortedSet<String> input = Sets.newTreeSet(STRING_LENGTH);
    Collections.addAll(input, "in", "the", "quick", "jumped", "over", "a");
    SortedSet<String> set = ImmutableSortedSet.copyOfSorted(input);
    assertThat(set).containsExactly("a", "in", "the", "over", "quick", "jumped").inOrder();
    assertSame(STRING_LENGTH, set.comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: comparator=1 ) - Predicate: N/A - Scenario: set (Alternative Scenario: input=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testContainsAll_sameComparator_StringVsInt
 Body: {
    SortedSet<String> set = of("a", "b", "f");
    SortedSet<Integer> unexpected = Sets.newTreeSet(Ordering.natural());
    unexpected.addAll(asList(1, 2, 3));
    assertFalse(set.containsAll(unexpected));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: addAll (Alternative Action: natural=1 ) - Predicate: containsAll - Scenario: unexpected (Alternative Scenario: set=1 )

Project: guava
 Class: ImmutableSortedSetTest
 Method: testLegacyComparable_builder_reverse
 Body: {
    @SuppressWarnings("unchecked")
    // Note: IntelliJ wrongly reports an error for this statement
    ImmutableSortedSet.Builder<LegacyComparable> builder =
        ImmutableSortedSet.<LegacyComparable>reverseOrder();

    builder.addAll(LegacyComparable.VALUES_FORWARD);
    builder.add(LegacyComparable.X);
    builder.add(LegacyComparable.Y, LegacyComparable.Z);

    ImmutableSortedSet<LegacyComparable> set = builder.build();
    assertTrue(Iterables.elementsEqual(LegacyComparable.VALUES_BACKWARD, set));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: elementsEqual - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: LinkedHashMultimapTest
 Method: testCreate
 Body: {
    LinkedHashMultimap<String, Integer> multimap = LinkedHashMultimap.create();
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    assertEquals(ImmutableSet.of(1, 3), multimap.get("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedHashMultimapTest
 Method: testToStringNullExact
 Body: {
    Multimap<String, Integer> multimap = LinkedHashMultimap.create();

    multimap.put("foo", 3);
    multimap.put("foo", -1);
    multimap.put(null, null);
    multimap.put("bar", 1);
    multimap.put("foo", 2);
    multimap.put(null, 0);
    multimap.put("bar", 2);
    multimap.put("bar", null);
    multimap.put("foo", null);
    multimap.put("foo", 4);
    multimap.put(null, -1);
    multimap.put("bar", 3);
    multimap.put("bar", 1);
    multimap.put("foo", 1);

    assertEquals(
        "{foo=[3, -1, 2, null, 4, 1], null=[null, 0, -1], bar=[1, 2, null, 3]}",
        multimap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=14 ) - Predicate: toString - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedHashMultimapTest
 Method: testToString
 Body: {
    Multimap<String, Integer> multimap = LinkedHashMultimap.create();
    multimap.put("foo", 3);
    multimap.put("bar", 1);
    multimap.putAll("foo", Arrays.asList(-1, 2, 4));
    multimap.putAll("bar", Arrays.asList(2, 3));
    multimap.put("foo", 1);
    assertEquals("{foo=[3, -1, 2, 4, 1], bar=[1, 2, 3]}", multimap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: toString - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedHashMultimapTest
 Method: testCreateFromSizes
 Body: {
    LinkedHashMultimap<String, Integer> multimap = LinkedHashMultimap.create(20, 15);
    multimap.put("foo", 1);
    multimap.put("bar", 2);
    multimap.put("foo", 3);
    assertEquals(ImmutableSet.of(1, 3), multimap.get("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: LinkedHashMultimapTest
 Method: testOrderingUpdates
 Body: {
    Multimap<String, Integer> multimap = initializeMultimap5();

    assertThat(multimap.replaceValues("foo", asList(6, 7))).containsExactly(5, 3).inOrder();
    assertThat(multimap.keySet()).containsExactly("foo", "bar", "cow").inOrder();
    assertThat(multimap.removeAll("foo")).containsExactly(6, 7).inOrder();
    assertThat(multimap.keySet()).containsExactly("bar", "cow").inOrder();
    assertTrue(multimap.remove("bar", 4));
    assertThat(multimap.keySet()).containsExactly("bar", "cow").inOrder();
    assertTrue(multimap.remove("bar", 1));
    assertThat(multimap.keySet()).contains("cow");
    multimap.put("bar", 9);
    assertThat(multimap.keySet()).containsExactly("cow", "bar").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: keySet=5 ) - Predicate: N/A - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: ByteSourceTest
 Method: testOpenBufferedStream
 Body: {
    InputStream in = source.openBufferedStream();
    assertTrue(source.wasStreamOpened());
    assertFalse(source.wasStreamClosed());

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    ByteStreams.copy(in, out);
    in.close();
    out.close();

    assertTrue(source.wasStreamClosed());
    assertArrayEquals(bytes, out.toByteArray());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copy (Alternative Action: wasStreamClosed=2 ) - Predicate: wasStreamOpened - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: ByteSourceTest
 Method: testRead_withProcessor
 Body: {
    final byte[] processedBytes = new byte[bytes.length];
    ByteProcessor<byte[]> processor =
        new ByteProcessor<byte[]>() {
          int pos;

          @Override
          public boolean processBytes(byte[] buf, int off, int len) throws IOException {
            System.arraycopy(buf, off, processedBytes, pos, len);
            pos += len;
            return true;
          }

          @Override
          public byte[] getResult() {
            return processedBytes;
          }
        };

    source.read(processor);
    assertTrue(source.wasStreamOpened() && source.wasStreamClosed());

    assertArrayEquals(bytes, processedBytes);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: read (Alternative Action: wasStreamClosed=1 ) - Predicate: N/A - Scenario: processor (Alternative Scenario: processedBytes=1 )

Project: guava
 Class: ByteSourceTest
 Method: testSlice_appendingAfterSlicing
 Body: {
    // Source of length 5
    AppendableByteSource source = new AppendableByteSource(newPreFilledByteArray(5));

    // Slice it starting at offset 10.
    ByteSource slice = source.slice(10, 5);

    // Open a stream to the slice.
    InputStream in = slice.openStream();

    // Append 10 more bytes to the source.
    source.append(newPreFilledByteArray(5, 10));

    // The stream reports no bytes... importantly, it doesn't read the byte at index 5 when it
    // should be reading the byte at index 10.
    // We could use a custom InputStream instead to make the read start at index 10, but since this
    // is a racy situation anyway, this behavior seems reasonable.
    assertEquals(-1, in.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: append (Alternative Action: newPreFilledByteArray=2 ) - Predicate: read - Scenario: in (Alternative Scenario: in=1 )

Project: guava
 Class: ByteSourceTest
 Method: testCopyToStream_doesNotCloseThatStream
 Body: {
    TestOutputStream out = new TestOutputStream(ByteStreams.nullOutputStream());
    assertFalse(out.closed());
    source.copyTo(out);
    assertFalse(out.closed());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: copyTo (Alternative Action: closed=2 ) - Predicate: closed - Scenario: out (Alternative Scenario: out=1 )

Project: guava
 Class: ImmutableLongArrayTest
 Method: testBuilder_presize_zero
 Body: {
    ImmutableLongArray.Builder builder = ImmutableLongArray.builder(0);
    builder.add(5L);
    ImmutableLongArray array = builder.build();
    assertThat(array.asList()).containsExactly(5L);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=1 ) - Predicate: N/A - Scenario: array (Alternative Scenario: array=1 )

Project: guava
 Class: ImmutableLongArrayTest
 Method: testCopyOf_collection_nonempty
 Body: {
    List<Long> list = Arrays.asList(0L, 1L, 3L);
    ImmutableLongArray iia = ImmutableLongArray.copyOf(list);
    list.set(2, 2L);
    assertThat(iia.asList()).containsExactly(0L, 1L, 3L).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableLongArrayTest
 Method: testCopyOf_iterable_collection_nonempty
 Body: {
    List<Long> list = Arrays.asList(0L, 1L, 3L);
    ImmutableLongArray iia = ImmutableLongArray.copyOf((Iterable<Long>) list);
    list.set(2, 2L);
    assertThat(iia.asList()).containsExactly(0L, 1L, 3L).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: ImmutableLongArrayTest
 Method: testForEach
 Body: {
    ImmutableLongArray.of().forEach(i -> fail());
    ImmutableLongArray.of(0, 1, 3).subArray(1, 1).forEach(i -> fail());

    AtomicLong count = new AtomicLong(0);
    ImmutableLongArray.of(0, 1, 2, 3)
        .forEach(i -> assertThat(i).isEqualTo(count.getAndIncrement()));
    assertEquals(4, count.get());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: of=3 ) - Predicate: N/A - Scenario: count (Alternative Scenario: count=1 )

Project: guava
 Class: ImmutableLongArrayTest
 Method: testCopyOf_iterable_notCollection_nonempty
 Body: {
    List<Long> list = Arrays.asList(0L, 1L, 3L);
    ImmutableLongArray iia = ImmutableLongArray.copyOf(iterable(list));
    list.set(2, 2L);
    assertThat(iia.asList()).containsExactly(0L, 1L, 3L).inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: asList=2 ) - Predicate: N/A - Scenario: iia (Alternative Scenario: iia=1 )

Project: guava
 Class: SchedulerTest
 Method: testCustomSchedulerServiceStop
 Body: {
      TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService();
      service.startAsync().awaitRunning();
      service.firstBarrier.await();
      assertEquals(1, service.numIterations.get());
      service.stopAsync();
      service.secondBarrier.await();
      service.awaitTerminated();
      // Sleep for a while just to ensure that our task wasn't called again.
      Thread.sleep(unit.toMillis(3 * delay));
      assertEquals(1, service.numIterations.get());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: awaitRunning (Alternative Action: get=2 ) - Predicate: get - Scenario: service (Alternative Scenario: service=1 )

Project: guava
 Class: SchedulerTest
 Method: testBig
 Body: {
      TestAbstractScheduledCustomService service =
          new TestAbstractScheduledCustomService() {
            @Override
            protected Scheduler scheduler() {
              return new AbstractScheduledService.CustomScheduler() {
                @Override
                protected Schedule getNextSchedule() throws Exception {
                  // Explicitly yield to increase the probability of a pathological scheduling.
                  Thread.yield();
                  return new Schedule(0, TimeUnit.SECONDS);
                }
              };
            }
          };
      service.useBarriers = false;
      service.startAsync().awaitRunning();
      Thread.sleep(50);
      service.useBarriers = true;
      service.firstBarrier.await();
      int numIterations = service.numIterations.get();
      service.stopAsync();
      service.secondBarrier.await();
      service.awaitTerminated();
      assertEquals(numIterations, service.numIterations.get());
    }
 Pattern Name: NormalPattern_AnyLOC - Action: stopAsync (Alternative Action: get=2 ) - Predicate: get - Scenario: numIterations (Alternative Scenario: numIterations=1 )

Project: guava
 Class: SchedulerTest
 Method: testCustomSchedule_startStop
 Body: {
      final CyclicBarrier firstBarrier = new CyclicBarrier(2);
      final CyclicBarrier secondBarrier = new CyclicBarrier(2);
      final AtomicBoolean shouldWait = new AtomicBoolean(true);
      Runnable task =
          new Runnable() {
            @Override
            public void run() {
              try {
                if (shouldWait.get()) {
                  firstBarrier.await();
                  secondBarrier.await();
                }
              } catch (Exception e) {
                throw new RuntimeException(e);
              }
            }
          };
      TestCustomScheduler scheduler = new TestCustomScheduler();
      Future<?> future = scheduler.schedule(null, Executors.newScheduledThreadPool(10), task);
      firstBarrier.await();
      assertEquals(1, scheduler.scheduleCounter.get());
      secondBarrier.await();
      firstBarrier.await();
      assertEquals(2, scheduler.scheduleCounter.get());
      shouldWait.set(false);
      secondBarrier.await();
      future.cancel(false);
    }
 Pattern Name: NormalPattern_AnyLOC - Action: await (Alternative Action: await=6 ) - Predicate: get - Scenario: future (Alternative Scenario: scheduler=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testCreateFromHashMultimap
 Body: {
    Multimap<Double, Double> hash = HashMultimap.create();
    hash.put(1.0, 2.0);
    hash.put(2.0, 3.0);
    hash.put(3.0, 4.0);
    hash.put(4.0, 5.0);

    TreeMultimap<Double, Double> copyFromHash = TreeMultimap.create(hash);
    assertEquals(hash, copyFromHash);
    assertEquals(Ordering.natural(), copyFromHash.keyComparator());
    assertEquals(Ordering.natural(), copyFromHash.valueComparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: copyFromHash (Alternative Scenario: copyFromHash=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testMultimapConstructor
 Body: {
    SetMultimap<String, Integer> multimap = create();
    multimap.putAll("bar", Arrays.asList(3, 1, 2));
    multimap.putAll("foo", Arrays.asList(2, 3, 1, -1, 4));
    TreeMultimap<String, Integer> copy = TreeMultimap.create(multimap);
    assertEquals(multimap, copy);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testCreateFromSortedSetMultimap
 Body: {
    SortedSetMultimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);
    tree.put(1.0, 2.0);
    tree.put(2.0, 3.0);
    tree.put(3.0, 4.0);
    tree.put(4.0, 5.0);

    SortedSetMultimap<Double, Double> sorted = Multimaps.unmodifiableSortedSetMultimap(tree);
    TreeMultimap<Double, Double> copyFromSorted = TreeMultimap.create(sorted);
    assertEquals(tree, copyFromSorted);
    assertSame(Ordering.natural(), copyFromSorted.keyComparator());
    assertSame(Ordering.natural(), copyFromSorted.valueComparator());
    assertSame(Ordering.natural(), copyFromSorted.get(1.0).comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: sorted (Alternative Scenario: sorted=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testTreeMultimapNonGeneric
 Body: {
    TreeMultimap<LegacyComparable, LegacyComparable> multimap = TreeMultimap.create();
    assertEquals(ImmutableMultimap.of(), multimap);
    multimap.put(new LegacyComparable("foo"), new LegacyComparable("f"));
    multimap.put(new LegacyComparable("foo"), new LegacyComparable("o"));
    multimap.put(new LegacyComparable("foo"), new LegacyComparable("o"));
    multimap.put(new LegacyComparable("bar"), new LegacyComparable("b"));
    multimap.put(new LegacyComparable("bar"), new LegacyComparable("a"));
    multimap.put(new LegacyComparable("bar"), new LegacyComparable("r"));
    assertThat(multimap.keySet())
        .containsExactly(new LegacyComparable("bar"), new LegacyComparable("foo"))
        .inOrder();
    assertThat(multimap.values())
        .containsExactly(
            new LegacyComparable("a"),
            new LegacyComparable("b"),
            new LegacyComparable("r"),
            new LegacyComparable("f"),
            new LegacyComparable("o"))
        .inOrder();
    assertEquals(Ordering.natural(), multimap.keyComparator());
    assertEquals(Ordering.natural(), multimap.valueComparator());
    SerializableTester.reserializeAndAssert(multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testCreateFromTreeMultimap
 Body: {
    Multimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);
    tree.put(1.0, 2.0);
    tree.put(2.0, 3.0);
    tree.put(3.0, 4.0);
    tree.put(4.0, 5.0);

    TreeMultimap<Double, Double> copyFromTree = TreeMultimap.create(tree);
    assertEquals(tree, copyFromTree);
    assertSame(Ordering.natural(), copyFromTree.keyComparator());
    assertSame(Ordering.natural(), copyFromTree.valueComparator());
    assertSame(Ordering.natural(), copyFromTree.get(1.0).comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: copyFromTree (Alternative Scenario: tree=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testToString
 Body: {
    SetMultimap<String, Integer> multimap = create();
    multimap.putAll("bar", Arrays.asList(3, 1, 2));
    multimap.putAll("foo", Arrays.asList(2, 3, 1, -1, 4));
    assertEquals("{bar=[1, 2, 3], foo=[-1, 1, 2, 3, 4]}", multimap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=2 ) - Predicate: toString - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testTreeMultimapDerived
 Body: {
    TreeMultimap<DerivedComparable, DerivedComparable> multimap = TreeMultimap.create();
    assertEquals(ImmutableMultimap.of(), multimap);
    multimap.put(new DerivedComparable("foo"), new DerivedComparable("f"));
    multimap.put(new DerivedComparable("foo"), new DerivedComparable("o"));
    multimap.put(new DerivedComparable("foo"), new DerivedComparable("o"));
    multimap.put(new DerivedComparable("bar"), new DerivedComparable("b"));
    multimap.put(new DerivedComparable("bar"), new DerivedComparable("a"));
    multimap.put(new DerivedComparable("bar"), new DerivedComparable("r"));
    assertThat(multimap.keySet())
        .containsExactly(new DerivedComparable("bar"), new DerivedComparable("foo"))
        .inOrder();
    assertThat(multimap.values())
        .containsExactly(
            new DerivedComparable("a"),
            new DerivedComparable("b"),
            new DerivedComparable("r"),
            new DerivedComparable("f"),
            new DerivedComparable("o"))
        .inOrder();
    assertEquals(Ordering.natural(), multimap.keyComparator());
    assertEquals(Ordering.natural(), multimap.valueComparator());
    SerializableTester.reserializeAndAssert(multimap);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=6 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: TreeMultimapNaturalTest
 Method: testTailSetClear
 Body: {
    TreeMultimap<String, Integer> multimap = TreeMultimap.create();
    multimap.put("a", 1);
    multimap.put("a", 11);
    multimap.put("b", 2);
    multimap.put("c", 3);
    multimap.put("d", 4);
    multimap.put("e", 5);
    multimap.put("e", 55);

    multimap.keySet().tailSet("d").clear();
    assertEquals(ImmutableSet.of("a", "b", "c"), multimap.keySet());
    assertEquals(4, multimap.size());
    assertEquals(4, multimap.values().size());
    assertEquals(4, multimap.keys().size());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=7 ) - Predicate: of - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: CollectionForEachTester
 Method: testForEachKnownOrder
 Body: {
    List<E> elements = new ArrayList<E>();
    collection.forEach(elements::add);
    List<E> expected = Helpers.copyToList(getOrderedElements());
    assertEquals("Different ordered iteration", expected, elements);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: forEach (Alternative Action: copyToList=1 ) - Predicate: N/A - Scenario: expected (Alternative Scenario: expected=1 )

Project: guava
 Class: MoreFilesFileTraverserTest
 Method: testFileTraverser_multipleDirectoryLayers_breadthFirstStartsWithTopLayer
 Body: {
    Path fileA = newFile("file-a");
    Path dir1 = newDir("dir-1");
    newFile("dir-1/file-b");
    newFile("dir-1/dir-2");

    assertThat(Iterables.limit(MoreFiles.fileTraverser().breadthFirst(rootDir), 3))
        .containsExactly(rootDir, fileA, dir1);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: newFile (Alternative Action: newFile=3 ) - Predicate: N/A - Scenario: dir1 (Alternative Scenario: dir1=1 )

Project: guava
 Class: HashMultisetTest
 Method: testSerializationContainingSelf
 Body: {
    Multiset<Multiset<?>> multiset = HashMultiset.create();
    multiset.add(multiset, 2);
    Multiset<Multiset<?>> copy = SerializableTester.reserialize(multiset);
    assertEquals(2, copy.size());
    assertSame(copy, copy.iterator().next());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: next=1 ) - Predicate: size - Scenario: copy (Alternative Scenario: multiset=1 )

Project: guava
 Class: HashMultisetTest
 Method: testCreateWithSize
 Body: {
    Multiset<String> multiset = HashMultiset.create(50);
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: HashMultisetTest
 Method: testCreate
 Body: {
    Multiset<String> multiset = HashMultiset.create();
    multiset.add("foo", 2);
    multiset.add("bar");
    assertEquals(3, multiset.size());
    assertEquals(2, multiset.count("foo"));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: size - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: HashMultisetTest
 Method: testSerializationIndirectSelfReference
 Body: {
    Multiset<MultisetHolder> multiset = HashMultiset.create();
    MultisetHolder holder = new MultisetHolder(multiset);
    multiset.add(holder, 2);
    Multiset<MultisetHolder> copy = SerializableTester.reserialize(multiset);
    assertEquals(2, copy.size());
    assertSame(copy, copy.iterator().next().member);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: next=1 ) - Predicate: size - Scenario: copy (Alternative Scenario: multiset=1 )

Project: guava
 Class: LittleEndianDataInputStreamTest
 Method: testReadFully
 Body: {
    DataInput in = new LittleEndianDataInputStream(new ByteArrayInputStream(data));
    byte[] b = new byte[data.length];
    in.readFully(b);
    assertEquals(Bytes.asList(data), Bytes.asList(b));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: asList=2 ) - Predicate: asList - Scenario: b (Alternative Scenario: b=1 )

Project: guava
 Class: LittleEndianDataInputStreamTest
 Method: testReadLittleEndian
 Body: {
    DataInput in = new LittleEndianDataInputStream(new ByteArrayInputStream(data));

    /* Read in various values in LITTLE ENDIAN FORMAT */
    byte[] b = new byte[2];
    in.readFully(b);
    assertEquals(-100, b[0]);
    assertEquals(100, b[1]);
    assertEquals(true, in.readBoolean());
    assertEquals(false, in.readBoolean());
    assertEquals(100, in.readByte());
    assertEquals(-100, in.readByte());
    assertEquals(200, in.readUnsignedByte());
    assertEquals('\u6100', in.readChar());
    assertEquals(-12150, in.readShort());
    assertEquals(20675, in.readUnsignedShort());
    assertEquals(0xBEBAFECA, in.readInt());
    assertEquals(0xBEBAFECAEFBEADDEL, in.readLong());
    assertEquals("Herby Derby", in.readUTF());
    assertEquals(0xBEBAFECA, Float.floatToIntBits(in.readFloat()));
    assertEquals(0xBEBAFECAEFBEADDEL, Double.doubleToLongBits(in.readDouble()));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: readFully (Alternative Action: readBoolean=2 ) - Predicate: N/A - Scenario: b (Alternative Scenario: b=1 )

Project: guava
 Class: MultisetRemoveTester
 Method: testRetainAllIgnoresCount
 Body: {
    initThreeCopies();
    List<E> contents = Helpers.copyToList(getMultiset());
    assertFalse(getMultiset().retainAll(Collections.singleton(e0())));
    expectContents(contents);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: initThreeCopies (Alternative Action: getMultiset=2 ) - Predicate: retainAll - Scenario: contents (Alternative Scenario: contents=1 )

Project: guava
 Class: SubscriberTest
 Method: testInvokeSubscriberMethod_basicMethodCall
 Body: {
    Method method = getTestSubscriberMethod("recordingMethod");
    Subscriber subscriber = Subscriber.create(bus, this, method);

    subscriber.invokeSubscriberMethod(FIXTURE_ARGUMENT);

    assertTrue("Subscriber must call provided method", methodCalled);
    assertTrue(
        "Subscriber argument must be exactly the provided object.",
        methodArgument == FIXTURE_ARGUMENT);
  }
 Pattern Name: NormalPattern_AnyLOC - Action: invokeSubscriberMethod (Alternative Action: invokeSubscriberMethod=1 ) - Predicate: N/A - Scenario: subscriber (Alternative Scenario: subscriber=1 )

Project: guava
 Class: ValueGraphTest
 Method: equivalence_considersEdgeValue
 Body: {
    graph = ValueGraphBuilder.undirected().build();
    graph.putEdgeValue(1, 2, "valueA");

    MutableValueGraph<Integer, String> otherGraph = ValueGraphBuilder.undirected().build();
    otherGraph.putEdgeValue(1, 2, "valueA");
    assertThat(graph).isEqualTo(otherGraph);

    otherGraph.putEdgeValue(1, 2, "valueB");
    assertThat(graph).isNotEqualTo(otherGraph); // values differ
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putEdgeValue (Alternative Action: putEdgeValue=3 ) - Predicate: N/A - Scenario: otherGraph (Alternative Scenario: otherGraph=1 )

Project: guava
 Class: InvokableTest
 Method: testInstanceMethod_parameters
 Body: {
    Invokable<?, ?> delegate = Prepender.method("prepend", Iterable.class);
    ImmutableList<Parameter> parameters = delegate.getParameters();
    assertEquals(1, parameters.size());
    assertEquals(new TypeToken<Iterable<String>>() {}, parameters.get(0).getType());
    assertThat(parameters.get(0).getAnnotations()).isEmpty();
    new EqualsTester().addEqualityGroup(parameters.get(0)).testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: get=3 ) - Predicate: size - Scenario: delegate (Alternative Scenario: delegate=1 )

Project: guava
 Class: InvokableTest
 Method: testConstructor_parameters
 Body: {
    Invokable<?, Prepender> delegate = Prepender.constructor(String.class, int.class);
    ImmutableList<Parameter> parameters = delegate.getParameters();
    assertEquals(2, parameters.size());
    assertEquals(String.class, parameters.get(0).getType().getType());
    assertTrue(parameters.get(0).isAnnotationPresent(NotBlank.class));
    assertEquals(int.class, parameters.get(1).getType().getType());
    assertFalse(parameters.get(1).isAnnotationPresent(NotBlank.class));
    new EqualsTester()
        .addEqualityGroup(parameters.get(0))
        .addEqualityGroup(parameters.get(1))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: get=6 ) - Predicate: size - Scenario: delegate (Alternative Scenario: delegate=1 )

Project: guava
 Class: InvokableTest
 Method: testStaticMethod_parameters
 Body: {
    Invokable<?, ?> delegate = Prepender.method("prepend", String.class, Iterable.class);
    ImmutableList<Parameter> parameters = delegate.getParameters();
    assertEquals(2, parameters.size());
    assertEquals(String.class, parameters.get(0).getType().getType());
    assertTrue(parameters.get(0).isAnnotationPresent(NotBlank.class));
    assertEquals(new TypeToken<Iterable<String>>() {}, parameters.get(1).getType());
    assertFalse(parameters.get(1).isAnnotationPresent(NotBlank.class));
    new EqualsTester()
        .addEqualityGroup(parameters.get(0))
        .addEqualityGroup(parameters.get(1))
        .testEquals();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: testEquals (Alternative Action: get=6 ) - Predicate: size - Scenario: delegate (Alternative Scenario: delegate=1 )

Project: guava
 Class: CharStreamsTest
 Method: testNullWriter
 Body: {
    // create a null writer
    Writer nullWriter = CharStreams.nullWriter();
    // write to the writer
    nullWriter.write('n');
    String test = "Test string for NullWriter";
    nullWriter.write(test);
    nullWriter.write(test, 2, 10);
    // nothing really to assert?
    assertSame(CharStreams.nullWriter(), CharStreams.nullWriter());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: write (Alternative Action: nullWriter=3 ) - Predicate: nullWriter - Scenario: test (Alternative Scenario: test=1 )

Project: guava
 Class: CharStreamsTest
 Method: testSkipFully
 Body: {
    String testString = "abcdef";
    Reader reader = new StringReader(testString);

    assertEquals(testString.charAt(0), reader.read());
    CharStreams.skipFully(reader, 1);
    assertEquals(testString.charAt(2), reader.read());
    CharStreams.skipFully(reader, 2);
    assertEquals(testString.charAt(5), reader.read());

    assertEquals(-1, reader.read());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: skipFully (Alternative Action: read=4 ) - Predicate: charAt - Scenario: testString (Alternative Scenario: reader=1 )

Project: guava
 Class: MultisetsTest
 Method: testNewTreeMultisetComparator
 Body: {
    TreeMultiset<String> multiset = TreeMultiset.create(Collections.reverseOrder());
    multiset.add("bar", 3);
    multiset.add("foo", 2);
    assertThat(multiset).containsExactly("foo", "foo", "bar", "bar", "bar").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: N/A - Scenario: multiset (Alternative Scenario: multiset=1 )

Project: guava
 Class: MultisetsTest
 Method: testNewTreeMultisetDerived
 Body: {
    TreeMultiset<DerivedComparable> set = TreeMultiset.create();
    assertTrue(set.isEmpty());
    set.add(new DerivedComparable("foo"), 2);
    set.add(new DerivedComparable("bar"), 3);
    assertThat(set)
        .containsExactly(
            new DerivedComparable("bar"),
            new DerivedComparable("bar"),
            new DerivedComparable("bar"),
            new DerivedComparable("foo"),
            new DerivedComparable("foo"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: isEmpty - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: MultisetsTest
 Method: testNewTreeMultisetNonGeneric
 Body: {
    TreeMultiset<LegacyComparable> set = TreeMultiset.create();
    assertTrue(set.isEmpty());
    set.add(new LegacyComparable("foo"), 2);
    set.add(new LegacyComparable("bar"), 3);
    assertThat(set)
        .containsExactly(
            new LegacyComparable("bar"),
            new LegacyComparable("bar"),
            new LegacyComparable("bar"),
            new LegacyComparable("foo"),
            new LegacyComparable("foo"))
        .inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: add=2 ) - Predicate: isEmpty - Scenario: set (Alternative Scenario: set=1 )

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testMultimapCreateFromTreeMultimap
 Body: {
    TreeMultimap<String, Integer> tree =
        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
    tree.put("google", 2);
    tree.put("google", 6);
    tree.put("tree", 0);
    tree.put("tree", 3);
    assertThat(tree.keySet()).containsExactly("tree", "google").inOrder();
    assertThat(tree.get("google")).containsExactly(6, 2).inOrder();

    TreeMultimap<String, Integer> copy = TreeMultimap.create(tree);
    assertEquals(tree, copy);
    assertThat(copy.keySet()).containsExactly("google", "tree").inOrder();
    assertThat(copy.get("google")).containsExactly(2, 6).inOrder();
    assertEquals(Ordering.natural(), copy.keyComparator());
    assertEquals(Ordering.natural(), copy.valueComparator());
    assertEquals(Ordering.natural(), copy.get("google").comparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=4 ) - Predicate: N/A - Scenario: tree (Alternative Scenario: tree=1 )

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testMultimapComparators
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 3);
    multimap.put("bar", 1);
    multimap.putAll("foo", Arrays.asList(-1, 2, 4));
    multimap.putAll("bar", Arrays.asList(2, 3));
    multimap.put("foo", 1);
    TreeMultimap<String, Integer> copy =
        TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);
    copy.putAll(multimap);
    assertEquals(multimap, copy);
    assertEquals(StringLength.COMPARATOR, copy.keyComparator());
    assertEquals(DECREASING_INT_COMPARATOR, copy.valueComparator());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: putAll (Alternative Action: putAll=3 ) - Predicate: N/A - Scenario: copy (Alternative Scenario: copy=1 )

Project: guava
 Class: TreeMultimapExplicitTest
 Method: testToString
 Body: {
    Multimap<String, Integer> multimap = create();
    multimap.put("foo", 3);
    multimap.put("bar", 1);
    multimap.putAll("foo", Arrays.asList(-1, 2, 4));
    multimap.putAll("bar", Arrays.asList(2, 3));
    multimap.put("foo", 1);
    assertEquals("{bar=[3, 2, 1], foo=[4, 3, 2, 1, -1]}", multimap.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: put (Alternative Action: put=3 ) - Predicate: toString - Scenario: multimap (Alternative Scenario: multimap=1 )

Project: guava
 Class: FluentIterableTest
 Method: testAllMatch
 Body: {
    List<String> list = Lists.newArrayList();
    FluentIterable<String> iterable = FluentIterable.<String>from(list);
    Predicate<String> predicate = Predicates.equalTo("cool");

    assertTrue(iterable.allMatch(predicate));
    list.add("cool");
    assertTrue(iterable.allMatch(predicate));
    list.add("pants");
    assertFalse(iterable.allMatch(predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: allMatch=3 ) - Predicate: allMatch - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: FluentIterableTest
 Method: testSkip_structurallyModifiedSkipAllList
 Body: {
    List<String> list = Lists.newArrayList("a", "b", "c");
    FluentIterable<String> tail = FluentIterable.from(list).skip(2);
    list.subList(0, 2).clear();
    assertThat(tail).isEmpty();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: subList=1 ) - Predicate: N/A - Scenario: tail (Alternative Scenario: tail=1 )

Project: guava
 Class: FluentIterableTest
 Method: testCycle_removingAllElementsStopsCycle
 Body: {
    FluentIterable<Integer> cycle = fluent(1, 2).cycle();
    Iterator<Integer> iterator = cycle.iterator();
    iterator.next();
    iterator.remove();
    iterator.next();
    iterator.remove();
    assertFalse(iterator.hasNext());
    assertFalse(cycle.iterator().hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: next (Alternative Action: next=2 ) - Predicate: hasNext - Scenario: iterator (Alternative Scenario: iterator=1 )

Project: guava
 Class: FluentIterableTest
 Method: testSkip_structurallyModifiedSkipSomeList
 Body: {
    List<String> list = Lists.newArrayList("a", "b", "c");
    FluentIterable<String> tail = FluentIterable.from(list).skip(1);
    list.subList(1, 3).clear();
    list.addAll(0, Lists.newArrayList("X", "Y", "Z"));
    assertThat(tail).containsExactly("Y", "Z", "a").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: clear (Alternative Action: newArrayList=2 ) - Predicate: N/A - Scenario: tail (Alternative Scenario: tail=1 )

Project: guava
 Class: FluentIterableTest
 Method: testSkip_structurallyModifiedSkipSome
 Body: {
    Collection<String> set = Sets.newLinkedHashSet();
    Collections.addAll(set, "a", "b", "c");
    FluentIterable<String> tail = FluentIterable.from(set).skip(1);
    set.remove("b");
    set.addAll(Lists.newArrayList("X", "Y", "Z"));
    assertThat(tail).containsExactly("c", "X", "Y", "Z").inOrder();
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: addAll=2 ) - Predicate: N/A - Scenario: tail (Alternative Scenario: set=1 )

Project: guava
 Class: FluentIterableTest
 Method: testConcatIterable
 Body: {
    List<Integer> list1 = newArrayList(1);
    List<Integer> list2 = newArrayList(4);

    @SuppressWarnings("unchecked")
    List<List<Integer>> input = newArrayList(list1, list2);

    FluentIterable<Integer> result = FluentIterable.concat(input);
    assertEquals(asList(1, 4), newArrayList(result));

    // Now change the inputs and see result dynamically change as well

    list1.add(2);
    List<Integer> list3 = newArrayList(3);
    input.add(1, list3);

    assertEquals(asList(1, 2, 3, 4), newArrayList(result));
    assertEquals("[1, 2, 3, 4]", result.toString());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: newArrayList=6 ) - Predicate: asList - Scenario: list1 (Alternative Scenario: result=1 )

Project: guava
 Class: FluentIterableTest
 Method: testAnyMatch
 Body: {
    ArrayList<String> list = Lists.newArrayList();
    FluentIterable<String> iterable = FluentIterable.<String>from(list);
    Predicate<String> predicate = Predicates.equalTo("pants");

    assertFalse(iterable.anyMatch(predicate));
    list.add("cool");
    assertFalse(iterable.anyMatch(predicate));
    list.add("pants");
    assertTrue(iterable.anyMatch(predicate));
  }
 Pattern Name: NormalPattern_AnyLOC - Action: add (Alternative Action: anyMatch=3 ) - Predicate: anyMatch - Scenario: list (Alternative Scenario: predicate=1 )

Project: guava
 Class: FluentIterableTest
 Method: testSkip_structurallyModifiedSkipAll
 Body: {
    Collection<String> set = Sets.newLinkedHashSet();
    Collections.addAll(set, "a", "b", "c");
    FluentIterable<String> tail = FluentIterable.from(set).skip(2);
    set.remove("a");
    set.remove("b");
    assertFalse(tail.iterator().hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: remove (Alternative Action: remove=2 ) - Predicate: hasNext - Scenario: tail (Alternative Scenario: set=1 )

Project: guava
 Class: FluentIterableTest
 Method: testSkip_nonStructurallyModifiedList
 Body: {
    List<String> list = Lists.newArrayList("a", "b", "c");
    FluentIterable<String> tail = FluentIterable.from(list).skip(1);
    Iterator<String> tailIterator = tail.iterator();
    list.set(2, "c2");
    assertEquals("b", tailIterator.next());
    assertEquals("c2", tailIterator.next());
    assertFalse(tailIterator.hasNext());
  }
 Pattern Name: NormalPattern_AnyLOC - Action: set (Alternative Action: next=2 ) - Predicate: next - Scenario: tailIterator (Alternative Scenario: tailIterator=1 )

